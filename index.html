<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mosi圖片轉房間數據產生器</title>
    <style>
        @font-face {
            font-family: 'fakePearl';
            src: url('static/FakePearl-SemiBold.ttf') format('woff2'), url('static/FakePearl-SemiBold.ttf') format('ttf');
            font-weight: normal;
            font-style: normal;
        }
        * {
            box-sizing: border-box;
            font-family: "fakePearl", sans-serif;
            text-align: center;
        }
        html, body {
            background-color: #594a54;
            color: #d3cbd0;
        }
        a {
            color: #f69f8f;
        }
        canvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: pixelated;
        }
        input[type="file"] {
            padding: 1em 0;
            width: 256px;
        }
        input[type="text"], button {
            width: 14em;
            margin: 1em;
            padding: 0.25em;
            font-size: 1em;
        }
        label {
            display: flex;
            flex-wrap: wrap;
            align-content: center;
            justify-content: center;
            align-items: center;
        }
        textarea {
            height: 256px;
            width: 256px;
            font-family: monospace;
        }
        textarea, input {
            text-align: left;
            margin: 1em;
            padding: 0.25em;
            font-size: 1em;
        }
        .flex-container {
            background-color: #d3cbd0;
            display: flex;
            flex-flow: row wrap;
        }
        .section {
            margin: 0 auto;
            background-color: #d3cbd0;
            color: #594a54;
            width: 256px;
            padding-bottom: 1em;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-content: space-between;
        }
        .settings-container {
            display: flex;
            justify-content: space-between;
        }
        .sprite-settings, .room-settings {
            flex: 1;
            box-sizing: border-box;
        }
        @media (max-width: 768px) {
            .settings-container {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            .sprite-settings, .room-settings {
                flex: none;
                width: 100%;
            }
        }
        #preview-container {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #quantized-preview-container {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #preview {
            margin: 0 auto;
            width: 256px;
        }
        #quantized-preview {
            margin: 0 auto;
            width: 256px;
            margin-left: 10px;
        }
        #file-list {
            list-style-type: none;
            padding: 0;
            border: 2px dashed #594A54;
            border-radius: 8px;
            margin-top: 10px;
            max-width: 400px;
        }
        #file-list li {
            display: flex;
            align-items: center;
            padding: 10px;
            margin: 5px;
            background-color: #D3CBD0;
            border: 1px solid #594A54;
            border-radius: 5px;
            cursor: grab;
            transition: background-color 0.3s;
        }
        #file-list li img {
            width: 24px;
            height: 24px;
            margin-right: 10px;
        }
        #file-list li.drag-hover {
            background-color: #9c758f;
            border-color: #594A54;
        }
        #file-list.dragging {
            border: 2px dashed #594A54;
        }
        .error {
            color: #ff6b6b;
            background-color: #ffe6e6;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .success {
            color: #51cf66;
            background-color: #ebfbee;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        #mergeSpriteFileList {
        list-style-type: none;
        padding: 0;
        border: 2px dashed #594A54;
        border-radius: 8px;
        margin-top: 10px;
        max-width: 400px;
        }
        #mergeSpriteFileList li {
        display: flex;
        align-items: center;
        padding: 10px;
        margin: 5px;
        background-color: #D3CBD0;
        border: 1px solid #594A54;
        border-radius: 5px;
        cursor: grab;
        transition: background-color 0.3s;
        }
        #mergeSpriteFileList li img {
        width: 24px;
        height: 24px;
        margin-right: 10px;
        }
        #mergeSpriteFileList li.drag-hover {
        background-color: #9c758f;
        border-color: #594A54;
        }
        #mergeSpriteFileList.dragging {
        border: 2px dashed #594A54;
        }

        
        #mergePictureFileList {
        list-style-type: none;
        padding: 0;
        border: 2px dashed #594A54;
        border-radius: 8px;
        margin-top: 10px;
        max-width: 400px;
        }
        #mergePictureFileList li {
        display: flex;
        align-items: center;
        padding: 10px;
        margin: 5px;
        background-color: #D3CBD0;
        border: 1px solid #594A54;
        border-radius: 5px;
        cursor: grab;
        transition: background-color 0.3s;
        }
        #mergePictureFileList li img {
        width: 24px;
        height: 24px;
        margin-right: 10px;
        }
        #mergePictureFileList li.drag-hover {
        background-color: #9c758f;
        border-color: #594A54;
        }
        #mergePictureFileList.dragging {
        border: 2px dashed #594A54;
        }
        /* Tab 樣式 */
        .tab-layout {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            /* min-height: 600px; */ /* 移除固定高度 */
        }
        .tab-bar, #tab-select, #tab-category-select {
            margin-right: 0;
        }
        .tab-bar {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            min-width: 140px;
            max-width: 200px;
            background: #d3cbd0;
            border-radius: 10px 0 0 10px;
            box-shadow: 2px 0 8px rgba(0,0,0,0.04);
            height: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-sizing: border-box;
        }
        .accordion-group {
            width: 100%;
            box-sizing: border-box;
        }
        .tab-bar button,
        .tab-bar .tab-btn,
        .tab-bar .accordion-btn {
            width: 100% !important;
            min-width: 0;
            max-width: 100%;
            display: block;
            box-sizing: border-box;
            margin: 0 !important;
        }
        .accordion-btn, .tab-bar button, .tab-bar .tab-btn {
            box-sizing: border-box;
            border: none;
            outline: none;
            background: #bbaec0;
            color: #594a54;
            font-size: 1.1em;
            text-align: left;
            padding: 12px 16px;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            border-radius: 0;
            margin: 0;
        }
        .accordion-btn.active, .accordion-btn:hover {
            background: #594a54;
            color: #fff;
        }
        .accordion-panel {
            display: none;
            flex-direction: column;
            align-items: stretch;
            padding: 0;
            background: #e7e0e7;
            margin-bottom: 8px;
            width: 100%;
        }
        .accordion-panel .tab-btn {
            border-left: 5px solid transparent;
            border-radius: 0;
            padding: 10px 16px;
            background: none;
            color: #594a54;
            font-size: 1em;
            text-align: left;
            transition: background 0.2s, color 0.2s, border-color 0.2s;
        }
        .accordion-panel .tab-btn.active {
            background: #594a54;
            color: #d3cbd0;
            border-left: 5px solid #f69f8f;
        }
        .tab-content {
            flex: 1;
            min-width: 0;
            max-width: 600px;
            width: 100%;
            height: 600px;
            overflow-y: auto;
            background: #d3cbd0;
            border-radius: 0 10px 10px 0;
            box-sizing: border-box;
        }
        .tab-section { display: none; }
        .tab-section.active { display: block; }
        /* 響應式：手機版用下拉選單 */
        @media (max-width: 900px) {
            .tab-layout { flex-direction: column; min-height: 0; }
            .tab-bar { display: none !important; }
            #tab-select, #tab-category-select {
                display: block !important;
                margin: 1em auto 0.5em auto;
                width: 90%;
                max-width: 400px;
                font-size: 1.1em;
                background: #d3cbd0;
                color: #594a54;
                border: 1px solid #594a54;
                border-radius: 8px;
                padding: 0.7em 1em;
                box-shadow: 1px 1px 6px rgba(0,0,0,0.04);
            }
            .tab-content {
                max-width: 100%;
                height: auto;
                border-radius: 10px;
            }
        }
        #tab-select, #tab-category-select { display: none; }
        .header-toggle-btn {
            position: absolute;
            top: 18px;
            right: 24px;
            background: #d3cbd0;
            color: #594a54;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            font-size: 1.5em;
            cursor: pointer;
            box-shadow: 1px 1px 6px rgba(0,0,0,0.06);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, color 0.2s, transform 0.2s;
            z-index: 10;
        }
        .preview-arrow-btn {
            color: #d3cbd0;
            background: #594a54;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            font-size: 1.5em;
            cursor: pointer;
            box-shadow: 1px 1px 6px rgba(0,0,0,0.06);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, color 0.2s, transform 0.2s;
            z-index: 10;
        }
        .header-toggle-btn:hover {
            background: #f69f8f;
            color: #fff;
        }
        .preview-arrow-btn:hover {
            background: #f69f8f;
            color: #fff;
        }
        .header-collapsed {
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-height 0.3s, opacity 0.3s;
            padding-bottom: 0 !important;
        }
        .header-content {
            transition: max-height 0.3s, opacity 0.3s;
        }
        .header-toggle-btn.rotate {
            transform: rotate(180deg);
        }
        header { position: relative; }
    </style>
    <link rel="icon" href="static/黑科技.png" type="image/x-icon">
</head>
<body>
    <header>
        <button class="header-toggle-btn" id="headerToggleBtn" title="開合說明">▼</button>
        <div class="header-content" id="headerContent">
            <h1>Mosi圖片轉房間數據產生器</h1>
            <p>轉換任何圖片至<a href="https://ebluvu.itch.io/mosi-ch">Mosi中文版</a>的房間數據</p>
            <p><a href="https://ebluvu.notion.site/M-si-5216b6a6c587449cb18c31ddd0dee61b">關於</a>｜有任何疑問歡迎聯繫我</p>
            <p style="color: #f69f8f; font-weight: bold;">✨ 純前端版本 - 無需伺服器，可直接在瀏覽器中運行 ✨</p>
        </div>
    </header>

    <div class="tab-layout">
      <div class="tab-bar">
        <div class="accordion-group">
          <button class="accordion-btn" type="button">圖片工具</button>
          <div class="accordion-panel">
            <button class="tab-btn" data-tab="upload-img">圖片上傳</button>
            <button class="tab-btn" data-tab="sprite-settings">精靈設定</button>
            <button class="tab-btn" data-tab="room-settings">房間設定</button>
            <button class="tab-btn" data-tab="data">生成結果</button>
          </div>
        </div>
        <div class="accordion-group">
          <button class="accordion-btn" type="button">合併工具</button>
          <div class="accordion-panel">
            <button class="tab-btn" data-tab="merge-rooms">房間合併工具</button>
            <button class="tab-btn" data-tab="merge-sprite-section">合併精靈工具</button>
            <button class="tab-btn" data-tab="merge-room-section">合併房間單色精靈工具</button>
            <button class="tab-btn" data-tab="merge-world-section">世界級合併工具</button>
            <button class="tab-btn" data-tab="merge-picture-section">插圖合併工具</button>
          </div>
        </div>
        <div class="accordion-group">
          <button class="accordion-btn" type="button">轉換工具</button>
          <div class="accordion-panel">
            <button class="tab-btn" data-tab="room-to-picture-section">房間轉插圖工具</button>
            <button class="tab-btn" data-tab="textbox-skin-section">對話框皮膚轉換工具</button>
          </div>
        </div>
      </div>
      <select id="tab-category-select"></select>
      <select id="tab-select">
        <option value="upload-img">圖片上傳</option>
        <option value="sprite-settings">精靈設定</option>
        <option value="room-settings">房間設定</option>
        <option value="data">生成結果</option>
        <option value="merge-rooms">房間合併工具</option>
        <option value="merge-sprite-section">合併精靈工具</option>
        <option value="merge-room-section">合併房間單色精靈工具</option>
        <option value="merge-world-section">世界級合併工具</option>
        <option value="merge-picture-section">插圖合併工具</option>
        <option value="room-to-picture-section">房間轉插圖工具</option>
        <option value="textbox-skin-section">對話框皮膚轉換工具</option>
      </select>
      <div class="tab-content">
        <div class="flex-container">
          <div class="section tab-section active" id="upload-img">
            <h2>圖片</h2>
            <div id="preview-container">
                <img id="preview" alt="預覽" src="static/rest.png" style="max-width: 300px;">
                <div id="quantized-preview-container" style="display:none; margin-top:8px; max-width: 300px;">
                    <canvas id="quantized-preview" width="256" height="256"></canvas>
                    <div id="preview-btn-container" style="display:flex; align-items: center; justify-content: space-between;">
                        <button id="preview-prev-btn" class="preview-arrow-btn" style="display:none;">←</button>
                        <span id="preview-index-label" style="margin:0 8px;"></span>
                        <button id="preview-next-btn" class="preview-arrow-btn" style="display:none;">→</button>
                    </div>
                </div>
            </div>
            <form id="upload-form">
                <input type="file" id="file" name="file" accept="image/*" required multiple>
                <button type="submit">載入圖片</button>
            </form>
            <div id="palette-section" style="margin: 1.5em 0; padding: 1em; background: #f5f5f5; border-radius: 8px; max-width: 350px;">
                <div id="palette-preview" style="margin: 0.5em 0;"></div>
                <textarea id="paletteTextImport" placeholder="貼上調色盤 JSON 文字..." style="width:90%;height:48px;margin-bottom:4px;"></textarea><br>
                <button id="paletteTextImportBtn" style="margin: 0.5em 0;" type="button">從文字匯入調色盤</button>
                <label>上傳調色盤：<input type="file" id="paletteFile" accept=".mosipalette"></label>
            </div>
            <div id="auto-palette-section" style="margin: 1.5em 0; padding: 1em; background: #f5f5f5; border-radius: 8px; max-width: 350px; display: none;">
              <h3 style="color:#594a54;">自動產生調色盤</h3>
              <label style="margin-bottom:0.5em; color:#594a54;">調色盤名稱：<input type="text" id="autoPaletteName" value="自動產生調色盤" style="width: 10em;" /></label>
              <button id="autoPaletteBtn" style="margin:0.5em 0;">自動偵測圖片顏色</button>
              <div id="auto-multi-palette-section" style="margin: 0.5em 0 1em 0; display:none;">
                <div style="font-weight:bold; color:#594a54; margin-bottom:0.3em;">自動偵測調色盤候選：</div>
                <div id="multi-palette-preview"></div>
              </div>
              <textarea id="autoPaletteResult" style="width:90%;height:90px;display:none;"></textarea>
              <button id="autoPaletteDownloadBtn" style="margin: 0.5em 0;display:none;">下載調色盤數據</button>
            </div>
            <div id="image-info" style="display: none;">
                <p>圖片尺寸: <span id="image-size"></span></p>
                <p>建議組合:</p>
                <div id="suggestions" style="text-align: left; margin: 10px 0; padding: 10px; background: #f0f0f0; border-radius: 5px; max-height: 200px; overflow-y: auto;"></div>
            </div>
        </div>
          <form id="generate-form" style="width:100%;">
            <div class="settings-container">
              <div class="section tab-section" id="sprite-settings">
                    <h2>精靈設定</h2>
                    <label>精靈名稱: <input type="text" id="spriteName" value="sprite"></label><br>
                    <label>精靈寬度: <input type="number" id="spriteWidth" value="8" min="1" max="24"></label><br>
                    <label>精靈高度: <input type="number" id="spriteHeight" value="8" min="1" max="24"></label><br>
                    <label>是否為主角: <input type="checkbox" id="isAvatar"></label><br>
                    <label>是否為牆: <input type="checkbox" id="isWall"></label><br>
                    <label>是否為道具: <input type="checkbox" id="isItem"></label><br>
                    <label>是否為透明化: <input type="checkbox" id="isTransparent"></label><br>
                    <label>顏色索引:
                        <select id="colorIndex">
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                            <option value="4">4</option>
                            <option value="5">5</option>
                            <option value="6">6</option>
                            <option value="7">7</option>
                            <option value="8">8</option>
                        </select>
                    </label><br>
                    <div id="batch-sprite-settings" style="display:none;"></div>
                    <small style="color: #666;">※ 精靈尺寸最大為 24×24</small>
                    <small style="color: #2196F3; display: block; margin-top: 5px;">💡 修改精靈尺寸會自動計算房間尺寸</small>
                </div>
                <div class="section tab-section" id="room-settings">
                    <h2>房間設定</h2>
                    <label>房間名稱: <input type="text" id="roomName" value="room-1"></label><br>
                    <label>調色盤名稱: <input type="text" id="paletteName" value="palette-1"></label><br>
                    <label>樂曲名稱: <input type="text" id="musicName" value="song-1"></label><br>
                    <label>房間寬度: <input type="number" id="roomWidth" value="8" min="1" max="24"></label><br>
                    <label>房間長度: <input type="number" id="roomHeight" value="8" min="1" max="24"></label><br>
                    <button type="button" id="generate-room-btn">生成房間數據</button>
                    <button type="button" id="generate-picture-btn">生成插圖數據</button>
                    <button type="button" id="clearButton">重置數據</button>
                    <small style="color: #666;">※ 房間尺寸最大為 24×24</small>
                    <small style="color: #2196F3; display: block; margin-top: 5px;">💡 修改房間尺寸會自動計算精靈尺寸</small>
                </div>
            </div>
        </form>
          <div class="section tab-section" id="data">
            <h2>結果</h2>
            <div style="margin-bottom: 1em;">
              <label style="font-weight:bold;">輸出格式：</label>
            </div>
            <textarea id="output" readonly></textarea>
            <button id="download-btn" style="display: none;">下載檔案</button>
        </div>
          <div class="section tab-section" id="merge-rooms">
            <h2>房間合併工具</h2>
            <form id="merge-form">
                <label for="merge-files">上傳多個房間數據: </label>
                <input type="file" id="merge-files" name="merge-files" accept=".json,.mosiroom" multiple required>
                <ul id="file-list"></ul>
                <button type="submit">合併房間數據</button>
            </form>
            <textarea id="merge-output" style="display: none;" readonly></textarea>
            <button id="merge-download-btn" style="display: none;">下載合併後數據</button>
        </div>
          <div class="section tab-section" id="merge-sprite-section">
            <h2>合併精靈工具</h2>
            <input type="file" id="mergeSpriteInput" accept=".mosisprite,.json" multiple style="margin-bottom:10px;">
            <ul id="mergeSpriteFileList"></ul>
            <div id="mergeSpriteAttrSelect" style="display:none; margin:10px 0;"></div>
            <div id="mergeSpriteError" class="error" style="display:none;"></div>
            <button id="mergeSpriteBtn" style="margin-top:10px; display:none;">合併並下載多色精靈</button>
        </div>
          <div class="section tab-section" id="merge-room-section">
            <h2>合併房間單色精靈工具</h2>
            <input type="file" id="mergeRoomInput" accept=".mosiroom,.json" style="margin-bottom:10px;">
            <div id="mergeRoomError" class="error" style="display:none;"></div>
            <button id="mergeRoomBtn" style="margin-top:10px; display:none;">合併並下載新房間檔案</button>
        </div>
        <div class="section tab-section" id="merge-world-section">
          <h2>世界級合併工具</h2>
          <input type="file" id="mergeWorldInput" accept=".mosi,.json" style="margin-bottom:10px;">
          <div id="mergeWorldError" class="error" style="display:none;"></div>
          <button id="mergeWorldBtn" style="margin-top:10px; display:none;">合併並下載新世界檔案</button>
        </div>
        <div class="section tab-section" id="merge-picture-section">
          <h2>插圖合併工具</h2>
          <input type="file" id="mergePictureInput" accept=".mosigraphic,.json" multiple style="margin-bottom:10px;">
          <ul id="mergePictureFileList"></ul>
          <div id="mergePictureAttrSelect" style="display:none; margin:10px 0;"></div>
          <div id="mergePictureError" class="error" style="display:none;"></div>
          <button id="mergePictureBtn" style="margin-top:10px; display:none;">合併並下載多色插圖</button>
        </div>
        <div class="section tab-section" id="room-to-picture-section">
          <h2>房間轉插圖工具</h2>
          <input type="file" id="roomToPictureInput" accept=".mosiroom,.json" style="margin-bottom:10px;">
          <div id="roomToPictureError" class="error" style="display:none;"></div>
          <button id="roomToPicturePictureBtn" style="margin-top:10px; display:none;">下載插圖（mosigraphic）</button>
        </div>
        <div class="section tab-section" id="textbox-skin-section">
          <h2>對話框皮膚轉換工具</h2>
          <p style="margin-bottom:1em; color:#594a54;">根據 3x3 房間與精靈數據，自動產生對話框皮膚檔案</p>
          <label style="display:block; margin-bottom:0.5em;">選擇 .mosiroom 檔案：<input type="file" id="roomFile" accept=".mosiroom,application/json"></label>
          <label style="display:block; margin-bottom:0.5em;">選擇 .mosisprite 檔案：<input type="file" id="spriteFile" accept=".mosisprite,application/json"></label>
          <button id="convertTextboxSkinBtn" style="margin-bottom:1em;">下載對話框皮膚</button>
          <div id="textboxSkinResult"></div>
        </div>
        </div>
      </div>
    </div>

    <script>
        let currentImages = []; // 支援多圖
        let batchMode = false;
        let allImagesLoaded = false;
        let batchResults = [];
        let userHasManualInput = false; // <--- 新增：用戶是否手動輸入過尺寸
        // ===== palette 相關 =====
        let currentPalette = null; // [[r,g,b], ...]
        let paletteName = "";
        // ========== 新增：全域 tab 狀態同步變數 ==========
        let currentTabId = 'upload-img';

        const uploadForm = document.getElementById("upload-form");
        const generateForm = document.getElementById("generate-form");
        const preview = document.getElementById("preview");
        const output = document.getElementById("output");
        const downloadBtn = document.getElementById("download-btn");
        const mergeFilesInput = document.getElementById("merge-files");
        const fileList = document.getElementById("file-list");
        const imageInfo = document.getElementById("image-info");
        const imageSize = document.getElementById("image-size");
        const suggestions = document.getElementById("suggestions");

        // 初始化自動計算功能
        setupAutoCalculation();

        // 圖片載入處理
        uploadForm.addEventListener("submit", async (e) => {
            e.preventDefault();
            const fileInput = document.getElementById('file');
            const files = Array.from(fileInput.files);
            if (!files.length) {
                showMessage('請選擇圖片檔案', 'error');
                return;
            }
            currentImages = [];
            batchMode = files.length > 1;
            allImagesLoaded = false;
            userHasManualInput = false; // <--- 新增：重新上傳圖片時重設
            // 禁用生成按鈕直到全部載入
            disableGenerateButtons();
            // 預覽第一張
            const firstFile = files[0];
            const img = new Image();
            img.onload = function() {
                preview.src = URL.createObjectURL(firstFile);
                preview.style.display = "block";
                generateForm.style.display = "block";
                imageSize.textContent = `${img.width} x ${img.height}`;
                const suggestions = calculateSuggestions(img.width, img.height);
                displaySuggestions(suggestions);
                imageInfo.style.display = "block";
                if (suggestions.length > 0) {
                    const firstSuggestion = suggestions[0];
                    document.getElementById("spriteWidth").value = firstSuggestion.spriteWidth;
                    document.getElementById("spriteHeight").value = firstSuggestion.spriteHeight;
                    document.getElementById("roomWidth").value = firstSuggestion.roomWidth;
                    document.getElementById("roomHeight").value = firstSuggestion.roomHeight;
                }
                // ===== palette 色階化預覽 =====
                const qContainer = document.getElementById('quantized-preview-container');
                const qCanvas = document.getElementById('quantized-preview');
                if (currentPalette) {
                  // 取得原圖像素
                  const ctx = document.createElement('canvas').getContext('2d');
                  ctx.canvas.width = img.width;
                  ctx.canvas.height = img.height;
                  ctx.drawImage(img, 0, 0);
                  const imgData = ctx.getImageData(0, 0, img.width, img.height);
                  // 色階化
                  const quantized = quantizeToPalette(imgData.data, currentPalette);
                  // 顯示預覽
                  qCanvas.width = img.width;
                  qCanvas.height = img.height;
                  qContainer.style.display = "block";
                  drawQuantizedPreview(qCanvas, img.width, img.height, quantized, currentPalette);
                  // 儲存 quantized 結果到 currentImages[0].quantized
                  if (!currentImages[0]) currentImages[0] = {};
                  currentImages[0].quantized = quantized;
                  currentImages[0].quantizedWidth = img.width;
                  currentImages[0].quantizedHeight = img.height;
                } else {
                  qContainer.style.display = "none";
                  if (currentImages[0]) {
                    delete currentImages[0].quantized;
                    delete currentImages[0].quantizedWidth;
                    delete currentImages[0].quantizedHeight;
                  }
                }
                showMessage('圖片載入成功！', 'success');
            };
            img.onerror = function() {
                showMessage('圖片載入失敗，請檢查檔案格式', 'error');
            };
            img.src = URL.createObjectURL(firstFile);
            // 批量模式下預先載入所有圖片
            if (batchMode) {
                let loaded = 0;
                currentImages = new Array(files.length);
                files.forEach((file, idx) => {
                    const img = new Image();
                    img.onload = function() {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                        currentImages[idx] = {
                            width: img.width,
                            height: img.height,
                            canvas: canvas,
                            context: ctx,
                            fileName: file.name,
                            spriteName: `sprite${idx+1}`,
                            colorIndex: 1
                        };
                        // ===== 新增：多圖也要 quantized =====
                        if (currentPalette) {
                            const imgData = ctx.getImageData(0, 0, img.width, img.height);
                            currentImages[idx].quantized = quantizeToPalette(imgData.data, currentPalette);
                            currentImages[idx].quantizedWidth = img.width;
                            currentImages[idx].quantizedHeight = img.height;
                            console.log('[批量模式] quantized 寫入 currentImages['+idx+']', {
                              quantized: currentImages[idx].quantized.slice(0, 32),
                              quantizedLen: currentImages[idx].quantized.length
                            });
                        }
                        loaded++;
                        if (loaded === files.length) {
                            allImagesLoaded = true;
                            enableGenerateButtons();
                            showMessage('所有圖片已載入完成，可生成數據', 'success');
                            renderBatchSpriteSettings();
                            currentPreviewIndex = 0;
                            updateQuantizedPreview();
                            updateColorIndexAndPaletteNameUI();
                            updatePreviewVisibility();
                            showAutoPaletteSection(true);
                        }
                    };
                    img.onerror = function() {
                        showMessage(`第${idx+1}張圖片載入失敗`, 'error');
                    };
                    img.src = URL.createObjectURL(file);
                });
            } else {
                // 單圖模式
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    currentImages = [{
                        width: img.width,
                        height: img.height,
                        canvas: canvas,
                        context: ctx,
                        fileName: firstFile.name
                    }];
                    // ===== 修正：單圖模式也要存 quantized =====
                    if (currentPalette) {
                        const imgData = ctx.getImageData(0, 0, img.width, img.height);
                        currentImages[0].quantized = quantizeToPalette(imgData.data, currentPalette);
                        currentImages[0].quantizedWidth = img.width;
                        currentImages[0].quantizedHeight = img.height;
                        console.log('[單圖模式] quantized 寫入 currentImages[0]', {
                          quantized: currentImages[0].quantized.slice(0, 32),
                          quantizedLen: currentImages[0].quantized.length
                        });
                    }
                    allImagesLoaded = true;
                    enableGenerateButtons();
                    renderBatchSpriteSettings();
                    currentPreviewIndex = 0;
                    updateQuantizedPreview();
                    updateColorIndexAndPaletteNameUI();
                    updatePreviewVisibility();
                    showAutoPaletteSection(true);
                };
                img.src = URL.createObjectURL(firstFile);
            }
        });

        // 生成數據處理
        const generateRoomBtn = document.getElementById("generate-room-btn");
        const generatePictureBtn = document.getElementById("generate-picture-btn");

        generateRoomBtn.onclick = function(e) {
            e.preventDefault();
            generateMainData('room');
        };
        generatePictureBtn.onclick = function(e) {
            e.preventDefault();
            generateMainData('picture');
        };

        function generateMainData(type) {
            if (batchMode) {
                if (!currentImages.length || !allImagesLoaded) {
                    showMessage('請先載入所有圖片', 'error');
                    return;
                }
                // 取得設定
                const data = {
                    spriteName: document.getElementById("spriteName").value,
                    spriteWidth: parseInt(document.getElementById("spriteWidth").value),
                    spriteHeight: parseInt(document.getElementById("spriteHeight").value),
                    isAvatar: document.getElementById("isAvatar").checked,
                    isWall: document.getElementById("isWall").checked,
                    isItem: document.getElementById("isItem").checked,
                    isTransparent: document.getElementById("isTransparent").checked,
                    colorIndex: parseInt(document.getElementById("colorIndex").value),
                    roomName: document.getElementById("roomName").value,
                    paletteName: paletteName || document.getElementById("paletteName").value,
                    musicName: document.getElementById("musicName").value,
                    roomWidth: parseInt(document.getElementById("roomWidth").value),
                    roomHeight: parseInt(document.getElementById("roomHeight").value)
                };
                // 驗證
                if (data.spriteWidth <= 0 || data.spriteHeight <= 0) {
                    showMessage('精靈尺寸必須大於0', 'error');
                    return;
                }
                if (data.roomWidth <= 0 || data.roomHeight <= 0) {
                    showMessage('房間尺寸必須大於0', 'error');
                    return;
                }
                if (data.spriteWidth > 24 || data.spriteHeight > 24) {
                    showMessage('精靈尺寸不能超過24（Mosi引擎限制）', 'error');
                    return;
                }
                if (data.roomWidth > 24 || data.roomHeight > 24) {
                    showMessage('房間尺寸不能超過24（Mosi引擎限制）', 'error');
                    return;
                }
                batchResults = [];
                let failCount = 0;
                for (let i = 0; i < currentImages.length; i++) {
                    try {
                        // 取得每張圖的 spriteName/colorIndex
                        const dataPerImg = {
                            ...data,
                            spriteName: currentImages[i].spriteName || data.spriteName,
                            colorIndex: currentImages[i].colorIndex || data.colorIndex
                        };
                        let resultData;
                        if (currentPalette && currentImages[i].quantized) {
                          // 多色模式
                          if (type === 'picture') {
                            resultData = processQuantizedToPictureData(currentImages[i], dataPerImg, currentPalette);
                          } else {
                            resultData = processQuantizedToRoomData(currentImages[i], dataPerImg, currentPalette);
                          }
                          console.log('[generateMainData] 多色模式', {i, resultData});
                        } else {
                          // 單色模式
                          if (type === 'picture') {
                            resultData = processImageToPictureData(currentImages[i], dataPerImg);
                          } else {
                            resultData = processImageToRoomData(currentImages[i], dataPerImg);
                          }
                          console.log('[generateMainData] 單色模式', {i, resultData});
                        }
                        batchResults.push({
                            data: resultData,
                            fileName: dataPerImg.spriteName || data.roomName
                        });
                    } catch (error) {
                        showMessage(`第${i+1}張圖片處理失敗: ${error.message}`, 'error');
                        failCount++;
                    }
                }
                if (batchResults.length === 0) {
                    showMessage('所有圖片處理都失敗，無可下載數據', 'error');
                    return;
                }
                // 隱藏文字框，顯示一鍵下載
                output.style.display = "none";
                downloadBtn.style.display = "none";
                // 先移除舊的 batch-download-btn
                let oldBatchBtn = document.getElementById('batch-download-btn');
                if (oldBatchBtn) oldBatchBtn.remove();
                // 新建一個按鈕
                let batchBtn = document.createElement('button');
                batchBtn.id = 'batch-download-btn';
                batchBtn.textContent = '一鍵下載所有檔案';
                batchBtn.style.margin = '1em';
                downloadBtn.parentNode.insertBefore(batchBtn, downloadBtn.nextSibling);
                batchBtn.onclick = function() {
                    console.log('batchResults:', batchResults);
                    if (!batchResults.length) {
                        showMessage('沒有可下載的數據', 'error');
                        return;
                    }
                    batchResults.forEach((r, idx) => {
                        let ext = ".json";
                        let minified = false;
                        if (r.data && r.data.type === "picture") { ext = ".mosigraphic"; minified = true; }
                        else if (r.data && r.data.frameList) { ext = ".mosisprite"; minified = true; }
                        else if (r.data && (r.data.roomName || r.data.name) && r.data.tileList) { ext = ".mosiroom"; minified = true; }
                        else if (r.data && r.data.roomList) { ext = ".mosi"; minified = true; }
                        let content = minified ? JSON.stringify(r.data) : JSON.stringify(r.data, null, 4);
                        const blob = new Blob([content], { type: "application/json" });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement("a");
                        a.href = url;
                        a.download = `${r.fileName}${ext}`;
                        a.click();
                        URL.revokeObjectURL(url);
                    });
                };
                showMessage('批量數據生成成功！', 'success');
                return;
            }
            if (!currentImages.length || !allImagesLoaded) {
                showMessage('請先載入圖片', 'error');
                return;
            }
            
            try {
                // 獲取設定值
                const data = {
                    spriteName: document.getElementById("spriteName").value,
                    spriteWidth: parseInt(document.getElementById("spriteWidth").value),
                    spriteHeight: parseInt(document.getElementById("spriteHeight").value),
                    isAvatar: document.getElementById("isAvatar").checked,
                    isWall: document.getElementById("isWall").checked,
                    isItem: document.getElementById("isItem").checked,
                    isTransparent: document.getElementById("isTransparent").checked,
                    colorIndex: parseInt(document.getElementById("colorIndex").value),
                    roomName: document.getElementById("roomName").value,
                    paletteName: paletteName || document.getElementById("paletteName").value,
                    musicName: document.getElementById("musicName").value,
                    roomWidth: parseInt(document.getElementById("roomWidth").value),
                    roomHeight: parseInt(document.getElementById("roomHeight").value)
                };
                let resultData;
                if (currentPalette && currentImages[0].quantized) {
                  // 多色模式
                  if (type === 'picture') {
                    resultData = processQuantizedToPictureData(currentImages[0], data, currentPalette);
                  } else {
                    resultData = processQuantizedToRoomData(currentImages[0], data, currentPalette);
                  }
                  console.log('[generateMainData] 多色模式 resultData', resultData);
                } else {
                  // 單色模式
                  if (type === 'picture') {
                    resultData = processImageToPictureData(currentImages[0], data);
                  } else {
                    resultData = processImageToRoomData(currentImages[0], data);
                  }
                  console.log('[generateMainData] 單色模式 resultData', resultData);
                }
                output.value = (resultData && (resultData.frameList || resultData.tileList || resultData.roomList))
                    ? JSON.stringify(resultData)
                    : JSON.stringify(resultData, null, 4);
                output.style.display = "block";
                downloadBtn.style.display = "block";
                
                showMessage('數據生成成功！', 'success');
                
            } catch (error) {
                console.error('數據生成錯誤:', error);
                showMessage('數據生成時發生錯誤: ' + error.message, 'error');
            }
        }

        // 圖片處理函數
        function processImageToRoomData(image, data) {
            const { width: imgWidth, height: imgHeight, context } = image;
            const { spriteWidth, spriteHeight, roomWidth, roomHeight } = data;
            
            // 計算需要的圖片尺寸
            const requiredWidth = roomWidth * spriteWidth;
            const requiredHeight = roomHeight * spriteHeight;
            
            // 檢查是否需要縮放
            let processedCanvas = image.canvas;
            let processedContext = image.context;
            let scale = 1;
            
            if (imgWidth !== requiredWidth || imgHeight !== requiredHeight) {
                // 創建新的 Canvas 進行縮放
                const scaledCanvas = document.createElement('canvas');
                const scaledContext = scaledCanvas.getContext('2d');
                
                scaledCanvas.width = requiredWidth;
                scaledCanvas.height = requiredHeight;
                
                // 使用 nearest-neighbor 縮放以保持像素風格
                scaledContext.imageSmoothingEnabled = false;
                scaledContext.drawImage(image.canvas, 0, 0, requiredWidth, requiredHeight);
                
                processedCanvas = scaledCanvas;
                processedContext = scaledContext;
                scale = requiredWidth / imgWidth;
            }
            
            // 計算每行的精靈數量
            const spritesPerRow = Math.floor(processedCanvas.width / spriteWidth);
            const totalSprites = spritesPerRow * Math.floor(processedCanvas.height / spriteHeight);
            
            // 檢查房間尺寸是否合理
            if (roomWidth * roomHeight > totalSprites) {
                throw new Error(`房間尺寸過大，圖片只能提供 ${totalSprites} 個精靈，但房間需要 ${roomWidth * roomHeight} 個`);
            }
            
            const spriteData = [];
            const tileList = [];
            const uniqueSprites = new Map();
            let validSpriteCount = 0;

            // 處理每個精靈
            for (let spriteIndex = 0; spriteIndex < roomWidth * roomHeight; spriteIndex++) {
                const x = (spriteIndex % spritesPerRow) * spriteWidth;
                const y = Math.floor(spriteIndex / spritesPerRow) * spriteHeight;
                
                // 獲取精靈區域的像素數據
                const imageData = processedContext.getImageData(x, y, spriteWidth, spriteHeight);
                const pixels = imageData.data;
                
                // 轉換為二值數據
                const binaryData = [];
                for (let i = 0; i < pixels.length; i += 4) {
                    const alpha = pixels[i + 3];
                    if (alpha < 128) {
                        binaryData.push(0); // 透明直接當 0
                    } else {
                        const gray = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
                        binaryData.push(gray < 128 ? 1 : 0);
                    }
                }
                
                // 檢查是否為空白精靈
                if (binaryData.some(pixel => pixel === 1)) {
                    const binaryKey = binaryData.join(',');
                    
                    if (!uniqueSprites.has(binaryKey)) {
                        // 新的精靈
                        validSpriteCount++;
                        const spriteName = `${data.spriteName}-${validSpriteCount.toString().padStart(2, '0')}`;
                        uniqueSprites.set(binaryKey, spriteName);
                        
                        spriteData.push({
                            name: spriteName,
                            isAvatar: data.isAvatar,
                            isWall: data.isWall,
                            isItem: data.isItem,
                            isTransparent: data.isTransparent,
                            colorIndex: data.colorIndex,
                            width: spriteWidth,
                            height: spriteHeight,
                            frameList: [binaryData],
                            scriptList: {"on-push": "", "on-message": ""}
                        });
                    }
                    
                    // 添加到瓷磚列表
                    tileList.push({
                        spriteName: uniqueSprites.get(binaryKey),
                        x: spriteIndex % roomWidth,
                        y: Math.floor(spriteIndex / roomWidth)
                    });
                }
            }
            
            // 生成房間數據
            return {
                name: data.roomName,
                paletteName: data.paletteName,
                musicName: data.musicName,
                tileList: tileList,
                scriptList: {"on-enter": "", "on-exit": ""},
                width: roomWidth,
                height: roomHeight,
                spriteWidth: spriteWidth,
                spriteHeight: spriteHeight,
                spriteList: spriteData
            };
        }

        // 下載按鈕處理
        downloadBtn.addEventListener("click", () => {
            const roomName = document.getElementById("roomName").value || "room_data";
            let ext = ".json";
            let minified = false;
            let obj = null;
            try {
                obj = JSON.parse(output.value);
                if (obj && obj.type === "picture") { ext = ".mosigraphic"; minified = true; }
                else if (obj && obj.frameList) { ext = ".mosisprite"; minified = true; }
                else if (obj && (obj.roomName || obj.name) && obj.tileList) { ext = ".mosiroom"; minified = true; }
                else if (obj && obj.roomList) { ext = ".mosi"; minified = true; }
            } catch {}
            let content = "";
            if (minified && obj) content = JSON.stringify(obj);
            else content = output.value;
            const blob = new Blob([content], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${roomName}${ext}`;
            a.click();
            URL.revokeObjectURL(url);
        });

        // 清除按鈕處理
        document.getElementById("clearButton").addEventListener("click", function () {
            // 清空圖片預覽
            const fileInput = document.getElementById("file");
            const preview = document.getElementById("preview");
            fileInput.value = "";
            preview.src = "static/rest.png";
            
            // 清空數據輸出
            const output = document.getElementById("output");
            output.value = "";
            output.style.display = "none";
            
            // 隱藏下載按鈕
            const downloadBtn = document.getElementById("download-btn");
            downloadBtn.style.display = "none";
            
            // 隱藏圖片資訊
            imageInfo.style.display = "none";
            
            // 重置圖片數據
            currentImages = [];
            batchMode = false;
            allImagesLoaded = false;
            const batchBtn = document.getElementById('batch-download-btn');
            if (batchBtn) batchBtn.style.display = 'none';
            
            showMessage('數據已清除！', 'success');
            batchResults = [];
            showAutoPaletteSection(false);
        });

        // 房間合併功能
        document.getElementById("merge-form").addEventListener("submit", async (e) => {
            e.preventDefault();

            const files = document.getElementById("merge-files").files;
            if (files.length < 2) {
                showMessage("請上傳至少兩個房間數據檔案！", 'error');
                return;
            }

            try {
                let mergedData = null;

                for (const file of files) {
                    const text = await file.text();
                    const jsonData = JSON.parse(text);

                    if (!mergedData) {
                        mergedData = { ...jsonData };
                        mergedData.spriteList = [...jsonData.spriteList];
                        mergedData.tileList = [...jsonData.tileList];
                    } else {
                        // 檢查基礎設定是否一致
                        if (
                            jsonData.roomName !== mergedData.roomName ||
                            jsonData.paletteName !== mergedData.paletteName ||
                            jsonData.musicName !== mergedData.musicName ||
                            jsonData.roomWidth !== mergedData.roomWidth ||
                            jsonData.roomHeight !== mergedData.roomHeight
                        ) {
                            showMessage(`檔案 ${file.name} 的基礎設定與其他房間不一致，無法合併！`, 'error');
                            return;
                        }

                        // 合併精靈數據
                        jsonData.spriteList.forEach(sprite => {
                            if (!mergedData.spriteList.some(s => JSON.stringify(s) === JSON.stringify(sprite))) {
                                mergedData.spriteList.push(sprite);
                            }
                        });

                        // 合併瓷磚數據
                        mergedData.tileList.push(...jsonData.tileList);
                    }
                }

                // 顯示合併後數據
                const mergeOutput = document.getElementById("merge-output");
                mergeOutput.value = (mergedData && (mergedData.frameList || mergedData.tileList || mergedData.roomList))
                    ? JSON.stringify(mergedData)
                    : JSON.stringify(mergedData, null, 4);
                mergeOutput.style.display = "block";

                // 顯示下載按鈕
                const mergeDownloadBtn = document.getElementById("merge-download-btn");
                mergeDownloadBtn.style.display = "block";

                showMessage('房間合併成功！', 'success');

            } catch (error) {
                console.error('合併錯誤:', error);
                showMessage('合併時發生錯誤: ' + error.message, 'error');
            }
        });

        // 合併下載按鈕
        document.getElementById("merge-download-btn").addEventListener("click", () => {
            const roomName = document.getElementById("roomName").value || "merged_room_data";
            const mergeOutput = document.getElementById("merge-output");
            let obj = null;
            let minified = false;
            try {
                obj = JSON.parse(mergeOutput.value);
                if (obj && obj.frameList) minified = true;
                else if (obj && (obj.roomName || obj.name) && obj.tileList) minified = true;
                else if (obj && obj.roomList) minified = true;
            } catch {}
            let content = (minified && obj) ? JSON.stringify(obj) : mergeOutput.value;
            const blob = new Blob([content], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${roomName}.mosiroom`;
            a.click();
            URL.revokeObjectURL(url);
        });

        // 檔案列表處理
        mergeFilesInput.addEventListener("change", () => {
            fileList.innerHTML = "";
            Array.from(mergeFilesInput.files).forEach((file, index) => {
                const listItem = document.createElement("li");
                listItem.innerHTML = `
                    <img src="static/file-icon.png" alt="File Icon"> ${file.name}
                `;
                listItem.draggable = true;
                listItem.dataset.index = index;
                fileList.appendChild(listItem);
            });

            // 拖曳功能
            let draggedItem = null;

            fileList.addEventListener("dragstart", (e) => {
                draggedItem = e.target;
                e.dataTransfer.effectAllowed = "move";
                fileList.classList.add("dragging");
            });

            fileList.addEventListener("dragover", (e) => {
                e.preventDefault();
                const target = e.target.closest("li");
                if (target && target !== draggedItem) {
                    target.classList.add("drag-hover");
                }
            });

            fileList.addEventListener("dragleave", (e) => {
                const target = e.target.closest("li");
                if (target) {
                    target.classList.remove("drag-hover");
                }
            });

            fileList.addEventListener("drop", (e) => {
                e.preventDefault();
                const target = e.target.closest("li");
                if (target && target !== draggedItem) {
                    fileList.insertBefore(draggedItem, target);
                }
                target.classList.remove("drag-hover");
            });

            fileList.addEventListener("dragend", () => {
                fileList.classList.remove("dragging");
                fileList.querySelectorAll("li").forEach((li) => li.classList.remove("drag-hover"));
            });
        });

        // 顯示訊息函數
        function showMessage(message, type) {
            // 移除舊的訊息
            const existingMessage = document.querySelector('.error, .success');
            if (existingMessage) {
                existingMessage.remove();
            }
            
            // 創建新訊息
            const messageDiv = document.createElement('div');
            messageDiv.className = type;
            messageDiv.textContent = message;
            
            // 插入到頁面頂部
            document.body.insertBefore(messageDiv, document.body.firstChild);
            
            // 3秒後自動移除
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.remove();
                }
            }, 3000);
        }

        // 計算建議的精靈和房間尺寸組合
        function calculateSuggestions(width, height) {
            const suggestions = [];
            
            // 常見的精靈尺寸（限制在24以內）
            const commonSpriteSizes = [4, 8, 12, 16, 20, 24];
            
            // 常見的房間尺寸（限制在24以內）
            const commonRoomSizes = [5, 8, 10, 12, 15, 16, 20, 24];
            
            // 方法1：直接檢查精靈尺寸是否能整除圖片尺寸
            for (const spriteSize of commonSpriteSizes) {
                if (width % spriteSize === 0 && height % spriteSize === 0) {
                    const roomWidth = width / spriteSize;
                    const roomHeight = height / spriteSize;
                    
                    // 檢查房間尺寸是否在限制範圍內
                    if (roomWidth <= 24 && roomHeight <= 24) {
                        const score = calculateScore(roomWidth, roomHeight, spriteSize);
                        suggestions.push({
                            spriteWidth: spriteSize,
                            spriteHeight: spriteSize,
                            roomWidth: roomWidth,
                            roomHeight: roomHeight,
                            score: score,
                            description: `${roomWidth}×${roomHeight} 房間 × ${spriteSize}×${spriteSize} 精靈`,
                            scale: 1,
                            originalSize: `${width}×${height}`
                        });
                    }
                }
            }
            
            // 方法2：如果沒有找到合適的組合，計算縮放比例
            if (suggestions.length === 0) {
                const scaledSuggestions = calculateScaledSuggestions(width, height);
                suggestions.push(...scaledSuggestions);
            }
            
            // 按評分排序，評分越高越優先
            suggestions.sort((a, b) => b.score - a.score);
            
            // 限制顯示數量
            return suggestions.slice(0, 10);
        }
        
        // 計算縮放後的建議組合
        function calculateScaledSuggestions(width, height) {
            const suggestions = [];
            const commonSpriteSizes = [4, 8, 12, 16, 20, 24];
            const commonRoomSizes = [5, 8, 10, 12, 15, 16, 20, 24];
            
            // 嘗試不同的縮放比例
            for (const roomWidth of commonRoomSizes) {
                for (const roomHeight of commonRoomSizes) {
                    for (const spriteSize of commonSpriteSizes) {
                        // 計算需要的圖片尺寸
                        const requiredWidth = roomWidth * spriteSize;
                        const requiredHeight = roomHeight * spriteSize;
                        
                        // 計算縮放比例
                        const scaleX = width / requiredWidth;
                        const scaleY = height / requiredHeight;
                        
                        // 檢查縮放比例是否合理（0.1 到 10 之間）
                        if (scaleX >= 0.1 && scaleX <= 10 && scaleY >= 0.1 && scaleY <= 10) {
                            // 使用較小的縮放比例（更保守）
                            const scale = Math.min(scaleX, scaleY);
                            
                            const score = calculateScore(roomWidth, roomHeight, spriteSize);
                            
                            // 調整評分：縮放比例越接近1越好
                            const scaleBonus = Math.max(0, 10 - Math.abs(scale - 1) * 5);
                            const finalScore = score + scaleBonus;
                            
                            suggestions.push({
                                spriteWidth: spriteSize,
                                spriteHeight: spriteSize,
                                roomWidth: roomWidth,
                                roomHeight: roomHeight,
                                score: finalScore,
                                description: `${roomWidth}×${roomHeight} 房間 × ${spriteSize}×${spriteSize} 精靈 (縮放 ${scale.toFixed(2)}x)`,
                                scale: scale,
                                originalSize: `${width}×${height}`,
                                scaledSize: `${Math.round(requiredWidth * scale)}×${Math.round(requiredHeight * scale)}`
                            });
                        }
                    }
                }
            }
            
            return suggestions;
        }
        
        // 計算建議的評分
        function calculateScore(roomWidth, roomHeight, spriteSize) {
            let score = 0;
            
            // 偏好適中的房間尺寸（8-20之間，但最大24）
            if (roomWidth >= 8 && roomWidth <= 20) score += 10;
            if (roomHeight >= 8 && roomHeight <= 20) score += 10;
            
            // 偏好適中的精靈尺寸（8-24之間）
            if (spriteSize >= 8 && spriteSize <= 24) score += 15;
            
            // 偏好正方形房間
            if (roomWidth === roomHeight) score += 5;
            
            // 偏好較小的精靈尺寸（更精細，但不要太小）
            if (spriteSize >= 8 && spriteSize <= 16) score += 10;
            
            // 偏好較小的房間尺寸（更實用，但不要太小）
            if (roomWidth >= 8 && roomWidth <= 16) score += 5;
            if (roomHeight >= 8 && roomHeight <= 16) score += 5;
            
            // 避免極端值
            if (roomWidth < 5 || roomHeight < 5) score -= 10;
            if (spriteSize < 4) score -= 10;
            
            return score;
        }
        
        // 顯示建議列表
        function displaySuggestions(suggestions) {
            const suggestionsDiv = document.getElementById("suggestions");
            
            if (suggestions.length === 0) {
                suggestionsDiv.innerHTML = '<p style="color: #666;">無法找到合適的組合，請手動調整尺寸</p>';
                return;
            }
            
            let html = '<div style="margin-bottom: 10px;"><strong>點擊選擇：</strong></div>';
            
            suggestions.forEach((suggestion, index) => {
                const isRecommended = index === 0;
                const style = isRecommended ? 
                    'background: #e8f5e8; border: 2px solid #4CAF50;' : 
                    'background: #f9f9f9; border: 1px solid #ddd;';
                
                // 添加縮放信息
                let scaleInfo = '';
                if (suggestion.scale !== 1) {
                    scaleInfo = `<div style="font-size: 0.8em; color: #ff6b35;">
                        📏 原圖: ${suggestion.originalSize} → 縮放: ${suggestion.scale.toFixed(2)}x
                    </div>`;
                }
                
                html += `
                    <div class="suggestion-item" 
                         style="${style} padding: 8px; margin: 5px 0; border-radius: 4px; cursor: pointer;"
                         onclick="selectSuggestion(${suggestion.spriteWidth}, ${suggestion.spriteHeight}, ${suggestion.roomWidth}, ${suggestion.roomHeight})">
                        <div style="font-weight: bold; color: #333;">
                            ${isRecommended ? '⭐ ' : ''}${suggestion.description}
                        </div>
                        <div style="font-size: 0.9em; color: #666;">
                            評分: ${suggestion.score} | 總精靈數: ${suggestion.roomWidth * suggestion.roomHeight}
                        </div>
                        ${scaleInfo}
                    </div>
                `;
            });
            
            suggestionsDiv.innerHTML = html;
        }
        
        // 選擇建議
        function selectSuggestion(spriteWidth, spriteHeight, roomWidth, roomHeight) {
            document.getElementById("spriteWidth").value = spriteWidth;
            document.getElementById("spriteHeight").value = spriteHeight;
            document.getElementById("roomWidth").value = roomWidth;
            document.getElementById("roomHeight").value = roomHeight;
            
            showMessage(`已選擇: ${roomWidth}×${roomHeight} 房間 × ${spriteWidth}×${spriteHeight} 精靈`, 'success');
        }

        // 自動計算功能
        function setupAutoCalculation() {
            const spriteWidthInput = document.getElementById("spriteWidth");
            const spriteHeightInput = document.getElementById("spriteHeight");
            const roomWidthInput = document.getElementById("roomWidth");
            const roomHeightInput = document.getElementById("roomHeight");

            // 添加防抖功能
            let spriteTimeout, roomTimeout;

            // 精靈尺寸變更時，自動計算房間尺寸
            spriteWidthInput.addEventListener("input", () => {
                userHasManualInput = true; // <--- 新增：偵測手動輸入
                clearTimeout(spriteTimeout);
                spriteTimeout = setTimeout(autoCalculateRoomSize, 300);
            });
            spriteHeightInput.addEventListener("input", () => {
                userHasManualInput = true;
                clearTimeout(spriteTimeout);
                spriteTimeout = setTimeout(autoCalculateRoomSize, 300);
            });

            // 房間尺寸變更時，自動計算精靈尺寸
            roomWidthInput.addEventListener("input", () => {
                userHasManualInput = true;
                clearTimeout(roomTimeout);
                roomTimeout = setTimeout(autoCalculateSpriteSize, 300);
            });
            roomHeightInput.addEventListener("input", () => {
                userHasManualInput = true;
                clearTimeout(roomTimeout);
                roomTimeout = setTimeout(autoCalculateSpriteSize, 300);
            });
        }

        // 自動計算房間尺寸
        function autoCalculateRoomSize() {
            if (userHasManualInput) return; // <--- 新增：用戶手動輸入後不再自動聯動
            if (!currentImages.length || !currentImages[0]) return;
            const spriteWidth = parseInt(document.getElementById("spriteWidth").value) || 0;
            const spriteHeight = parseInt(document.getElementById("spriteHeight").value) || 0;
            if (spriteWidth > 0 && spriteHeight > 0) {
                // 計算房間尺寸
                const roomWidth = Math.floor(currentImages[0].width / spriteWidth);
                const roomHeight = Math.floor(currentImages[0].height / spriteHeight);
                // 檢查是否在限制範圍內
                if (roomWidth <= 24 && roomHeight <= 24 && roomWidth > 0 && roomHeight > 0) {
                    // 暫時移除事件監聽器避免循環
                    const roomWidthInput = document.getElementById("roomWidth");
                    const roomHeightInput = document.getElementById("roomHeight");
                    roomWidthInput.removeEventListener("input", autoCalculateSpriteSize);
                    roomHeightInput.removeEventListener("input", autoCalculateSpriteSize);
                    roomWidthInput.value = roomWidth;
                    roomHeightInput.value = roomHeight;
                    // 重新添加事件監聽器
                    setTimeout(() => {
                        roomWidthInput.addEventListener("input", autoCalculateSpriteSize);
                        roomHeightInput.addEventListener("input", autoCalculateSpriteSize);
                    }, 100);
                    // 顯示計算信息
                    showCalculationInfo(`自動計算: ${roomWidth}×${roomHeight} 房間`);
                } else {
                    // 如果超出限制，顯示警告
                    const maxRoomWidth = Math.min(24, Math.floor(currentImages[0].width / spriteWidth));
                    const maxRoomHeight = Math.min(24, Math.floor(currentImages[0].height / spriteHeight));
                    if (maxRoomWidth > 0 && maxRoomHeight > 0) {
                        const roomWidthInput = document.getElementById("roomWidth");
                        const roomHeightInput = document.getElementById("roomHeight");
                        roomWidthInput.removeEventListener("input", autoCalculateSpriteSize);
                        roomHeightInput.removeEventListener("input", autoCalculateSpriteSize);
                        roomWidthInput.value = maxRoomWidth;
                        roomHeightInput.value = maxRoomHeight;
                        setTimeout(() => {
                            roomWidthInput.addEventListener("input", autoCalculateSpriteSize);
                            roomHeightInput.addEventListener("input", autoCalculateSpriteSize);
                        }, 100);
                        showCalculationInfo(`已調整至最大可用尺寸: ${maxRoomWidth}×${maxRoomHeight} 房間`);
                    } else {
                        showCalculationInfo(`精靈尺寸過大，無法計算合適的房間尺寸`, 'warning');
                    }
                }
            }
        }

        // 自動計算精靈尺寸
        function autoCalculateSpriteSize() {
            if (userHasManualInput) return; // <--- 新增：用戶手動輸入後不再自動聯動
            if (!currentImages.length || !currentImages[0]) return;
            const roomWidth = parseInt(document.getElementById("roomWidth").value) || 0;
            const roomHeight = parseInt(document.getElementById("roomHeight").value) || 0;
            if (roomWidth > 0 && roomHeight > 0) {
                // 計算精靈尺寸
                const spriteWidth = Math.floor(currentImages[0].width / roomWidth);
                const spriteHeight = Math.floor(currentImages[0].height / roomHeight);
                // 檢查是否在限制範圍內
                if (spriteWidth <= 24 && spriteHeight <= 24 && spriteWidth > 0 && spriteHeight > 0) {
                    // 暫時移除事件監聽器避免循環
                    const spriteWidthInput = document.getElementById("spriteWidth");
                    const spriteHeightInput = document.getElementById("spriteHeight");
                    spriteWidthInput.removeEventListener("input", autoCalculateRoomSize);
                    spriteHeightInput.removeEventListener("input", autoCalculateRoomSize);
                    spriteWidthInput.value = spriteWidth;
                    spriteHeightInput.value = spriteHeight;
                    // 重新添加事件監聽器
                    setTimeout(() => {
                        spriteWidthInput.addEventListener("input", autoCalculateRoomSize);
                        spriteHeightInput.addEventListener("input", autoCalculateRoomSize);
                    }, 100);
                    // 顯示計算信息
                    showCalculationInfo(`自動計算: ${spriteWidth}×${spriteHeight} 精靈`);
                } else {
                    // 如果超出限制，顯示警告
                    const maxSpriteWidth = Math.min(24, Math.floor(currentImages[0].width / roomWidth));
                    const maxSpriteHeight = Math.min(24, Math.floor(currentImages[0].height / roomHeight));
                    if (maxSpriteWidth > 0 && maxSpriteHeight > 0) {
                        const spriteWidthInput = document.getElementById("spriteWidth");
                        const spriteHeightInput = document.getElementById("spriteHeight");
                        spriteWidthInput.removeEventListener("input", autoCalculateRoomSize);
                        spriteHeightInput.removeEventListener("input", autoCalculateRoomSize);
                        spriteWidthInput.value = maxSpriteWidth;
                        spriteHeightInput.value = maxSpriteHeight;
                        setTimeout(() => {
                            spriteWidthInput.addEventListener("input", autoCalculateRoomSize);
                            spriteHeightInput.addEventListener("input", autoCalculateRoomSize);
                        }, 100);
                        showCalculationInfo(`已調整至最大可用尺寸: ${maxSpriteWidth}×${maxSpriteHeight} 精靈`);
                    } else {
                        showCalculationInfo(`房間尺寸過大，無法計算合適的精靈尺寸`, 'warning');
                    }
                }
            }
        }

        // 顯示計算信息
        function showCalculationInfo(message, type = 'info') {
            // 移除舊的計算信息
            const existingInfo = document.querySelector('.calculation-info');
            if (existingInfo) {
                existingInfo.remove();
            }
            
            // 創建新的計算信息
            const infoDiv = document.createElement('div');
            infoDiv.className = 'calculation-info';
            infoDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 10px 15px;
                border-radius: 5px;
                color: white;
                font-size: 14px;
                z-index: 1000;
                max-width: 300px;
                word-wrap: break-word;
            `;
            
            // 根據類型設定顏色
            if (type === 'warning') {
                infoDiv.style.backgroundColor = '#ff9800';
            } else {
                infoDiv.style.backgroundColor = '#2196F3';
            }
            
            infoDiv.textContent = message;
            
            // 插入到頁面
            document.body.appendChild(infoDiv);
            
            // 3秒後自動移除
            setTimeout(() => {
                if (infoDiv.parentNode) {
                    infoDiv.remove();
                }
            }, 3000);
        }

        // ====== 全域動畫幀補齊函數 ======
        function padFrames(frames, maxLen) {
            if (frames.length === maxLen) return frames.slice();
            if (maxLen === 2) {
                return [frames[0], frames[0]];
            }
            if (maxLen === 3) {
                if (frames.length === 1) return [frames[0], frames[0], frames[0]];
                if (frames.length === 2) return [frames[0], frames[1], frames[0]];
            }
            if (maxLen === 4) {
                if (frames.length === 1) return [frames[0], frames[0], frames[0], frames[0]];
                if (frames.length === 2) return [frames[0], frames[1], frames[0], frames[1]];
                if (frames.length === 3) return [frames[0], frames[1], frames[1], frames[2]];
            }
            const arr = frames.slice();
            while (arr.length < maxLen) arr.push(JSON.parse(JSON.stringify(arr[arr.length - 1])));
            return arr;
        }

        // ===== 合併精靈工具 =====
        (function(){
            const input = document.getElementById('mergeSpriteInput');
            const fileList = document.getElementById('mergeSpriteFileList');
            const attrSelect = document.getElementById('mergeSpriteAttrSelect');
            const errorDiv = document.getElementById('mergeSpriteError');
            const mergeBtn = document.getElementById('mergeSpriteBtn');
            let sprites = [];
            let attrSourceIdx = 0;

            // 拖曳排序
            let dragIdx = null;
            fileList.addEventListener('dragstart', e => {
                dragIdx = Number(e.target.dataset.idx);
                e.dataTransfer.effectAllowed = 'move';
            });
            fileList.addEventListener('dragover', e => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            });
            fileList.addEventListener('drop', e => {
                e.preventDefault();
                const targetIdx = Number(e.target.closest('li').dataset.idx);
                if (dragIdx !== null && targetIdx !== dragIdx) {
                    const moved = sprites.splice(dragIdx, 1)[0];
                    sprites.splice(targetIdx, 0, moved);
                    renderFileList();
                    renderAttrSelect();
                }
                dragIdx = null;
            });

            input.addEventListener('change', async e => {
                sprites = [];
                errorDiv.style.display = 'none';
                attrSelect.style.display = 'none';
                mergeBtn.style.display = 'none';
                fileList.innerHTML = '';
                const files = Array.from(input.files);
                for (const file of files) {
                    try {
                        const text = await file.text();
                        const data = JSON.parse(text);
                        sprites.push({file, data});
                    } catch {
                        errorDiv.textContent = `檔案 ${file.name} 解析失敗`;
                        errorDiv.style.display = '';
                        return;
                    }
                }
                if (sprites.length < 2) {
                    errorDiv.textContent = '請選擇至少兩個精靈檔案';
                    errorDiv.style.display = '';
                    return;
                }
                // 檢查長寬一致
                const w = sprites[0].data.width, h = sprites[0].data.height;
                if (!sprites.every(s => s.data.width === w && s.data.height === h)) {
                    errorDiv.textContent = '所有精靈的寬高必須一致！';
                    errorDiv.style.display = '';
                    return;
                }
                renderFileList();
                renderAttrSelect();
                mergeBtn.style.display = '';
            });

            function renderFileList() {
                fileList.innerHTML = '';
                sprites.forEach((s, i) => {
                    const li = document.createElement('li');
                    li.textContent = `${s.file.name} (${s.data.name || ''})`;
                    li.draggable = true;
                    li.dataset.idx = i;
                    fileList.appendChild(li);
                });
            }
            function renderAttrSelect() {
                attrSelect.style.display = '';
                attrSelect.innerHTML = '選擇要保留屬性的精靈：';
                const select = document.createElement('select');
                sprites.forEach((s, i) => {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.textContent = `${s.file.name} (${s.data.name || ''})`;
                    select.appendChild(opt);
                });
                select.value = attrSourceIdx;
                select.onchange = e => { attrSourceIdx = Number(e.target.value); };
                attrSelect.appendChild(select);
            }

            mergeBtn.onclick = function() {
                errorDiv.style.display = 'none';
                if (sprites.length < 2) {
                    errorDiv.textContent = '請選擇至少兩個精靈檔案';
                    errorDiv.style.display = '';
                    return;
                }
                // 處理單色和多色精靈的 frameList
                const colorFrameLists = sprites.map(s => {
                    // 檢查是否為單色精靈（有 colorIndex）
                    if (s.data.colorIndex !== undefined) {
                        // 單色精靈：將 1 轉換為 colorIndex，0 保持為 0
                        const color = s.data.colorIndex;
                        return s.data.frameList.map(frame => frame.map(px => px === 1 ? color : 0));
                    } else {
                        // 多色精靈：直接使用原始 frameList（已經是顏色值）
                        return s.data.frameList.map(frame => [...frame]);
                    }
                });
                // ====== 新增：動畫幀補齊 ======
                const maxFrameLen = Math.max(...colorFrameLists.map(frames => frames.length));
                const paddedColorFrameLists = colorFrameLists.map(frames => padFrames(frames, maxFrameLen));
                // ====== 合併時 colorFrameLists 換成 paddedColorFrameLists ======
                const w = sprites[0].data.width, h = sprites[0].data.height;
                const mergedFrameList = [];
                for (let f = 0; f < maxFrameLen; f++) {
                    const mergedFrame = [];
                    for (let i = 0; i < w * h; i++) {
                        let val = 0;
                        for (let sIdx = 0; sIdx < paddedColorFrameLists.length; sIdx++) {
                            const frameArr = paddedColorFrameLists[sIdx][f] || paddedColorFrameLists[sIdx][0];
                            if (frameArr[i] !== 0) val = frameArr[i];
                        }
                        mergedFrame.push(val);
                    }
                    mergedFrameList.push(mergedFrame);
                }
                // 直接從下拉選單 DOM 取值，確保正確
                const select = attrSelect.querySelector('select');
                const idx = select ? Number(select.value) : attrSourceIdx;
                const src = sprites[idx].data;
                const merged = {
                    name: src.name,
                    isAvatar: src.isAvatar,
                    isWall: src.isWall,
                    isItem: src.isItem,
                    isTransparent: src.isTransparent,
                    width: src.width,
                    height: src.height,
                    frameList: mergedFrameList,
                    scriptList: JSON.parse(JSON.stringify(src.scriptList || {}))
                };
                delete merged.colorIndex;
                const fileName = sprites[idx].file.name.replace(/\.(json|mosisprite)?$/, "") + ".mosisprite";
                // 壓成一行
                const content = JSON.stringify(merged);
                const blob = new Blob([content], {type:'application/json'});
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = fileName;
                a.click();
            };
        })();

        // ===== 合併房間單色精靈工具 =====
        (function(){
            const input = document.getElementById('mergeRoomInput');
            const errorDiv = document.getElementById('mergeRoomError');
            const mergeBtn = document.getElementById('mergeRoomBtn');
            let roomData = null, fileName = '';
            input.onchange = async function(e) {
                errorDiv.style.display = 'none';
                mergeBtn.style.display = 'none';
                if (!input.files[0]) return;
                fileName = input.files[0].name;
                try {
                    const text = await input.files[0].text();
                    roomData = JSON.parse(text);
                    mergeBtn.style.display = '';
                } catch {
                    errorDiv.textContent = '檔案格式錯誤，請上傳正確的 .mosiroom 檔案';
                    errorDiv.style.display = '';
                    roomData = null;
                }
            };
            mergeBtn.onclick = function() {
                errorDiv.style.display = 'none';
                if (!roomData) return;
                try {
                    const room = JSON.parse(JSON.stringify(roomData));
                    const spriteMap = {};
                    room.spriteList.forEach(s => spriteMap[s.name] = s);
                    // ====== 預處理：每個重複放置的 sprite 都分配一個獨立複製（名稱加編號） ======
                    // （已不需要，直接跳過，保留原始 tileList 與 spriteList）
                    // 依座標分組
                    const posMap = {};
                    room.tileList.forEach((t, idx) => {
                        const key = t.x + ',' + t.y;
                        if (!posMap[key]) posMap[key] = [];
                        posMap[key].push(idx);
                    });
                    let mergedCount = 0;
                    Object.entries(posMap).forEach(([key, idxArr]) => {
                        // 每一格都產生一個獨立的合併精靈
                        const [x, y] = key.split(',').map(Number);
                        const sprites = idxArr.map(idx => spriteMap[room.tileList[idx].spriteName]);
                        // ====== 新增：動畫幀補齊 ======
                        // 1. 處理單色和多色精靈的 frameList
                        const colorFrameLists = sprites.map(s => {
                            // 檢查是否為單色精靈（有 colorIndex）
                            if (s.colorIndex !== undefined) {
                                // 單色精靈：將 1 轉換為 colorIndex，0 保持為 0
                                const color = s.colorIndex;
                                return s.frameList.map(frame => frame.map(px => px === 1 ? color : 0));
                            } else {
                                // 多色精靈：直接使用原始 frameList（已經是顏色值）
                                return s.frameList.map(frame => [...frame]);
                            }
                        });
                        // 2. 取得最大動畫幀數
                        const maxFrameLen = Math.max(...colorFrameLists.map(frames => frames.length));
                        // 3. 幀數不足補齊
                        const paddedColorFrameLists = colorFrameLists.map(frames => padFrames(frames, maxFrameLen));
                        // ====== 合併時 colorFrameLists 換成 paddedColorFrameLists ======
                        const w = sprites[0].width, h = sprites[0].height;
                        const mergedFrameList = [];
                        for (let f = 0; f < maxFrameLen; f++) {
                            const mergedFrame = [];
                            for (let i = 0; i < w * h; i++) {
                                let color = 0;
                                for (let sIdx = 0; sIdx < paddedColorFrameLists.length; sIdx++) {
                                    const val = paddedColorFrameLists[sIdx][f][i];
                                    if (val && val !== 0) color = val;
                                }
                                mergedFrame.push(color);
                            }
                            mergedFrameList.push(mergedFrame);
                        }
                        // 先宣告 topSprite
                        const topSprite = sprites[sprites.length - 1];
                        // 決定合併精靈名稱：只有多色才加 -合併(x,y)，單色維持原名
                        let mergedName = topSprite.name;
                        if (sprites.length > 1) {
                            mergedName = `${topSprite.name}-合併(${x},${y})`;
                        }
                        // ===== scriptList 新邏輯 =====
                        let mergedScriptList = {};
                        let scriptLog = [];
                        for (let i = sprites.length - 1; i >= 0; i--) {
                            scriptLog.push({name: sprites[i].name, scriptList: sprites[i].scriptList});
                            if (isScriptListValid(sprites[i].scriptList)) {
                                mergedScriptList = JSON.parse(JSON.stringify(sprites[i].scriptList));
                                break;
                            }
                        }
                        console.log(`[合併房間單色精靈] (${x},${y}) sprites:`, scriptLog, '→ 採用 scriptList:', mergedScriptList);
                        const mergedSprite = {
                            name: mergedName,
                            isAvatar: false,
                            isWall: false,
                            isItem: false,
                            isTransparent: true,
                            width: w,
                            height: h,
                            frameList: mergedFrameList,
                            scriptList: mergedScriptList
                        };
                        // 屬性來源：取最上層精靈（可調整）
                        mergedSprite.isAvatar = topSprite.isAvatar;
                        mergedSprite.isWall = topSprite.isWall;
                        mergedSprite.isItem = topSprite.isItem;
                        mergedSprite.isTransparent = topSprite.isTransparent;
                        mergedSprite.scriptList = mergedScriptList;
                        console.log('[合併房間單色精靈] mergedSprite(屬性設定後):', JSON.parse(JSON.stringify(mergedSprite)));
                        room.spriteList.push(mergedSprite);
                        // 只 log 除 frameList 以外的屬性
                        const { frameList, ...spriteInfo } = mergedSprite;
                        // tileList 保留所有原 tile，全部指向新合併精靈
                        idxArr.forEach(idx => {
                            room.tileList[idx] = {
                                spriteName: mergedSprite.name,
                                x: room.tileList[idx].x,
                                y: room.tileList[idx].y
                            };
                        });
                        mergedCount++;
                    });
                    // 移除被合併的 tile
                    room.tileList = room.tileList.filter(t => t);
                    if (mergedCount === 0) {
                        errorDiv.textContent = '沒有需要合併的同格單色精靈';
                        errorDiv.style.display = '';
                        return;
                    }
                    // ====== 新增：合併精靈內容去重 ======
                    if (room.spriteList && room.spriteList.length > 0) {
                        const spriteContentMap = {};
                        const nameMap = {};
                        room.spriteList.forEach(s => {
                            const hash = JSON.stringify({
                                isAvatar: s.isAvatar,
                                isWall: s.isWall,
                                isItem: s.isItem,
                                isTransparent: s.isTransparent,
                                width: s.width,
                                height: s.height,
                                frameList: s.frameList,
                                scriptList: s.scriptList
                            });
                            if (!spriteContentMap[hash]) {
                                spriteContentMap[hash] = s;
                                nameMap[s.name] = s.name;
                            } else {
                                nameMap[s.name] = spriteContentMap[hash].name;
                            }
                        });
                        room.spriteList = Object.values(spriteContentMap);
                        // 修正 tileList 指向唯一精靈名稱
                        room.tileList.forEach(tile => {
                            if (nameMap[tile.spriteName]) {
                                tile.spriteName = nameMap[tile.spriteName];
                            }
                        });
                    }
                    // ===== 合併房間單色精靈工具下載檔名修正 =====
                    let downloadName = (fileName || "merged_room")
                      .replace(/\.(json|mosiroom)?$/, "") + ".mosiroom";
                    // 壓成一行
                    const content = JSON.stringify(room);
                    const blob = new Blob([content], {type:'application/json'});
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = downloadName;
                    a.click();
                } catch (e) {
                    errorDiv.textContent = '合併失敗：' + e.message;
                    errorDiv.style.display = '';
                    console.error('合併房間單色精靈錯誤', e);
                }
            };
        })();

        // ===== 世界級合併工具 =====
        (function(){
            const input = document.getElementById('mergeWorldInput');
            const errorDiv = document.getElementById('mergeWorldError');
            const mergeBtn = document.getElementById('mergeWorldBtn');
            let worldData = null, fileName = '';
            input.onchange = async function(e) {
                errorDiv.style.display = 'none';
                mergeBtn.style.display = 'none';
                if (!input.files[0]) return;
                fileName = input.files[0].name;
                try {
                    const text = await input.files[0].text();
                    worldData = JSON.parse(text);
                    mergeBtn.style.display = '';
                } catch {
                    errorDiv.textContent = '檔案格式錯誤，請上傳正確的 .mosi 世界檔案';
                    errorDiv.style.display = '';
                    worldData = null;
                }
            };
            mergeBtn.onclick = function() {
                errorDiv.style.display = 'none';
                if (!worldData) return;
                try {
                    // 深拷貝世界數據，完整保留所有屬性
                    const world = JSON.parse(JSON.stringify(worldData));
                    if (!Array.isArray(world.roomList) || !Array.isArray(world.spriteList)) {
                        errorDiv.textContent = '世界數據格式錯誤，缺少 roomList 或 spriteList';
                        errorDiv.style.display = '';
                        return;
                    }
                    // 建立 spriteName->sprite 映射
                    const globalSpriteMap = {};
                    world.spriteList.forEach(s => globalSpriteMap[s.name] = s);
                    // 用來記錄所有合併後新精靈名稱
                    const mergedSpriteNames = new Set();
                    // 用來記錄所有被合併的原始精靈名稱
                    const mergedSourceNames = new Set();
                    // 處理每個房間
                    world.roomList.forEach(room => {
                        // 建立本房間 spriteName->sprite
                        const roomSpriteMap = {};
                        (room.spriteList||[]).forEach(s => roomSpriteMap[s.name] = s);
                        // 合併 tileList
                        const posMap = {};
                        (room.tileList||[]).forEach((t, idx) => {
                            const key = t.x + ',' + t.y;
                            if (!posMap[key]) posMap[key] = [];
                            posMap[key].push(idx);
                        });
                        Object.entries(posMap).forEach(([key, idxArr]) => {
                            // 每格都產生一個合併精靈
                            const [x, y] = key.split(',').map(Number);
                            // 支援房間自帶 spriteList，否則用世界 spriteList
                            const sprites = idxArr.map(idx => {
                                const sn = room.tileList[idx].spriteName;
                                return roomSpriteMap[sn] || globalSpriteMap[sn];
                            });
                            // 記錄所有被合併的原始精靈名稱
                            sprites.forEach(s => mergedSourceNames.add(s.name));
                            // 處理單色和多色精靈的 frameList
                            const colorFrameLists = sprites.map(s => {
                                // 檢查是否為單色精靈（有 colorIndex）
                                if (s.colorIndex !== undefined) {
                                    // 單色精靈：將 1 轉換為 colorIndex，0 保持為 0
                                    const color = s.colorIndex;
                                    return s.frameList.map(frame => frame.map(px => px === 1 ? color : 0));
                                } else {
                                    // 多色精靈：直接使用原始 frameList（已經是顏色值）
                                    return s.frameList.map(frame => [...frame]);
                                }
                            });
                            // 幀補齊
                            const maxFrameLen = Math.max(...colorFrameLists.map(frames => frames.length));
                            const paddedColorFrameLists = colorFrameLists.map(frames => padFrames(frames, maxFrameLen));
                            const w = sprites[0].width, h = sprites[0].height;
                            const mergedFrameList = [];
                            for (let f = 0; f < maxFrameLen; f++) {
                                const mergedFrame = [];
                                for (let i = 0; i < w * h; i++) {
                                    let color = 0;
                                    for (let sIdx = 0; sIdx < paddedColorFrameLists.length; sIdx++) {
                                        const val = paddedColorFrameLists[sIdx][f][i];
                                        if (val && val !== 0) color = val;
                                    }
                                    mergedFrame.push(color);
                                }
                                mergedFrameList.push(mergedFrame);
                            }
                            // 取最上層精靈
                            const topSprite = sprites[sprites.length - 1];
                            let mergedName = topSprite.name;
                            if (sprites.length > 1) {
                                mergedName = `${topSprite.name}-合併(${x},${y})`;
                            }
                            // ===== scriptList 新邏輯 =====
                            let mergedScriptList = {};
                            let scriptLog = [];
                            for (let i = sprites.length - 1; i >= 0; i--) {
                                scriptLog.push({name: sprites[i].name, scriptList: sprites[i].scriptList});
                                if (isScriptListValid(sprites[i].scriptList)) {
                                    mergedScriptList = JSON.parse(JSON.stringify(sprites[i].scriptList));
                                    break;
                                }
                            }
                            console.log(`[世界級合併] (${x},${y}) sprites:`, scriptLog, '→ 採用 scriptList:', mergedScriptList);
                            const mergedSprite = {
                                name: mergedName,
                                isAvatar: topSprite.isAvatar,
                                isWall: topSprite.isWall,
                                isItem: topSprite.isItem,
                                isTransparent: topSprite.isTransparent,
                                width: w,
                                height: h,
                                frameList: mergedFrameList,
                                scriptList: mergedScriptList
                            };
                            // 新增到世界 spriteList
                            world.spriteList.push(mergedSprite);
                            mergedSpriteNames.add(mergedName);
                            // tileList 指向新合併精靈
                            idxArr.forEach(idx => {
                                room.tileList[idx] = {
                                    spriteName: mergedSprite.name,
                                    x: room.tileList[idx].x,
                                    y: room.tileList[idx].y
                                };
                            });
                        });
                    });
                    // 合併後清理 spriteList：
                    // 1. 保留合併後的新精靈（mergedSpriteNames）
                    // 2. 移除被合併的原始精靈（mergedSourceNames）
                    // 3. 保留未參與合併的精靈（既不在 mergedSpriteNames 也不在 mergedSourceNames）
                    // 4. 移除重複精靈（同名只留一個）
                    const uniqueSpriteMap = {};
                    world.spriteList.forEach(s => {
                        // 保留合併後的新精靈
                        if (mergedSpriteNames.has(s.name)) {
                            uniqueSpriteMap[s.name] = s;
                        }
                        // 保留未參與合併的精靈（既不是合併後的新精靈，也不是被合併的原始精靈）
                        else if (!mergedSourceNames.has(s.name)) {
                            uniqueSpriteMap[s.name] = s;
                        }
                        // 被合併的原始精靈會被移除（不加入 uniqueSpriteMap）
                    });
                    world.spriteList = Object.values(uniqueSpriteMap);
                    // ====== 新增：合併精靈內容去重 ======
                    const spriteContentMap = {};
                    const nameMap = {};
                    world.spriteList.forEach(s => {
                        const hash = JSON.stringify({
                            isAvatar: s.isAvatar,
                            isWall: s.isWall,
                            isItem: s.isItem,
                            isTransparent: s.isTransparent,
                            width: s.width,
                            height: s.height,
                            frameList: s.frameList,
                            scriptList: s.scriptList
                        });
                        if (!spriteContentMap[hash]) {
                            spriteContentMap[hash] = s;
                            nameMap[s.name] = s.name;
                        } else {
                            nameMap[s.name] = spriteContentMap[hash].name;
                        }
                    });
                    world.spriteList = Object.values(spriteContentMap);
                    // 修正所有房間 tileList 指向唯一精靈名稱
                    world.roomList.forEach(room => {
                        room.tileList.forEach(tile => {
                            if (nameMap[tile.spriteName]) {
                                tile.spriteName = nameMap[tile.spriteName];
                            }
                        });
                    });
                    // ===== 世界級合併工具下載檔名修正 =====
                    let downloadName = (fileName || "merged_world")
                      .replace(/\.(json|mosi)?$/, "") + ".mosi";
                    // 壓成一行
                    const content = JSON.stringify(world);
                    const blob = new Blob([content], {type:'application/json'});
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = downloadName;
                    a.click();
                } catch (e) {
                    errorDiv.textContent = '合併失敗：' + e.message;
                    errorDiv.style.display = '';
                    console.error('世界級合併錯誤', e);
                }
            };
        })();

        // ===== 插圖合併工具 =====
        (function(){
            const input = document.getElementById('mergePictureInput');
            const fileList = document.getElementById('mergePictureFileList');
            const attrSelect = document.getElementById('mergePictureAttrSelect');
            const errorDiv = document.getElementById('mergePictureError');
            const mergeBtn = document.getElementById('mergePictureBtn');
            let sprites = [];
            let attrSourceIdx = 0;

            // 拖曳排序
            let dragIdx = null;
            fileList.addEventListener('dragstart', e => {
                dragIdx = Number(e.target.dataset.idx);
                e.dataTransfer.effectAllowed = 'move';
            });
            fileList.addEventListener('dragover', e => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            });
            fileList.addEventListener('drop', e => {
                e.preventDefault();
                const targetIdx = Number(e.target.closest('li').dataset.idx);
                if (dragIdx !== null && targetIdx !== dragIdx) {
                    const moved = sprites.splice(dragIdx, 1)[0];
                    sprites.splice(targetIdx, 0, moved);
                    renderFileList();
                    renderAttrSelect();
                }
                dragIdx = null;
            });

            input.addEventListener('change', async e => {
                sprites = [];
                errorDiv.style.display = 'none';
                attrSelect.style.display = 'none';
                mergeBtn.style.display = 'none';
                fileList.innerHTML = '';
                const files = Array.from(input.files);
                for (const file of files) {
                    try {
                        const text = await file.text();
                        const data = JSON.parse(text);
                        sprites.push({file, data});
                    } catch {
                        errorDiv.textContent = `檔案 ${file.name} 解析失敗`;
                        errorDiv.style.display = '';
                        return;
                    }
                }
                if (sprites.length < 2) {
                    errorDiv.textContent = '請選擇至少兩個插圖檔案';
                    errorDiv.style.display = '';
                    return;
                }
                // 檢查長寬一致
                const w = sprites[0].data.width, h = sprites[0].data.height;
                if (!sprites.every(s => s.data.width === w && s.data.height === h)) {
                    errorDiv.textContent = '所有插圖的寬高必須一致！';
                    errorDiv.style.display = '';
                    return;
                }
                renderFileList();
                renderAttrSelect();
                mergeBtn.style.display = '';
            });

            function renderFileList() {
                fileList.innerHTML = '';
                sprites.forEach((s, i) => {
                    const li = document.createElement('li');
                    li.textContent = `${s.file.name} (${s.data.name || ''})`;
                    li.draggable = true;
                    li.dataset.idx = i;
                    fileList.appendChild(li);
                });
            }
            function renderAttrSelect() {
                attrSelect.style.display = '';
                attrSelect.innerHTML = '選擇要保留屬性的插圖：';
                const select = document.createElement('select');
                sprites.forEach((s, i) => {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.textContent = `${s.file.name} (${s.data.name || ''})`;
                    select.appendChild(opt);
                });
                select.value = attrSourceIdx;
                select.onchange = e => { attrSourceIdx = Number(e.target.value); };
                attrSelect.appendChild(select);
            }

            mergeBtn.onclick = function() {
                errorDiv.style.display = 'none';
                if (sprites.length < 2) {
                    errorDiv.textContent = '請選擇至少兩個插圖檔案';
                    errorDiv.style.display = '';
                    return;
                }
                // 處理單色和多色插圖的 frameList
                const colorFrameLists = sprites.map(s => {
                    // 檢查是否為單色插圖（有 colorIndex）
                    if (s.data.colorIndex !== undefined) {
                        // 單色插圖：將 1 轉換為 colorIndex，0 保持為 0
                        const color = s.data.colorIndex;
                        return s.data.frameList.map(frame => frame.map(px => px === 1 ? color : 0));
                    } else {
                        // 多色插圖：直接使用原始 frameList（已經是顏色值）
                        return s.data.frameList.map(frame => [...frame]);
                    }
                });
                // ====== 新增：動畫幀補齊 ======
                const maxFrameLen = Math.max(...colorFrameLists.map(frames => frames.length));
                const paddedColorFrameLists = colorFrameLists.map(frames => padFrames(frames, maxFrameLen));
                // ====== 合併時 colorFrameLists 換成 paddedColorFrameLists ======
                const w = sprites[0].data.width, h = sprites[0].data.height;
                const mergedFrameList = [];
                for (let f = 0; f < maxFrameLen; f++) {
                    const mergedFrame = [];
                    for (let i = 0; i < w * h; i++) {
                        let val = 0;
                        for (let sIdx = 0; sIdx < paddedColorFrameLists.length; sIdx++) {
                            const frameArr = paddedColorFrameLists[sIdx][f] || paddedColorFrameLists[sIdx][0];
                            if (frameArr[i] !== 0) val = frameArr[i];
                        }
                        mergedFrame.push(val);
                    }
                    mergedFrameList.push(mergedFrame);
                }
                // 直接從下拉選單 DOM 取值，確保正確
                const select = attrSelect.querySelector('select');
                const idx = select ? Number(select.value) : attrSourceIdx;
                const src = sprites[idx].data;
                // 合併 picture 物件，所有欄位都複製來源，只覆蓋 frameList
                const merged = Object.assign({}, src, { frameList: mergedFrameList });
                const fileName = (src.name || 'merged_picture').replace(/\.(json|mosigraphic)?$/, "") + ".mosigraphic";
                // 壓成一行
                const content = JSON.stringify(merged);
                const blob = new Blob([content], {type:'application/json'});
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = fileName;
                a.click();
            };
        })();

        // ===== 房間轉插圖工具 =====
        (function(){
            const input = document.getElementById('roomToPictureInput');
            const errorDiv = document.getElementById('roomToPictureError');
            const pictureBtn = document.getElementById('roomToPicturePictureBtn');
            let roomData = null;
            input.onchange = async function(e) {
                errorDiv.style.display = 'none';
                pictureBtn.style.display = 'none';
                if (!input.files[0]) return;
                try {
                    const text = await input.files[0].text();
                    roomData = JSON.parse(text);
                    pictureBtn.style.display = '';
                } catch {
                    errorDiv.textContent = '檔案格式錯誤，請上傳正確的 .mosiroom 檔案';
                    errorDiv.style.display = '';
                    roomData = null;
                }
            };
            pictureBtn.onclick = function() {
                errorDiv.style.display = 'none';
                if (!roomData) return;
                try {
                    const picture = roomToPictureData(roomData);
                    const fileName = (picture.name || 'picture').replace(/\.(json|mosigraphic)?$/, "") + ".mosigraphic";
                    const content = JSON.stringify(picture);
                    const blob = new Blob([content], {type:'application/json'});
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = fileName;
                    a.click();
                } catch (e) {
                    errorDiv.textContent = '轉換失敗：' + e.message;
                    errorDiv.style.display = '';
                }
            };
        })();

        // Tab 切換邏輯
        function setTab(tabId) {
            currentTabId = tabId;
            // 切換內容
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-section').forEach(sec => sec.classList.remove('active'));
            const btn = document.querySelector('.tab-btn[data-tab="' + tabId + '"]');
            if (btn) btn.classList.add('active');
            const sec = document.getElementById(tabId);
            if (sec) sec.classList.add('active');
            // ====== 桌面手風琴同步展開/高亮 ======
            // 找到該 tab-btn 所屬的 accordion-panel
            if (btn) {
                // 1. 找到所有 accordion-panel，全部收起
                document.querySelectorAll('.accordion-panel').forEach(panel => {
                    panel.style.display = 'none';
                });
                // 2. 找到所有 accordion-btn，全部移除 active
                document.querySelectorAll('.accordion-btn').forEach(abtn => {
                    abtn.classList.remove('active');
                });
                // 3. 展開該 tab-btn 所屬的 accordion-panel，並高亮對應的 accordion-btn
                const panel = btn.closest('.accordion-panel');
                if (panel) {
                    panel.style.display = 'block';
                    const accordionBtn = panel.previousElementSibling;
                    if (accordionBtn && accordionBtn.classList.contains('accordion-btn')) {
                        accordionBtn.classList.add('active');
                    }
                }
            }
            // 手機下拉同步
            const tabSel = document.getElementById('tab-select');
            if (tabSel && tabSel.value !== tabId) {
                // 找到這個 tabId 屬於哪個母類別
                let found = false;
                for (let cat of tabCategories) {
                    if (cat.children.some(child => child.value === tabId)) {
                        // 設定母類別
                        document.getElementById('tab-category-select').value = cat.value;
                        updateTabSelectByCategory(cat.value);
                        found = true;
                        break;
                    }
                }
                tabSel.value = tabId;
            }
        }
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.onclick = function() {
                setTab(btn.dataset.tab);
            };
        });
        // 響應式下拉選單切換
        document.getElementById('tab-select').addEventListener('change', function() {
            setTab(this.value);
        });
        // 預設顯示第一個 tab
        setTab('upload-img');

        // Header 開合邏輯
        const headerBtn = document.getElementById('headerToggleBtn');
        const headerContent = document.getElementById('headerContent');
        let headerOpen = true;
        headerBtn.onclick = function() {
            headerOpen = !headerOpen;
            if (headerOpen) {
                headerContent.classList.remove('header-collapsed');
                headerBtn.classList.remove('rotate');
            } else {
                headerContent.classList.add('header-collapsed');
                headerBtn.classList.add('rotate');
            }
        };

        // ===== scriptList 有效性判斷 =====
        function isScriptListValid(scriptList) {
            if (!scriptList || typeof scriptList !== 'object') return false;
            return Object.values(scriptList).some(v => typeof v === 'string' && v.trim() !== '');
        }

        // 新增：批量精靈設定區
        function renderBatchSpriteSettings() {
            const batchDiv = document.getElementById('batch-sprite-settings');
            if (!batchMode || !currentImages.length) {
                batchDiv.style.display = 'none';
                batchDiv.innerHTML = '';
                document.getElementById('spriteName').style.display = '';
                document.getElementById('colorIndex').parentNode.style.display = '';
                return;
            }
            batchDiv.style.display = '';
            batchDiv.innerHTML = '<b>批量精靈設定：</b>';
            document.getElementById('spriteName').style.display = 'none';
            document.getElementById('colorIndex').parentNode.style.display = 'none';
            // 建立每張圖的設定欄
            currentImages.forEach((img, idx) => {
                // 預設名稱與色碼
                if (!img.spriteName) img.spriteName = `sprite${idx+1}`;
                if (!img.colorIndex) img.colorIndex = 1;
                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.alignItems = 'center';
                row.style.margin = '6px 0';
                // 圖片預覽
                const thumb = document.createElement('img');
                thumb.src = img.canvas.toDataURL();
                thumb.style.width = '32px';
                thumb.style.height = '32px';
                thumb.style.marginRight = '8px';
                // 名稱輸入
                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.value = img.spriteName;
                nameInput.style.width = '6em';
                nameInput.oninput = e => { img.spriteName = e.target.value; };
                row.appendChild(thumb);
                const label1 = document.createElement('span');
                label1.textContent = '名稱:';
                label1.style.margin = '0 4px';
                row.appendChild(label1);
                row.appendChild(nameInput);
                // 顏色索引 select 只在單色模式顯示
                if (!currentPalette) {
                  const label2 = document.createElement('span');
                  label2.textContent = '顏色:';
                  label2.style.margin = '0 4px';
                  const colorSel = document.createElement('select');
                  for (let i=1; i<=8; i++) {
                      const opt = document.createElement('option');
                      opt.value = i;
                      opt.textContent = i;
                      if (i == img.colorIndex) opt.selected = true;
                      colorSel.appendChild(opt);
                  }
                  colorSel.onchange = e => { img.colorIndex = parseInt(e.target.value); };
                  row.appendChild(label2);
                  row.appendChild(colorSel);
                }
                batchDiv.appendChild(row);
            });
        }

        // 新增 processImageToPictureData 函數
        function processImageToPictureData(image, data) {
            const { width: imgWidth, height: imgHeight, context } = image;
            const { spriteWidth, spriteHeight, roomWidth, roomHeight } = data;
            const requiredWidth = roomWidth * spriteWidth;
            const requiredHeight = roomHeight * spriteHeight;
            let processedCanvas = image.canvas;
            let processedContext = image.context;
            let scale = 1;
            if (imgWidth !== requiredWidth || imgHeight !== requiredHeight) {
                const scaledCanvas = document.createElement('canvas');
                const scaledContext = scaledCanvas.getContext('2d');
                scaledCanvas.width = requiredWidth;
                scaledCanvas.height = requiredHeight;
                scaledContext.imageSmoothingEnabled = false;
                scaledContext.drawImage(image.canvas, 0, 0, requiredWidth, requiredHeight);
                processedCanvas = scaledCanvas;
                processedContext = scaledContext;
                scale = requiredWidth / imgWidth;
            }
            // 單色插圖 frameList 只用 0/色碼
            const pixels = processedContext.getImageData(0, 0, requiredWidth, requiredHeight).data;
            const frame = [];
            const colorIndex = data.colorIndex || 1;
            for (let i = 0; i < pixels.length; i += 4) {
                const alpha = pixels[i + 3];
                if (alpha < 128) {
                    frame.push(0);
                } else {
                    const gray = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
                    frame.push(gray < 128 ? colorIndex : 0);
                }
            }
            return {
                name: data.spriteName,
                type: 'picture',
                paletteName: data.paletteName,
                musicName: data.musicName,
                roomWidth: data.roomWidth,
                roomHeight: data.roomHeight,
                spriteWidth: data.spriteWidth,
                spriteHeight: data.spriteHeight,
                width: requiredWidth,
                height: requiredHeight,
                frameList: [frame],
                scriptList: {"on-show": "", "on-hide": ""}
            };
        }

        // 禁用生成按鈕
        function disableGenerateButtons() {
            document.getElementById('generate-room-btn').disabled = true;
            document.getElementById('generate-picture-btn').disabled = true;
        }
        // 啟用生成按鈕
        function enableGenerateButtons() {
            document.getElementById('generate-room-btn').disabled = false;
            document.getElementById('generate-picture-btn').disabled = false;
        }

        // ===== 房間轉插圖主邏輯 =====
        function roomToPictureData(room) {
            // 取得房間基本資訊
            const roomWidth = room.width || room.roomWidth;
            const roomHeight = room.height || room.roomHeight;
            const spriteWidth = room.spriteWidth;
            const spriteHeight = room.spriteHeight;
            const width = roomWidth * spriteWidth;
            const height = roomHeight * spriteHeight;
            // 建立 spriteName->sprite 映射，並預處理 colorFrameList
            const spriteMap = {};
            const colorFrameMap = {};
            (room.spriteList||[]).forEach(s => {
                spriteMap[s.name] = s;
                // 預處理：單色精靈 frameList 轉 colorIndex，多色直接複製
                if (s.colorIndex !== undefined) {
                    const color = s.colorIndex;
                    colorFrameMap[s.name] = s.frameList.map(frame => frame.map(px => px === 1 ? color : 0));
                } else {
                    colorFrameMap[s.name] = s.frameList.map(frame => [...frame]);
                }
            });
            // 取得最大動畫幀數
            let maxFrameLen = 1;
            Object.values(colorFrameMap).forEach(frames => {
                if (Array.isArray(frames)) maxFrameLen = Math.max(maxFrameLen, frames.length);
            });
            // 幀補齊：合併工具 padFrames 特殊規則
            function padFrames(frames, maxLen) {
                if (frames.length === maxLen) return frames.slice();
                if (maxLen === 2) {
                    return [frames[0], frames[0]];
                }
                if (maxLen === 3) {
                    if (frames.length === 1) return [frames[0], frames[0], frames[0]];
                    if (frames.length === 2) return [frames[0], frames[1], frames[0]];
                }
                if (maxLen === 4) {
                    if (frames.length === 1) return [frames[0], frames[0], frames[0], frames[0]];
                    if (frames.length === 2) return [frames[0], frames[1], frames[0], frames[1]];
                    if (frames.length === 3) return [frames[0], frames[1], frames[1], frames[2]];
                }
                const arr = frames.slice();
                while (arr.length < maxLen) arr.push(JSON.parse(JSON.stringify(arr[arr.length - 1])));
                return arr;
            }
            const paddedColorFrameMap = {};
            Object.entries(colorFrameMap).forEach(([name, frames]) => {
                paddedColorFrameMap[name] = padFrames(frames, maxFrameLen);
            });
            // 對每個 tile，記錄其 sprite 及座標
            const tileGrid = Array.from({length: roomHeight}, () => Array(roomWidth).fill(null));
            (room.tileList||[]).forEach(tile => {
                if (tile.x >= 0 && tile.x < roomWidth && tile.y >= 0 && tile.y < roomHeight) {
                    if (!tileGrid[tile.y][tile.x]) tileGrid[tile.y][tile.x] = [];
                    tileGrid[tile.y][tile.x].push(tile.spriteName);
                }
            });
            // 產生每一幀的大圖
            const frameList = [];
            for (let f = 0; f < maxFrameLen; f++) {
                const frame = new Array(width * height).fill(0);
                for (let y = 0; y < roomHeight; y++) {
                    for (let x = 0; x < roomWidth; x++) {
                        const spriteNames = tileGrid[y][x] || [];
                        // 疊加所有 sprite，後者覆蓋前者
                        for (let sIdx = 0; sIdx < spriteNames.length; sIdx++) {
                            const sprite = spriteMap[spriteNames[sIdx]];
                            if (!sprite) continue;
                            const paddedColorFrames = paddedColorFrameMap[spriteNames[sIdx]];
                            const spriteFrame = paddedColorFrames[f];
                            for (let sy = 0; sy < spriteHeight; sy++) {
                                for (let sx = 0; sx < spriteWidth; sx++) {
                                    const px = x * spriteWidth + sx;
                                    const py = y * spriteHeight + sy;
                                    const idx = py * width + px;
                                    const val = spriteFrame[sy * spriteWidth + sx];
                                    if (val !== 0) frame[idx] = val;
                                }
                            }
                        }
                    }
                }
                frameList.push(frame);
            }
            // scriptList 轉換
            let scriptList = {};
            if (room.scriptList) {
                scriptList["on-show"] = room.scriptList["on-enter"] ?? "";
                scriptList["on-hide"] = room.scriptList["on-exit"] ?? "";
            } else {
                scriptList["on-show"] = "";
                scriptList["on-hide"] = "";
            }
            return {
                name: room.name || room.roomName || "picture",
                type: "picture",
                paletteName: room.paletteName || "palette-1",
                musicName: room.musicName || "song-1",
                roomWidth,
                roomHeight,
                spriteWidth,
                spriteHeight,
                width,
                height,
                frameList,
                scriptList
            };
        }

        // 對話框皮膚轉換工具 JS
        function readJsonFile(file) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = e => {
              try {
                resolve(JSON.parse(e.target.result));
              } catch (err) {
                reject('JSON 解析失敗: ' + err);
              }
            };
            reader.onerror = () => reject('檔案讀取失敗');
            reader.readAsText(file);
          });
        }

        function generateTextboxSkin(room, sprite) {
          // 驗證房間尺寸
          if (room.width !== 3 || room.height !== 3) {
            throw new Error('房間尺寸必須為 3x3');
          }
          // 驗證房間精靈數量必須為 9
          if (!Array.isArray(room.spriteList) || room.spriteList.length !== 9) {
            throw new Error('房間必須剛好有 9 個精靈（九宮格）');
          }
          // 取得精靈尺寸
          const fontWidth = sprite.width;
          const fontHeight = sprite.height;

          // === 驗證機制補充 ===
          // 2. 房間內所有精靈 frameList 長度必須為 1
          if (Array.isArray(room.spriteList)) {
            for (const spr of room.spriteList) {
              if (!Array.isArray(spr.frameList) || spr.frameList.length !== 1) {
                throw new Error(`房間內精靈「${spr.name || ''}」有動畫幀，請確保所有房間精靈僅有一幀（frameList 長度為 1）`);
              }
            }
          }
          // 3. 房間內所有精靈 isTransparent 必須一致
          let transparentSet = new Set();
          if (Array.isArray(room.spriteList)) {
            room.spriteList.forEach(spr => {
              if (typeof spr.isTransparent !== 'undefined') transparentSet.add(spr.isTransparent);
            });
          }
          if (transparentSet.size > 1) {
            throw new Error('房間內所有精靈的透明化屬性（isTransparent）必須一致！');
          }
          // 取得統一的 isTransparent 屬性（若無則預設 false）
          let isTransparent = transparentSet.size === 1 ? [...transparentSet][0] : 
          false;
          // 4. 房間內所有精靈尺寸必須一致
          let roomSpriteWidth = null, roomSpriteHeight = null;
          if (Array.isArray(room.spriteList) && room.spriteList.length > 0) {
            roomSpriteWidth = room.spriteList[0].width;
            roomSpriteHeight = room.spriteList[0].height;
            for (const spr of room.spriteList) {
              if (spr.width !== roomSpriteWidth || spr.height !== roomSpriteHeight) {
                throw new Error(`房間內精靈尺寸不一致，請確保所有房間精靈尺寸相同（${roomSpriteWidth}x${roomSpriteHeight}）`);
              }
            }
          }
          // 5. sprite（箭頭精靈）尺寸必須與房間精靈尺寸一致
          if (sprite.width !== roomSpriteWidth || sprite.height !== roomSpriteHeight) {
            throw new Error(`箭頭精靈尺寸（${sprite.width}x${sprite.height}）必須與房間精靈尺寸（${roomSpriteWidth}x${roomSpriteHeight}）一致！`);
          }
          // === 驗證機制補充結束 ===

          // 處理 indicatorList（直接用 sprite 檔案的 frameList，補齊動畫幀數）
          let indicatorList = [];
          if (sprite.colorIndex !== undefined) {
            // 單色精靈：將 1 轉 colorIndex，0 保持 0
            const color = sprite.colorIndex;
            indicatorList = padFrames(sprite.frameList.map(frame => frame.map(px => px === 1 ? color : 0)), sprite.frameList.length);
          } else {
            // 多色精靈：直接複製
            indicatorList = padFrames(sprite.frameList.map(frame => [...frame]), sprite.frameList.length);
          }

          // 處理 fillList（九宮格，依 tileList 位置順序，內容為該格精靈的 frameList 經 padFrames 後合併成一維陣列）
          // 九宮格順序：0,0→0 1,0→1 2,0→2 0,1→3 1,1→4 2,1→5 0,2→6 1,2→7 2,2→8
          const fillList = [];
          for (let y = 0; y < 3; y++) {
            for (let x = 0; x < 3; x++) {
              // 找到 tileList 中對應 (x, y) 的精靈 index
              let spriteIdx = null;
              if (Array.isArray(room.tileList)) {
                // 支援二維陣列或物件陣列
                if (Array.isArray(room.tileList[0])) {
                  spriteIdx = room.tileList[y][x];
                } else {
                  // 物件陣列格式
                  const tile = room.tileList.find(t => t.x === x && t.y === y);
                  spriteIdx = tile ? tile.spriteIndex || tile.sprite || tile.spriteName || 0 : 0;
                }
              }
              // 取得對應精靈
              let spr = null;
              if (Array.isArray(room.spriteList)) {
                if (typeof spriteIdx === 'number') {
                  spr = room.spriteList[spriteIdx];
                } else if (typeof spriteIdx === 'string') {
                  spr = room.spriteList.find(s => s.name === spriteIdx);
                }
              }
              if (!spr) {
                fillList.push([]);
                continue;
              }
              // 處理單色/多色精靈
              let frames;
              if (spr.colorIndex !== undefined) {
                const color = spr.colorIndex;
                frames = padFrames(spr.frameList.map(frame => frame.map(px => px === 1 ? color : 0)), spr.frameList.length);
              } else {
                frames = padFrames(spr.frameList.map(frame => [...frame]), spr.frameList.length);
              }
              // 合併所有幀成一維陣列
              fillList.push([].concat(...frames));
            }
          }

          // name: 房間名稱
          const name = room.name || room.roomName || '新對話框皮膚';
          return {
            name,
            isTransparent,
            fontWidth,
            fontHeight,
            fillList,
            indicatorList
          };
        }

        // 修正下載時壓成一行
        const oldTextboxSkinBtn = document.getElementById('convertTextboxSkinBtn').onclick;
        document.getElementById('convertTextboxSkinBtn').onclick = async function() {
          const roomFile = document.getElementById('roomFile').files[0];
          const spriteFile = document.getElementById('spriteFile').files[0];
          const resultDiv = document.getElementById('textboxSkinResult');
          resultDiv.innerHTML = '';
          if (!roomFile || !spriteFile) {
            resultDiv.innerHTML = '<div class="error">請選擇 .mosiroom 與 .mosisprite 檔案</div>';
            return;
          }
          try {
            const [room, sprite] = await Promise.all([
              readJsonFile(roomFile),
              readJsonFile(spriteFile)
            ]);
            const skin = generateTextboxSkin(room, sprite);
            // 新增：顯示 isTransparent 屬性
            let info = '';
            if (typeof skin.isTransparent !== 'undefined') {
              info = `<div style="color:#2196F3;">isTransparent: <b>${skin.isTransparent}</b></div>`;
            }
            const blob = new Blob([JSON.stringify(skin)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${skin.name}.mositextbox`;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
            }, 100);
            resultDiv.innerHTML = `<div class='success'>下載完成！${info}</div>`;
          } catch (err) {
            resultDiv.innerHTML = `<div class=\"error\">${err}</div>`;
          }
        };

        // Accordion 手風琴展開/收合邏輯
        document.querySelectorAll('.accordion-btn').forEach((btn, idx) => {
            btn.onclick = function() {
                const panel = btn.nextElementSibling;
                const isOpen = btn.classList.contains('active');
                // 關閉所有
                document.querySelectorAll('.accordion-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.accordion-panel').forEach(p => p.style.display = 'none');
                // 如果原本沒開，則打開
                if (!isOpen) {
                    btn.classList.add('active');
                    panel.style.display = 'block'; // 這裡由 flex 改為 block
                }
            };
        });
        // 預設展開第一個分類
        document.querySelectorAll('.accordion-btn')[0].classList.add('active');
        document.querySelectorAll('.accordion-panel')[0].style.display = 'block';

        // palette 檔案上傳事件
        document.getElementById('paletteFile').addEventListener('change', async function(e) {
          const file = e.target.files[0];
          if (!file) return;
          try {
            const reader = new FileReader();
            reader.onload = function(ev) {
              try {
                const obj = JSON.parse(ev.target.result);
                paletteName = obj.name || "palette";
                let colorList = obj.colorList || [];
                colorList = distinctColorsMaxDistance(colorList.map(hexToRgb), 8);
                if (colorList.length < 2) {
                  showMessage('調色盤顏色數量需至少2色', 'error');
                  currentPalette = null;
                  paletteName = "";
                  showPalettePreview([]);
                  return;
                }
                currentPalette = colorList;
                showPalettePreview(colorList);
                showMessage('調色盤載入成功', 'success');
              } catch (err) {
                showMessage('palette 解析失敗: ' + err, 'error');
                currentPalette = null;
                paletteName = "";
                showPalettePreview([]);
              }
            };
            reader.readAsText(file);
          } catch (err) {
            showMessage('palette 檔案讀取失敗', 'error');
            currentPalette = null;
            paletteName = "";
            showPalettePreview([]);
          }
          updateColorIndexAndPaletteNameUI();
          updatePreviewVisibility();
        });
        function hexToRgb(hex) {
          hex = hex.replace('#', '');
          if (hex.length === 3) hex = hex.split('').map(x => x + x).join('');
          const num = parseInt(hex, 16);
          return [num >> 16 & 255, num >> 8 & 255, num & 255];
        }
        function showPalettePreview(colorList) {
          const div = document.getElementById('palette-preview');
          if (!colorList || colorList.length === 0) {
            div.innerHTML = '';
            return;
          }
          div.innerHTML = colorList.map(c =>
            `<span style="display:inline-block;width:24px;height:24px;background:rgb(${c.join(',')});margin-right:2px;"></span>`
          ).join('');
        }
        // ===== 圖片色階化（palette） =====
        function quantizeToPalette(imageData, palette) {
          // 預先轉換 palette 為 LAB
          const paletteLab = palette.map(([r, g, b]) => rgbToLab(r, g, b));
          const result = [];
          for (let i = 0; i < imageData.length; i += 4) {
            const r = imageData[i], g = imageData[i+1], b = imageData[i+2], a = imageData[i+3];
            if (a < 128) {
              result.push(0); // 透明歸 0
              continue;
            }
            const lab = rgbToLab(r, g, b);
            let minDist = Infinity, idx = 0;
            for (let j = 0; j < paletteLab.length; j++) {
              const dist = labDist(lab, paletteLab[j]);
              if (dist < minDist) { minDist = dist; idx = j; }
            }
            result.push(idx);
          }
          return result;
        }
        function drawQuantizedPreview(canvas, width, height, quantized, palette) {
          const ctx = canvas.getContext('2d');
          const imgData = ctx.createImageData(width, height);
          for (let i = 0; i < quantized.length; i++) {
            const idx = quantized[i];
            const [r, g, b] = palette[idx] || [0,0,0];
            imgData.data[i*4] = r;
            imgData.data[i*4+1] = g;
            imgData.data[i*4+2] = b;
            imgData.data[i*4+3] = 255;
          }
          ctx.putImageData(imgData, 0, 0);
        }

        // ===== 多色模式：quantized 轉房間/插圖數據 =====
        function processQuantizedToRoomData(image, data, palette) {
          // 直接用 quantized 陣列切割成 tileList 與 spriteList
          const { quantized, quantizedWidth, quantizedHeight } = image;
          const { spriteWidth, spriteHeight, roomWidth, roomHeight } = data;
          const requiredWidth = roomWidth * spriteWidth;
          const requiredHeight = roomHeight * spriteHeight;
          // 若 quantized 尺寸與需求不同，需縮放
          let qArr = quantized;
          let w = quantizedWidth, h = quantizedHeight;
          if (w !== requiredWidth || h !== requiredHeight) {
            // 最近鄰縮放
            qArr = new Array(requiredWidth * requiredHeight);
            for (let y = 0; y < requiredHeight; y++) {
              for (let x = 0; x < requiredWidth; x++) {
                const srcX = Math.floor(x * w / requiredWidth);
                const srcY = Math.floor(y * h / requiredHeight);
                qArr[y * requiredWidth + x] = quantized[srcY * w + srcX];
              }
            }
            w = requiredWidth; h = requiredHeight;
          }
          // 切割成 sprite
          const spritesPerRow = Math.floor(w / spriteWidth);
          const totalSprites = spritesPerRow * Math.floor(h / spriteHeight);
          if (roomWidth * roomHeight > totalSprites) {
            throw new Error(`房間尺寸過大，圖片只能提供 ${totalSprites} 個精靈，但房間需要 ${roomWidth * roomHeight} 個`);
          }
          const spriteData = [];
          const tileList = [];
          const uniqueSprites = new Map();
          let validSpriteCount = 0;
          for (let spriteIndex = 0; spriteIndex < roomWidth * roomHeight; spriteIndex++) {
            const x = (spriteIndex % spritesPerRow) * spriteWidth;
            const y = Math.floor(spriteIndex / spritesPerRow) * spriteHeight;
            // 取得精靈區域的 quantized
            const frame = [];
            for (let sy = 0; sy < spriteHeight; sy++) {
              for (let sx = 0; sx < spriteWidth; sx++) {
                frame.push(qArr[(y+sy)*w + (x+sx)]);
              }
            }
            // 檢查是否為全透明
            if (frame.some(px => px !== 0)) {
              const key = frame.join(',');
              if (!uniqueSprites.has(key)) {
                validSpriteCount++;
                const spriteName = `${data.spriteName}-${validSpriteCount.toString().padStart(2, '0')}`;
                uniqueSprites.set(key, spriteName);
                spriteData.push({
                  name: spriteName,
                  isAvatar: data.isAvatar,
                  isWall: data.isWall,
                  isItem: data.isItem,
                  isTransparent: data.isTransparent,
                  width: spriteWidth,
                  height: spriteHeight,
                  frameList: [frame],
                  scriptList: {"on-push": "", "on-message": ""}
                });
              }
              tileList.push({
                spriteName: uniqueSprites.get(key),
                x: spriteIndex % roomWidth,
                y: Math.floor(spriteIndex / roomWidth)
              });
            }
          }
          return {
            name: data.roomName,
            paletteName: data.paletteName,
            musicName: data.musicName,
            tileList: tileList,
            scriptList: {"on-enter": "", "on-exit": ""},
            width: roomWidth,
            height: roomHeight,
            spriteWidth: spriteWidth,
            spriteHeight: spriteHeight,
            spriteList: spriteData
          };
        }
        function processQuantizedToPictureData(image, data, palette) {
          const { quantized, quantizedWidth, quantizedHeight } = image;
          const { spriteWidth, spriteHeight, roomWidth, roomHeight } = data;
          const requiredWidth = roomWidth * spriteWidth;
          const requiredHeight = roomHeight * spriteHeight;
          let qArr = quantized;
          let w = quantizedWidth, h = quantizedHeight;
          if (w !== requiredWidth || h !== requiredHeight) {
            // 最近鄰縮放
            qArr = new Array(requiredWidth * requiredHeight);
            for (let y = 0; y < requiredHeight; y++) {
              for (let x = 0; x < requiredWidth; x++) {
                const srcX = Math.floor(x * w / requiredWidth);
                const srcY = Math.floor(y * h / requiredHeight);
                qArr[y * requiredWidth + x] = quantized[srcY * w + srcX];
              }
            }
            w = requiredWidth; h = requiredHeight;
          }
          return {
            name: data.spriteName,
            type: 'picture',
            paletteName: data.paletteName,
            musicName: data.musicName,
            roomWidth: data.roomWidth,
            roomHeight: data.roomHeight,
            spriteWidth: data.spriteWidth,
            spriteHeight: data.spriteHeight,
            width: requiredWidth,
            height: requiredHeight,
            frameList: [qArr],
            scriptList: {"on-show": "", "on-hide": ""}
          };
        }

        let currentPreviewIndex = 0;
        function updateQuantizedPreview() {
          if (!currentImages.length) return;
          const idx = currentPreviewIndex;
          const img = currentImages[idx];
          const qCanvas = document.getElementById('quantized-preview');
          const label = document.getElementById('preview-index-label');
          const prevBtn = document.getElementById('preview-prev-btn');
          const nextBtn = document.getElementById('preview-next-btn');
          if (img && img.quantized) {
            qCanvas.width = img.quantizedWidth;
            qCanvas.height = img.quantizedHeight;
            drawQuantizedPreview(qCanvas, img.quantizedWidth, img.quantizedHeight, img.quantized, currentPalette);
            label.textContent = `${idx+1} / ${currentImages.length}`;
          } else {
            label.textContent = '';
            const ctx = qCanvas.getContext('2d');
            ctx.clearRect(0, 0, qCanvas.width, qCanvas.height);
          }
          if (batchMode && currentImages.length > 1) {
            prevBtn.style.display = '';
            nextBtn.style.display = '';
            prevBtn.disabled = (idx === 0);
            nextBtn.disabled = (idx === currentImages.length-1);
          } else {
            prevBtn.style.display = 'none';
            nextBtn.style.display = 'none';
          }
        }
        document.getElementById('preview-prev-btn').onclick = function() {
          if (currentPreviewIndex > 0) {
            currentPreviewIndex--;
            updateQuantizedPreview();
          }
        };
        document.getElementById('preview-next-btn').onclick = function() {
          if (currentPreviewIndex < currentImages.length-1) {
            currentPreviewIndex++;
            updateQuantizedPreview();
          }
        };
        // 在圖片上傳完成、或 batchMode 時呼叫 updateQuantizedPreview()
        // 單圖模式
        if (!batchMode) {
          currentPreviewIndex = 0;
          updateQuantizedPreview();
        }
        // 批量模式下預先載入所有圖片
        if (batchMode) {
            let loaded = 0;
            currentImages = new Array(files.length);
            files.forEach((file, idx) => {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    currentImages[idx] = {
                        width: img.width,
                        height: img.height,
                        canvas: canvas,
                        context: ctx,
                        fileName: file.name,
                        spriteName: `sprite${idx+1}`,
                        colorIndex: 1
                    };
                    // ===== 新增：多圖也要 quantized =====
                    if (currentPalette) {
                        const imgData = ctx.getImageData(0, 0, img.width, img.height);
                        currentImages[idx].quantized = quantizeToPalette(imgData.data, currentPalette);
                        currentImages[idx].quantizedWidth = img.width;
                        currentImages[idx].quantizedHeight = img.height;
                        console.log('[批量模式] quantized 寫入 currentImages['+idx+']', {
                          quantized: currentImages[idx].quantized.slice(0, 32),
                          quantizedLen: currentImages[idx].quantized.length
                        });
                    }
                    loaded++;
                    if (loaded === files.length) {
                        allImagesLoaded = true;
                        enableGenerateButtons();
                        showMessage('所有圖片已載入完成，可生成數據', 'success');
                        renderBatchSpriteSettings();
                        currentPreviewIndex = 0;
                        updateQuantizedPreview();
                        updateColorIndexAndPaletteNameUI();
                        updatePreviewVisibility();
                        showAutoPaletteSection(true);
                    }
                };
                img.onerror = function() {
                    showMessage(`第${idx+1}張圖片載入失敗`, 'error');
                };
                img.src = URL.createObjectURL(file);
            });
        }

        // 新增：palette 控制顏色索引與 paletteName UI 顯示/隱藏
        function updateColorIndexAndPaletteNameUI() {
          const colorIndexRow = document.getElementById('colorIndex').parentNode;
          const paletteNameRow = document.getElementById('paletteName').parentNode;
          const batchDiv = document.getElementById('batch-sprite-settings');
          if (currentPalette) {
            // 多色模式，隱藏顏色索引與 paletteName
            colorIndexRow.style.display = 'none';
            if (paletteNameRow) paletteNameRow.style.display = 'none';
            if (batchDiv) batchDiv.style.display = 'none';
            // 單圖模式也隱藏顏色索引
            document.getElementById('colorIndex').parentNode.style.display = 'none';
          } else {
            // 單色模式，顯示
            colorIndexRow.style.display = '';
            if (paletteNameRow) paletteNameRow.style.display = '';
            if (batchDiv) batchDiv.style.display = batchMode ? '' : 'none';
            document.getElementById('colorIndex').parentNode.style.display = '';
          }
        }

        function updatePreviewVisibility() {
          const imgPreview = document.getElementById('preview');
          const qContainer = document.getElementById('quantized-preview-container');
          if (currentPalette) {
            // 多色模式：只顯示 quantized canvas
            imgPreview.style.display = 'none';
            qContainer.style.display = 'block';
          } else {
            // 單色模式：只顯示圖片
            imgPreview.style.display = 'block';
            qContainer.style.display = 'none';
          }
        }

        function showAutoPaletteSection(show) {
          document.getElementById('auto-palette-section').style.display = show ? '' : 'none';
        }
        function rgbToHex(r,g,b) {
          return '#' + [r,g,b].map(x => x.toString(16).padStart(2,'0')).join('');
        }
        // 將 getMostFrequentColors 換成簡易分群法
        function getPaletteByQuantize(imageData, maxColors=8, quant=32) {
          const colorMap = {};
          for (let i=0; i<imageData.length; i+=4) {
            const a = imageData[i+3];
            if (a < 128) continue;
            const r = Math.round(imageData[i] / quant) * quant;
            const g = Math.round(imageData[i+1] / quant) * quant;
            const b = Math.round(imageData[i+2] / quant) * quant;
            const key = `${r},${g},${b}`;
            colorMap[key] = (colorMap[key]||0)+1;
          }
          const sorted = Object.entries(colorMap).sort((a,b)=>b[1]-a[1]);
          return sorted.slice(0, maxColors).map(([k]) => {
            const [r,g,b] = k.split(',').map(Number);
            return rgbToHex(r,g,b);
          });
        }
        // 新增簡易 k-means 分群函數
        function getPaletteKMeans(imageData, maxColors=8, maxIter=10) {
          const pixels = [];
          for (let i=0; i<imageData.length; i+=4) {
            if (imageData[i+3] < 128) continue;
            pixels.push([imageData[i], imageData[i+1], imageData[i+2]]);
          }
          if (pixels.length === 0) return ['#000000', '#ffffff'];
          // 隨機初始化中心
          const centers = [];
          for (let i=0; i<maxColors; i++) {
            centers.push(pixels[Math.floor(Math.random()*pixels.length)].slice());
          }
          for (let iter=0; iter<maxIter; iter++) {
            // 分配每個像素到最近中心
            const clusters = Array.from({length:maxColors}, ()=>[]);
            for (const p of pixels) {
              let minDist = Infinity, idx = 0;
              for (let c=0; c<maxColors; c++) {
                const d = (p[0]-centers[c][0])**2 + (p[1]-centers[c][1])**2 + (p[2]-centers[c][2])**2;
                if (d < minDist) { minDist = d; idx = c; }
              }
              clusters[idx].push(p);
            }
            // 更新中心
            for (let c=0; c<maxColors; c++) {
              if (clusters[c].length === 0) continue;
              const sum = clusters[c].reduce((a,b)=>[a[0]+b[0],a[1]+b[1],a[2]+b[2]],[0,0,0]);
              centers[c] = sum.map(x=>Math.round(x/clusters[c].length));
            }
          }
          // ===== 新增：依每個中心的像素數量排序（主色優先） =====
          // 統計每個中心的像素數量
          const countArr = new Array(maxColors).fill(0);
          for (const p of pixels) {
            let minDist = Infinity, idx = 0;
            for (let c=0; c<maxColors; c++) {
              const d = (p[0]-centers[c][0])**2 + (p[1]-centers[c][1])**2 + (p[2]-centers[c][2])**2;
              if (d < minDist) { minDist = d; idx = c; }
            }
            countArr[idx]++;
          }
          // 依照數量排序
          const centerWithCount = centers.map((c,i)=>({color:c, count:countArr[i]}));
          centerWithCount.sort((a,b)=>b.count-a.count);
          // 轉 HEX
          return centerWithCount.map(obj=>rgbToHex(obj.color[0],obj.color[1],obj.color[2]));
        }
        function hexToRgbArr(hex) {
          hex = hex.replace('#','');
          if (hex.length === 3) hex = hex.split('').map(x=>x+x).join('');
          const num = parseInt(hex, 16);
          return [num>>16&255, num>>8&255, num&255];
        }
        // 只做單純 8 色分散，不保留主色
        function distinctColorsMaxDistance(colors, maxColors=8) {
          if (!colors.length) return [];
          const arr = colors.map(c => Array.isArray(c) ? c : hexToRgbArr(c));
          const result = [arr[0]];
          for (let i = 1; i < arr.length && result.length < maxColors; i++) {
            let tooClose = false;
            for (let j = 0; j < result.length; j++) {
              if (colorDist(result[j], arr[i]) < 40) { tooClose = true; break; }
            }
            if (!tooClose) result.push(arr[i]);
          }
          // 如果還不夠 8 色，隨便補
          for (let i = 0; i < arr.length && result.length < maxColors; i++) {
            let already = false;
            for (let j = 0; j < result.length; j++) {
              if (colorDist(result[j], arr[i]) < 1) { already = true; break; }
            }
            if (!already) result.push(arr[i]);
          }
          return result;
        }
        function colorDist(a, b) {
          return Math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2 + (a[2]-b[2])**2);
        }
        document.getElementById('autoPaletteBtn').onclick = function() {
          if (!currentImages.length) {
            alert('請先上傳圖片');
            return;
          }
          const img = currentImages[currentPreviewIndex] || currentImages[0];
          let ctx = img.context;
          if (!ctx && img.canvas) ctx = img.canvas.getContext('2d');
          if (!ctx) {
            alert('無法取得圖片像素');
            return;
          }
          const w = img.width || img.canvas.width;
          const h = img.height || img.canvas.height;
          const imageData = ctx.getImageData(0,0,w,h).data;
          // 產生三組不同 palette
          const paletteList = [];
          for (let i = 0; i < 3; i++) {
            // 每組用不同 K-means 隨機中心
            let centers = getPaletteKMeans(imageData, 32, 10);
            let colors = distinctColorsMaxDistance(centers, 8);
            if (colors.length < 2) colors = ['#000000', '#ffffff'];
            paletteList.push(colors.map(c => typeof c === 'string' ? c : rgbToHex(...c)));
          }
          // 顯示 palette 多組預覽區塊
          showMultiPalettePreview(paletteList);
          // 預設選第一組
          currentPalette = paletteList[0].map(hexToRgb);
          showPalettePreview(currentPalette);
          // 隱藏 JSON 結果和下載按鈕，等選擇後才顯示
          document.getElementById('autoPaletteResult').style.display = 'none';
          document.getElementById('autoPaletteDownloadBtn').style.display = 'none';
        };
        document.getElementById('autoPaletteDownloadBtn').onclick = function() {
          const text = document.getElementById('autoPaletteResult').value;
          const name = document.getElementById('autoPaletteName').value || '自動產生調色盤';
          const blob = new Blob([text], {type:'application/json'});
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = name + '.mosipalette';
          document.body.appendChild(a);
          a.click();
          setTimeout(()=>{ document.body.removeChild(a); }, 100);
        };
        // 在圖片 onload（單圖/多圖）後呼叫 showAutoPaletteSection(true)
        // 在清除按鈕時呼叫 showAutoPaletteSection(false)

        // 新增：從文字匯入調色盤
        document.getElementById('paletteTextImportBtn').onclick = function() {
          const text = document.getElementById('paletteTextImport').value.trim();
          if (!text) {
            showMessage('請貼上調色盤 JSON 文字', 'error');
            return;
          }
          try {
            const obj = JSON.parse(text);
            paletteName = obj.name || "palette";
            let colorList = obj.colorList || [];
            colorList = distinctColorsMaxDistance(colorList.map(hexToRgb), 8);
            if (colorList.length < 2) {
              showMessage('調色盤顏色數量需至少2色', 'error');
              currentPalette = null;
              paletteName = "";
              showPalettePreview([]);
              console.log('[palette] 解析失敗 palette 顏色數量不足:', colorList);
              return;
            }
            // colorList 需轉成 hex 字串
            colorList = colorList.map(c => typeof c === 'string' ? c : rgbToHex(...c));
            currentPalette = colorList.map(hexToRgb);
            showPalettePreview(colorList.map(hexToRgb));
            showMessage('調色盤匯入成功', 'success');
            console.log('[palette] 文字匯入成功:', currentPalette, 'paletteName:', paletteName);
          } catch (err) {
            showMessage('palette 解析失敗: ' + err, 'error');
            currentPalette = null;
            paletteName = "";
            showPalettePreview([]);
            console.log('[palette] 文字匯入失敗:', err);
          }
          updateColorIndexAndPaletteNameUI();
          // ===== 新增：自動更新 canvas 預覽 =====
          if (currentImages.length && currentImages[0] && currentImages[0].canvas) {
            // 單圖或多圖都處理
            for (let i = 0; i < currentImages.length; i++) {
              const img = currentImages[i];
              if (img && img.canvas && currentPalette) {
                const ctx = img.context || img.canvas.getContext('2d');
                const w = img.width || img.canvas.width;
                const h = img.height || img.canvas.height;
                const imgData = ctx.getImageData(0, 0, w, h);
                img.quantized = quantizeToPalette(imgData.data, currentPalette);
                img.quantizedWidth = w;
                img.quantizedHeight = h;
              }
            }
            updateQuantizedPreview();
          }
          updatePreviewVisibility();
        };

        // ========== 手機版 tab 分類下拉選單 ===========
        // 定義分類與子項
        const tabCategories = [
          {
            label: '圖片工具',
            value: 'img',
            children: [
              { label: '圖片上傳', value: 'upload-img' },
              { label: '精靈設定', value: 'sprite-settings' },
              { label: '房間設定', value: 'room-settings' },
              { label: '生成結果', value: 'data' },
            ]
          },
          {
            label: '合併工具',
            value: 'merge',
            children: [
              { label: '房間合併工具', value: 'merge-rooms' },
              { label: '合併精靈工具', value: 'merge-sprite-section' },
              { label: '合併房間單色精靈工具', value: 'merge-room-section' },
              { label: '世界級合併工具', value: 'merge-world-section' },
              { label: '插圖合併工具', value: 'merge-picture-section' },
            ]
          },
          {
            label: '轉換工具',
            value: 'convert',
            children: [
              { label: '房間轉插圖工具', value: 'room-to-picture-section' },
              { label: '對話框皮膚轉換工具', value: 'textbox-skin-section' },
            ]
          }
        ];
        // 初始化下拉選單
        function initMobileTabSelect() {
          const catSel = document.getElementById('tab-category-select');
          const tabSel = document.getElementById('tab-select');
          // 填充母類別
          catSel.innerHTML = '';
          tabCategories.forEach((cat, i) => {
            const opt = document.createElement('option');
            opt.value = cat.value;
            opt.textContent = cat.label;
            catSel.appendChild(opt);
          });
          // 根據第一個母類別填充子類別
          updateTabSelectByCategory(catSel.value || tabCategories[0].value);
        }
        function updateTabSelectByCategory(catValue) {
          const tabSel = document.getElementById('tab-select');
          tabSel.innerHTML = '';
          const cat = tabCategories.find(c => c.value === catValue) || tabCategories[0];
          cat.children.forEach(child => {
            const opt = document.createElement('option');
            opt.value = child.value;
            opt.textContent = child.label;
            tabSel.appendChild(opt);
          });
        }
        // 切換母類別時，更新子類別
        document.getElementById('tab-category-select').addEventListener('change', function() {
          updateTabSelectByCategory(this.value);
          // 切到第一個子類別
          const tabSel = document.getElementById('tab-select');
          setTab(tabSel.value);
        });
        // 切換子類別時，顯示對應 tab
        document.getElementById('tab-select').addEventListener('change', function() {
          setTab(this.value);
        });
        // 響應式顯示/隱藏下拉選單
        function updateTabSelectVisibility() {
          const isMobile = window.innerWidth <= 900;
          document.getElementById('tab-category-select').style.display = isMobile ? '' : 'none';
          document.getElementById('tab-select').style.display = isMobile ? '' : 'none';
          // ====== 新增：切換顯示方式時自動同步當前 tab 狀態 ======
          if (isMobile) {
            // 手機版：根據 currentTabId 設定下拉選單
            let found = false;
            for (let cat of tabCategories) {
              if (cat.children.some(child => child.value === currentTabId)) {
                document.getElementById('tab-category-select').value = cat.value;
                updateTabSelectByCategory(cat.value);
                document.getElementById('tab-select').value = currentTabId;
                found = true;
                break;
              }
            }
            if (!found) {
              document.getElementById('tab-category-select').value = tabCategories[0].value;
              updateTabSelectByCategory(tabCategories[0].value);
              document.getElementById('tab-select').value = tabCategories[0].children[0].value;
              setTab(tabCategories[0].children[0].value);
            }
          } else {
            // 桌面版：根據 currentTabId 設定 active 標籤
            setTab(currentTabId);
          }
        }
        window.addEventListener('resize', updateTabSelectVisibility);
        // 初始化
        initMobileTabSelect();
        updateTabSelectVisibility();
        // 預設顯示第一個 tab
        setTab(document.getElementById('tab-select').value);

        // palette 多組預覽區塊
        // 新增：多組 palette 預覽（獨立區塊）
        function showMultiPalettePreview(paletteList) {
          const section = document.getElementById('auto-multi-palette-section');
          const container = document.getElementById('multi-palette-preview');
          if (!container || !section) return;
          section.style.display = '';
          container.innerHTML = '';
          paletteList.forEach((palette, idx) => {
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.alignItems = 'center';
            row.style.marginBottom = '6px';
            // 色條
            const colorBar = document.createElement('div');
            colorBar.style.display = 'flex';
            palette.forEach(c => {
              const swatch = document.createElement('span');
              swatch.style.display = 'inline-block';
              swatch.style.width = '24px';
              swatch.style.height = '24px';
              swatch.style.background = typeof c === 'string' ? c : `rgb(${c.join(',')})`;
              swatch.style.marginRight = '2px';
              colorBar.appendChild(swatch);
            });
            row.appendChild(colorBar);
            // 選擇按鈕
            const btn = document.createElement('button');
            btn.textContent = '✓';
            btn.style.margin = '1px';
            btn.onclick = function() {
              // 設定 currentPalette 並更新主預覽
              currentPalette = palette.map(hexToRgb);
              showPalettePreview(currentPalette);
              showMessage(`已選擇第${idx+1}組調色盤`, 'success');
              // 更新 quantized 預覽
              if (currentImages.length && currentImages[0] && currentImages[0].canvas) {
                for (let i = 0; i < currentImages.length; i++) {
                  const img = currentImages[i];
                  if (img && img.canvas && currentPalette) {
                    const ctx = img.context || img.canvas.getContext('2d');
                    const w = img.width || img.canvas.width;
                    const h = img.height || img.canvas.height;
                    const imgData = ctx.getImageData(0, 0, w, h);
                    img.quantized = quantizeToPalette(imgData.data, currentPalette);
                    img.quantizedWidth = w;
                    img.quantizedHeight = h;
                  }
                }
                updateQuantizedPreview();
              }
              updatePreviewVisibility();
              // 選擇 palette 後才產生 JSON 結果和下載按鈕
              const name = document.getElementById('autoPaletteName').value || '自動產生調色盤';
              const paletteObj = { name, colorList: palette };
              const result = JSON.stringify(paletteObj);
              document.getElementById('autoPaletteResult').value = result;
              document.getElementById('autoPaletteResult').style.display = '';
              document.getElementById('autoPaletteDownloadBtn').style.display = '';
            };
            row.appendChild(btn);
            container.appendChild(row);
          });
        }

        // ===== RGB 轉 LAB 色空間 =====
        function rgbToXyz(r, g, b) {
          r = r / 255; g = g / 255; b = b / 255;
          r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
          g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
          b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
          let x = r * 0.4124 + g * 0.3576 + b * 0.1805;
          let y = r * 0.2126 + g * 0.7152 + b * 0.0722;
          let z = r * 0.0193 + g * 0.1192 + b * 0.9505;
          return [x * 100, y * 100, z * 100];
        }
        function xyzToLab(x, y, z) {
          let refX = 95.047, refY = 100.0, refZ = 108.883;
          x = x / refX; y = y / refY; z = z / refZ;
          x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;
          y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;
          z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;
          let L = (116 * y) - 16;
          let a = 500 * (x - y);
          let b = 200 * (y - z);
          return [L, a, b];
        }
        function rgbToLab(r, g, b) {
          const [x, y, z] = rgbToXyz(r, g, b);
          return xyzToLab(x, y, z);
        }
        function labDist(lab1, lab2) {
          return Math.sqrt(
            (lab1[0] - lab2[0]) ** 2 +
            (lab1[1] - lab2[1]) ** 2 +
            (lab1[2] - lab2[2]) ** 2
          );
        }
    </script>
</body>
</html> 
