<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mosiåœ–ç‰‡è½‰æˆ¿é–“æ•¸æ“šç”¢ç”Ÿå™¨</title>
    <style>
        :root {
            /* ç²‰è‰²ç³» */
            --main-color: #ED87BE;
            --secondary-color: #e1539b;
            --bg-hover: #503B49;
            --bg-light: #3F2D38;
            --bg-color: #2F2429;
            --success-color: #7fcbb3;
            --error-color: #FF6D95;
            /* èˆŠç‰ˆ */
            /*--main-color: #594a54;
            --secondary-color: #f69f8f;
            --text-color: #9c758f;
            --bg-hover: #bbaec0;
            --bg-light: #d3cbd0;
            --bg-color: #f5f5f5;
            --success-color: #51cf66;
            --success-bg: #ebfbee;
            --error-color: #ff6b6b;
            --error-bg: #ffe6e6;*/
        }
        
        @font-face {
            font-family: 'fakePearl';
            src: url('static/FakePearl-SemiBold.ttf') format('woff2'), url('static/FakePearl-SemiBold.ttf') format('ttf');
            font-weight: normal;
            font-style: normal;
        }
        * {
            box-sizing: border-box;
            font-family: "fakePearl", sans-serif;
            text-align: center;
        }
        html, body {
            background-color: var(--main-color);
            color: var(--bg-light);
        }
        a {
            color: var(--secondary-color);
        }
        canvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: pixelated;
        }
        hr {
            margin: 1em 0;
            border-color: var(--main-color);
        }
        input[type="text"], input[type=number] {
            background-color: var(--bg-color);
            border: 2px solid var(--main-color);
            color: var(--main-color);
            margin: 1em;
            padding: 0.5em;
            font-size: 1em;
            border-radius: 10px;
        }
        input[type="checkbox"] {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            width: 20px;
            height: 20px;
            margin: 1em;
            border: 2px solid var(--main-color);
            border-radius: 10px;
            background: var(--bg-color);
            cursor: pointer;
            position: relative;
            transition: background 0.2s, border-color 0.2s;
        }
        input[type="checkbox"]:checked {
            background: var(--main-color);
            border-color: var(--main-color);
        }
        input[type="checkbox"]:checked::after {
            content: 'âœ“';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--bg-color);
            font-size: 14px;
            font-weight: bold;
        }
        button, select{
            border: none;
            background: var(--main-color);
            color: var(--bg-color);
            width: 14em;
            margin: 1em;
            padding: 12px 16px;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            border-radius: 10px;
        }
        input[type="file"] {
            position: relative;
            overflow: hidden;
            width: 14em;
            height: 45px;
            cursor: pointer;
            background: transparent;
            border: none;
            padding: 0;
            margin: 1em;
            z-index: 2;
            font-size: 1em;
        }
        input[type="file"]::-webkit-file-upload-button {
            visibility: hidden;
            width: 0;
            height: 0;
        }
        input[type="file"]::file-selector-button {
            visibility: hidden;
            width: 0;
            height: 0;
        }
        input[type="file"]::before {
            content: attr(data-original-text);
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: var(--main-color);
            color: var(--bg-color);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            border-radius: 10px;
            z-index: 1;
            font-size: 1em;
            padding: 12px 16px;
            border: none;
            box-sizing: border-box;
            font-family: inherit;
            font-weight: inherit;
        }
        input[type="file"]:hover::before {
            background: var(--bg-hover);
            color: var(--main-color);
        }
        button:hover, select:hover {
            background: var(--bg-hover);
            color: var(--main-color);
        }
        select option {
            background: var(--bg-hover);
            color: var(--main-color);
            padding: 8px;
            font-size: 1em;
        }
        select:focus {
            outline: none;
            background: var(--bg-hover);
            color: var(--main-color);
        }
        label {
            display: flex;
            flex-wrap: wrap;
            align-content: center;
            justify-content: center;
            align-items: center;
        }
        textarea {
            background-color: var(--bg-color);
            border: 2px solid var(--main-color);
            color: var(--main-color);
            border-radius: 10px;
            text-align: left;
            height: 256px;
            width: 256px;
            font-family: monospace;
        }
        .flex-container {
            background-color: var(--bg-light);
            display: flex;
            flex-flow: row wrap;
        }
        .section {
            margin: 0 auto;
            background-color: var(--bg-light);
            color: var(--main-color);
            width: 256px;
            padding-bottom: 1em;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-content: space-between;
        }
        .settings-container {
            display: flex;
            justify-content: space-between;
        }
        .sprite-settings, .room-settings {
            flex: 1;
            box-sizing: border-box;
        }
        
        .palette-container {
            margin: 1.5em 0;
            padding: 1em;
            background: var(--bg-color);
            border-radius: 8px;
            max-width: 350px;
        }
        @media (max-width: 768px) {
            .settings-container {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            .sprite-settings, .room-settings {
                flex: none;
                width: 100%;
            }
        }
        
        /* ç§»å‹•è¨­å‚™çš„éŸ¿æ‡‰å¼è¨­è¨ˆ */
        @media (max-width: 768px) {
            #preview {
                max-width: 250px !important;
            }
        }
        #preview-container, #preview-result-container {
            /*transition: all 0.3s ease;*/
            margin: 1.5em 0; 
            background: var(--bg-color); 
            border-radius: 8px; 
            padding-top: 10px;
            padding-bottom: 10px;
        }
        
        .preview-btn-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 10px;
            margin-left: 10px;
            margin-right: 10px;
        }
        
        .preview-arrow-btn {
            color: var(--bg-light);
            background: var(--main-color);
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            font-size: 0.5em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, color 0.2s, transform 0.2s;
            z-index: 10;
            margin: 0;
            padding: 0;
        }
        
        .preview-arrow-btn:hover {
            background: var(--bg-hover);
            color: var(--bg-color);
        }
        
        .preview-arrow-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .preview-index-label {
            margin: 0 8px;
            color: var(--main-color);
        }
        
        .preview-canvas {
            width: 100%;
            max-width: 400px;
            height: auto;
            image-rendering: pixelated;
        }
        #preview-img, #preview-canvas {
            margin: 0 auto;
            width: 256px;
            transition: transform 0.2s;
        }
        /* åªæœ‰åœ¨å¯ä»¥åˆ‡æ›é¡¯ç¤ºæ™‚æ‰å¥—ç”¨ hover æ•ˆæœ */
        #preview-img.clickable:hover, #preview-canvas.clickable:hover {
            transform: scale(0.98);
            transition: transform 0.2s;
        }
        /* é»æ“Šå¾Œçš„ç¸®æ”¾ç‹€æ…‹ */
        #preview-img.clickable.clicked, #preview-canvas.clickable.clicked {
            transform: scale(0.98);
            transition: transform 0.2s;
        }
        #file-list, #mergeSpriteFileList, #mergePictureFileList {
            list-style-type: none;
            padding: 0;
            border: 2px dashed var(--main-color);
            border-radius: 8px;
            margin-top: 10px;
            max-width: 400px;
        }
        #file-list li, #mergeSpriteFileList li, #mergePictureFileList li {
            display: flex;
            align-items: center;
            padding: 10px;
            margin: 5px;
            background-color: var(--bg-hover);
            border-radius: 5px;
            cursor: grab;
            transition: all 0.3s ease;
        }
        #file-list li img, #mergeSpriteFileList li img, #mergePictureFileList li img {
            width: 24px;
            height: 24px;
            margin-right: 10px;
        }
        #file-list li.drag-hover, #mergeSpriteFileList li.drag-hover, #mergePictureFileList li.drag-hover {
            background-color: var(--main-color);
            color: var(--bg-color);
        }
        #file-list.dragging, #mergeSpriteFileList.dragging, #mergePictureFileList.dragging {
            border: 2px dashed var(--main-color);
        }
        .error, .success {
            padding: 10px;
            border-radius: 10px;
            margin: 10px 0;
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            max-width: 90vw;
            word-wrap: break-word;
        }
        .error {
            color: var(--error-color);
            background-color: var(--bg-light);
            border: 2px solid var(--error-color);
        }
        .success {
            color: var(--success-color);
            background-color: var(--bg-light);
            border: 2px solid var(--success-color);
        }

        /* Tab æ¨£å¼ */
        .tab-layout {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            width: 100%;
            max-width: 768px;
            margin: 0 auto;
            /* min-height: 600px; */ /* ç§»é™¤å›ºå®šé«˜åº¦ */
        }
        .tab-bar, #tab-select, #tab-category-select {
            margin-right: 0;
        }
        .tab-bar {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            min-width: 140px;
            max-width: 200px;
            background: var(--bg-light);
            border-radius: 10px 0 0 10px;
            height: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-sizing: border-box;
        }
        .accordion-group {
            width: 100%;
            box-sizing: border-box;
        }
        .tab-bar button,
        .tab-bar .tab-btn,
        .tab-bar .accordion-btn {
            width: 100% !important;
            min-width: 0;
            max-width: 100%;
            display: block;
            box-sizing: border-box;
            margin: 0 !important;
        }
        .accordion-btn, .tab-bar button, .tab-bar .tab-btn {
            box-sizing: border-box;
            border: none;
            outline: none;
            background: var(--bg-hover);
            color: var(--main-color);
            font-size: 1.1em;
            text-align: left;
            padding: 12px 16px;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            border-radius: 0;
            margin: 0;
        }
        .accordion-btn.active, .accordion-btn:hover {
            background: var(--main-color);
            color: var(--bg-color);
        }
        .accordion-panel {
            display: none;
            flex-direction: column;
            align-items: stretch;
            padding: 0;
            background: var(--bg-color);
            margin-bottom: 8px;
            width: 100%;
        }
        .accordion-panel .tab-btn {
            border-left: 5px solid transparent;
            border-radius: 0;
            padding: 10px 16px;
            background: none;
            color: var(--main-color);
            font-size: 1em;
            text-align: left;
            transition: background 0.2s, color 0.2s, border-color 0.2s;
        }
        .accordion-panel .tab-btn.active {
            background: var(--secondary-color);
            color: var(--bg-color);
        }
        .tab-content {
            flex: 1;
            min-width: 0;
            max-width: 600px;
            width: 100%;
            height: 600px;
            overflow-y: auto;
            background: var(--bg-light);
            border-radius: 0 10px 10px 0;
            box-sizing: border-box;
        }
        .tab-section { display: none; }
        .tab-section.active { display: block; }
        /* éŸ¿æ‡‰å¼ï¼šæ‰‹æ©Ÿç‰ˆç”¨ä¸‹æ‹‰é¸å–® */
        @media (max-width: 768px) {
            .tab-layout { flex-direction: column; min-height: 0; }
            .tab-bar { display: none !important; }
            #tab-select, #tab-category-select {
                display: block !important;
                margin: 1em auto 1em auto;
                width: 90%;
                max-width: 400px;
                font-size: 1.1em;
                background: var(--bg-light);
                color: var(--main-color);
                border: 1px solid var(--main-color);
                border-radius: 8px;
                padding: 0.7em 1em;
            }
            .tab-content {
                max-width: 100%;
                height: auto;
                border-radius: 10px;
            }
        }
        #tab-select, #tab-category-select { display: none; }
        .header-toggle-btn {
            position: absolute;
            top: 18px;
            right: 24px;
            background: var(--bg-light);
            color: var(--main-color);
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            font-size: 1em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, color 0.2s, transform 0.2s;
            z-index: 10;
        }
        .preview-arrow-btn {
            color: var(--bg-light);
            background: var(--main-color);
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            font-size: 0.5em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, color 0.2s, transform 0.2s;
            z-index: 10;
            margin: 0;
            padding: 0;
        }
        .header-toggle-btn:hover {
            background: var(--bg-hover);
            color: var(--bg-color);
        }
        .preview-arrow-btn:hover {
            background: var(--bg-hover);
            color: var(--bg-color);
        }
        .header-collapsed {
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-height 0.3s, opacity 0.3s;
            padding-bottom: 0 !important;
        }
        .header-content {
            transition: max-height 0.3s, opacity 0.3s;
        }
        .header-toggle-btn.rotate {
            transform: rotate(180deg);
        }
        header { position: relative; }
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
            background: var(--bg-color);
            border-radius: 5px;
        }
        ::-webkit-scrollbar-thumb {
            background: var(--main-color);
            border-radius: 5px;
            border: 2px solid var(--bg-color);
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--bg-hover);
        }
    </style>
    <link rel="icon" href="static/é»‘ç§‘æŠ€.png" type="image/x-icon">
</head>
<body>
    <header>
        <button class="header-toggle-btn" id="headerToggleBtn" title="é–‹åˆèªªæ˜">â–¼</button>
        <div class="header-content" id="headerContent">
            <h1>Mosiåœ–ç‰‡è½‰æˆ¿é–“æ•¸æ“šç”¢ç”Ÿå™¨</h1>
            <p>è½‰æ›ä»»ä½•åœ–ç‰‡è‡³<a href="https://ebluvu.itch.io/mosi-ch">Mosiä¸­æ–‡ç‰ˆ</a>çš„æˆ¿é–“æ•¸æ“š</p>
            <p><a href="https://ebluvu.notion.site/163642e52df080c794f3ea51a1612c57">é—œæ–¼</a>ï½œæœ‰ä»»ä½•ç–‘å•æ­¡è¿è¯ç¹«æˆ‘</p>
        </div>
    </header>

    <div class="tab-layout">
      <div class="tab-bar">
        <div class="accordion-group">
          <button class="accordion-btn" type="button">åœ–ç‰‡å·¥å…·</button>
          <div class="accordion-panel">
            <button class="tab-btn" data-tab="upload-img">åœ–ç‰‡ä¸Šå‚³</button>
            <button class="tab-btn" data-tab="sprite-settings">ç²¾éˆè¨­å®š</button>
            <button class="tab-btn" data-tab="room-settings">æˆ¿é–“è¨­å®š</button>
            <button class="tab-btn" data-tab="data">ç”Ÿæˆçµæœ</button>
          </div>
        </div>
        <div class="accordion-group">
          <button class="accordion-btn" type="button">åˆä½µå·¥å…·</button>
          <div class="accordion-panel">
            <button class="tab-btn" data-tab="merge-rooms">æˆ¿é–“åˆä½µå·¥å…·</button>
            <button class="tab-btn" data-tab="merge-sprite-section">ç²¾éˆåˆä½µå·¥å…·</button>
            <button class="tab-btn" data-tab="merge-room-section">æˆ¿é–“åˆä½µå–®è‰²ç²¾éˆå·¥å…·</button>
            <button class="tab-btn" data-tab="merge-world-section">ä¸–ç•Œç´šåˆä½µå·¥å…·</button>
            <button class="tab-btn" data-tab="merge-picture-section">æ’åœ–åˆä½µå·¥å…·</button>
          </div>
        </div>
        <div class="accordion-group">
          <button class="accordion-btn" type="button">è½‰æ›å·¥å…·</button>
          <div class="accordion-panel">
            <button class="tab-btn" data-tab="room-to-picture-section">æˆ¿é–“è½‰æ’åœ–å·¥å…·</button>
            <button class="tab-btn" data-tab="textbox-skin-section">å°è©±æ¡†çš®è†šè½‰æ›å·¥å…·</button>
          </div>
        </div>
      </div>
      <select id="tab-category-select"></select>
      <select id="tab-select">
        <option value="upload-img">åœ–ç‰‡ä¸Šå‚³</option>
        <option value="sprite-settings">ç²¾éˆè¨­å®š</option>
        <option value="room-settings">æˆ¿é–“è¨­å®š</option>
        <option value="data">ç”Ÿæˆçµæœ</option>
        <option value="merge-rooms">æˆ¿é–“åˆä½µå·¥å…·</option>
        <option value="merge-sprite-section">ç²¾éˆåˆä½µå·¥å…·</option>
        <option value="merge-room-section">æˆ¿é–“åˆä½µå–®è‰²ç²¾éˆå·¥å…·</option>
        <option value="merge-world-section">ä¸–ç•Œç´šåˆä½µå·¥å…·</option>
        <option value="merge-picture-section">æ’åœ–åˆä½µå·¥å…·</option>
        <option value="room-to-picture-section">æˆ¿é–“è½‰æ’åœ–å·¥å…·</option>
        <option value="textbox-skin-section">å°è©±æ¡†çš®è†šè½‰æ›å·¥å…·</option>
      </select>
      <div class="tab-content">
        <div class="flex-container">
          <div class="section tab-section active" id="upload-img" style="position: relative;">
            <h2>åœ–ç‰‡</h2>
            <div id="preview-container" style="display: block;">
              <img id="preview-img" alt="é è¦½" src="static/rest.png" style="max-width: 300px; display: block;">
              <canvas id="preview-canvas" width="256" height="256" style="display:none;"></canvas>
              <div id="palette-preview" style="margin: 0.5em 0; display: none;"></div>
              <div id="preview-btn-container" class="preview-btn-container">
                <button id="preview-prev-btn" class="preview-arrow-btn"><</button>
                <span id="preview-index-label" class="preview-index-label"></span>
                <button id="preview-next-btn" class="preview-arrow-btn">></button>
              </div>
            </div>
            <form id="upload-form" style="margin: 1em 0;">
                <label for="file">ä¸Šå‚³ä¸€æˆ–å¤šå¼µåœ–ç‰‡: </label>
                <input type="file" id="file" name="file" accept="image/*" required multiple>
                <button type="submit">è¼‰å…¥åœ–ç‰‡</button>
            </form>
            <div id="palette-section" class="palette-container">
                <div style="margin: 0.5em 0; font-size: 0.9em; color: var(--secondary-color);">
                    <label>è‰²éšåŒ–æ–¹æ³•ï¼š
                        <select id="quantizeMethod">
                            <option value="lab">LAB è‰²å½©ç©ºé–“ï¼ˆé è¨­ï¼‰</option>
                            <option value="hsl">HSL è‰²å½©ç©ºé–“</option>
                        </select>
                    </label>
                </div>
                <div id="current-palette-status" style="margin: 0.5em 0; padding: 0.5em; border-left: 4px solid var(--secondary-color);">
                    ç•¶å‰èª¿è‰²ç›¤ï¼š<span id="current-palette-name">ç„¡</span>
                </div>
                <textarea id="paletteTextImport" placeholder="è²¼ä¸Šèª¿è‰²ç›¤æ•¸æ“š..." style="width:90%;height:48px;margin-bottom:4px;"></textarea><br>
                <button id="paletteTextImportBtn" style="margin: 0.5em 0;" type="button">å¾æ–‡å­—åŒ¯å…¥èª¿è‰²ç›¤</button>
                <label>ä¸Šå‚³èª¿è‰²ç›¤ï¼š<input type="file" id="paletteFile" accept=".mosipalette"></label>
            </div>
            <div id="auto-palette-section" class="palette-container" style="display: none;">
              <h3 style="color:var(--main-color);">æ™ºèƒ½èª¿è‰²ç›¤ç”Ÿæˆ</h3>
              <button id="autoPaletteBtn" style="margin:0.5em 0;">åµæ¸¬åœ–ç‰‡é¡è‰²</button>
                <div id="color-selection-section" style="margin: 0.5em 0 0.5em 0; display:none;">
                <div style="font-weight:bold; color:var(--main-color); margin-bottom:0.3em;">é¸æ“‡é¡è‰²ï¼š</div>
                <div id="color-grid" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(40px, 1fr)); gap:4px; margin-bottom:0.5em;"></div>
                <div style="font-size:0.9em; color:var(--secondary-color); margin-bottom:0.5em;">
                  å·²é¸æ“‡: <span id="selected-count">0</span>/8 å€‹é¡è‰²
                </div>
                <hr>
                <label style="color:var(--main-color);">èª¿è‰²ç›¤åç¨±ï¼š<input type="text" id="autoPaletteName" value="æ™ºèƒ½èª¿è‰²ç›¤" style="width: 10em;" /></label>
                <button id="confirmPaletteBtn" style="margin:0.5em 0; display:none;">ç¢ºèªç”Ÿæˆèª¿è‰²ç›¤</button>
              </div>
              <textarea id="autoPaletteResult" style="width:90%;height:90px;display:none;"></textarea>
              <button id="autoPaletteDownloadBtn" style="margin: 0.5em 0;display:none;">ä¸‹è¼‰èª¿è‰²ç›¤æ•¸æ“š</button>
            </div>
            <div id="image-info" style="display: none;">
                <p>åœ–ç‰‡å°ºå¯¸: <span id="image-size"></span></p>
                <p>å»ºè­°çµ„åˆ:</p>
                <div id="suggestions" style="text-align: left; margin: 10px 0; padding: 10px; background: var(--bg-color); border-radius: 5px; max-height: 200px; overflow-y: auto;"></div>
            </div>
        </div>
          <form id="generate-form" style="width:100%;">
            <div class="settings-container">
              <div class="section tab-section" id="sprite-settings">
                    <h2>ç²¾éˆè¨­å®š</h2>
                    <label>ç²¾éˆåç¨±: <input type="text" id="spriteName" value="sprite"></label><br>
                    <label>ç²¾éˆå¯¬åº¦: <input type="number" id="spriteWidth" value="8" min="1" max="24"></label><br>
                    <label>ç²¾éˆé«˜åº¦: <input type="number" id="spriteHeight" value="8" min="1" max="24"></label><br>
                    <label>æ˜¯å¦ç‚ºä¸»è§’: <input type="checkbox" id="isAvatar"></label><br>
                    <label>æ˜¯å¦ç‚ºç‰†: <input type="checkbox" id="isWall"></label><br>
                    <label>æ˜¯å¦ç‚ºé“å…·: <input type="checkbox" id="isItem"></label><br>
                    <label>æ˜¯å¦ç‚ºé€æ˜åŒ–: <input type="checkbox" id="isTransparent"></label><br>
                    <label>é¡è‰²ç´¢å¼•:
                        <select id="colorIndex">
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                            <option value="4">4</option>
                            <option value="5">5</option>
                            <option value="6">6</option>
                            <option value="7">7</option>
                        </select>
                    </label><br>
                    <div id="batch-sprite-settings" style="display:none;"></div>
                    <small style="color: var(--secondary-color);">â€» ç²¾éˆå°ºå¯¸æœ€å¤§ç‚º 24Ã—24</small>
                    <small style="color: var(--secondary-color); display: block; margin-top: 5px;">ğŸ’¡ ä¿®æ”¹ç²¾éˆå°ºå¯¸æœƒè‡ªå‹•è¨ˆç®—æˆ¿é–“å°ºå¯¸</small>
                </div>
                <div class="section tab-section" id="room-settings">
                    <h2>æˆ¿é–“è¨­å®š</h2>
                    <label>æˆ¿é–“(æª”æ¡ˆ)åç¨±: <input type="text" id="roomName" value="room-1"></label><br>
                    <label>èª¿è‰²ç›¤åç¨±: <input type="text" id="paletteName" value="palette-1"></label><br>
                    <label>éŸ³æ¨‚åç¨±: <input type="text" id="musicName" value="song-1"></label><br>
                    <label>æˆ¿é–“å¯¬åº¦: <input type="number" id="roomWidth" value="8" min="1" max="24"></label><br>
                    <label>æˆ¿é–“é«˜åº¦: <input type="number" id="roomHeight" value="8" min="1" max="24"></label><br>
                    <small style="color: var(--secondary-color);">â€» æˆ¿é–“å°ºå¯¸æœ€å¤§ç‚º 24Ã—24</small>
                    <small style="color: var(--secondary-color); display: block; margin-top: 5px;">ğŸ’¡ ä¿®æ”¹æˆ¿é–“å°ºå¯¸æœƒè‡ªå‹•è¨ˆç®—ç²¾éˆå°ºå¯¸</small>
                </div>
            </div>
        </form>
          <div class="section tab-section" id="data">
            <h2>çµæœ</h2>
            <div id="preview-result-container" style="display: none;"></div>
            <button id="preview-result-btn" style="margin-top:10px; display:none;">é è¦½è½‰æ›çµæœ</button>
            <hr>
            <textarea id="output" style="display: none;"></textarea>
            <button id="download-btn" style="display: none;">ä¸‹è¼‰æª”æ¡ˆ</button>
            <button type="button" id="generate-room-btn">ç”Ÿæˆæˆ¿é–“æ•¸æ“š</button>
            <button type="button" id="generate-picture-btn">ç”Ÿæˆæ’åœ–æ•¸æ“š</button>
            <button type="button" id="clearButton">é‡ç½®æ•¸æ“š</button>
        </div>
          <div class="section tab-section" id="merge-rooms">
            <h2>æˆ¿é–“åˆä½µå·¥å…·</h2>
            <form id="merge-form">
                <label for="merge-files">ä¸Šå‚³å¤šå€‹æˆ¿é–“æ•¸æ“š: </label>
                <input type="file" id="merge-files" name="merge-files" accept=".json,.mosiroom" multiple required>
                <ul id="file-list"></ul>
                <button type="submit">åˆä½µæˆ¿é–“æ•¸æ“š</button>
            </form>
            <textarea id="merge-output" style="display: none;"></textarea>
            <button id="merge-download-btn" style="display: none;">ä¸‹è¼‰åˆä½µå¾Œæ•¸æ“š</button>
        </div>
          <div class="section tab-section" id="merge-sprite-section">
            <h2>ç²¾éˆåˆä½µå·¥å…·</h2>
            <label for="mergeSpriteInput">ä¸Šå‚³å¤šå€‹ç²¾éˆæ•¸æ“š: </label>
            <input type="file" id="mergeSpriteInput" accept=".mosisprite,.json" multiple style="margin-bottom:10px;">
            <ul id="mergeSpriteFileList"></ul>
            <div id="mergeSpriteAttrSelect" style="display:none; margin:10px 0;"></div>
            <button id="mergeSpriteBtn" style="margin-top:10px; display:none;">åˆä½µç²¾éˆ</button>
            <textarea id="mergeSpriteOutput" style="display: none;"></textarea>
            <button id="mergeSpriteDownloadBtn" style="display: none;">ä¸‹è¼‰åˆä½µå¾Œæ•¸æ“š</button>
        </div>
          <div class="section tab-section" id="merge-room-section">
            <h2>æˆ¿é–“åˆä½µå–®è‰²ç²¾éˆå·¥å…·</h2>
            <label for="mergeRoomInput">ä¸Šå‚³ä¸€å€‹æˆ¿é–“æ•¸æ“š: </label>
            <div style="margin-top:10px;">
                <textarea id="mergeRoomTextImport" placeholder="è²¼ä¸Šæˆ¿é–“æ•¸æ“š..." style="width:90%;height:80px;margin-bottom:4px;"></textarea><br>
                <button id="mergeRoomTextImportBtn" style="margin: 0.5em 0;" type="button">å¾æ–‡å­—åŒ¯å…¥æˆ¿é–“æ•¸æ“š</button>
            </div>
            <input type="file" id="mergeRoomInput" accept=".mosiroom,.json" style="margin-bottom:10px;">
            <hr>
            <button id="mergeRoomBtn" style="margin-top:10px; display:none;">åˆä½µæˆ¿é–“</button>
            <textarea id="mergeRoomOutput" style="display: none;"></textarea>
            <button id="mergeRoomDownloadBtn" style="display: none;">ä¸‹è¼‰åˆä½µå¾Œæ•¸æ“š</button>
        </div>
        <div class="section tab-section" id="merge-world-section">
          <h2>ä¸–ç•Œç´šåˆä½µå·¥å…·</h2>
          <label for="mergeWorldInput">ä¸Šå‚³ä¸€å€‹ä¸–ç•Œæ•¸æ“š: </label>
          <div style="margin-top:10px;">
              <textarea id="mergeWorldTextImport" placeholder="è²¼ä¸Šä¸–ç•Œæ•¸æ“š..." style="width:90%;height:80px;margin-bottom:4px;"></textarea><br>
              <button id="mergeWorldTextImportBtn" style="margin: 0.5em 0;" type="button">å¾æ–‡å­—åŒ¯å…¥ä¸–ç•Œæ•¸æ“š</button>
          </div>
          <input type="file" id="mergeWorldInput" accept=".mosi,.json" style="margin-bottom:10px;">
            <hr>
            <button id="mergeWorldBtn" style="margin-top:10px; display:none;">åˆä½µä¸–ç•Œ</button>
            <textarea id="mergeWorldOutput" style="display: none;"></textarea>
            <button id="mergeWorldDownloadBtn" style="display: none;">ä¸‹è¼‰åˆä½µå¾Œæ•¸æ“š</button>
        </div>
        <div class="section tab-section" id="merge-picture-section">
          <h2>æ’åœ–åˆä½µå·¥å…·</h2>
          <label for="mergePictureInput">ä¸Šå‚³å¤šå€‹æ’åœ–æ•¸æ“š: </label>
          <input type="file" id="mergePictureInput" accept=".mosigraphic,.json" multiple style="margin-bottom:10px;">
          <ul id="mergePictureFileList"></ul>
          <div id="mergePictureAttrSelect" style="display:none; margin:10px 0;"></div>
            <button id="mergePictureBtn" style="margin-top:10px; display:none;">åˆä½µæ’åœ–</button>
            <textarea id="mergePictureOutput" style="display: none;"></textarea>
            <button id="mergePictureDownloadBtn" style="display: none;">ä¸‹è¼‰åˆä½µå¾Œæ•¸æ“š</button>
        </div>
        <div class="section tab-section" id="room-to-picture-section">
          <h2>æˆ¿é–“è½‰æ’åœ–å·¥å…·</h2>
          <label for="roomToPictureInput">ä¸Šå‚³ä¸€å€‹æˆ¿é–“æ•¸æ“š: </label>
          <div style="margin-top:10px;">
              <textarea id="roomToPictureTextImport" placeholder="è²¼ä¸Šæˆ¿é–“æ•¸æ“š..." style="width:90%;height:80px;margin-bottom:4px;"></textarea><br>
              <button id="roomToPictureTextImportBtn" style="margin: 0.5em 0;" type="button">å¾æ–‡å­—åŒ¯å…¥æˆ¿é–“æ•¸æ“š</button>
          </div>
          <input type="file" id="roomToPictureInput" accept=".mosiroom,.json" style="margin-bottom:10px;">
          <hr>
            <button id="roomToPicturePictureBtn" style="margin-top:10px; display:none;">è½‰æ›æˆ¿é–“</button>
            <textarea id="roomToPictureOutput" style="display: none;"></textarea>
            <button id="roomToPictureDownloadBtn" style="display: none;">ä¸‹è¼‰è½‰æ›å¾Œæ•¸æ“š</button>
        </div>
      <div class="section tab-section" id="textbox-skin-section">
          <h2>å°è©±æ¡†çš®è†šè½‰æ›å·¥å…·</h2>
          <div>
            <label style="display:block; margin-bottom:0.5em;">é¸æ“‡æˆ¿é–“æª”æ¡ˆï¼š</label>
            <textarea id="textboxSkinRoomTextImport" placeholder="è²¼ä¸Šæˆ¿é–“æ•¸æ“š..." style="width:90%;height:80px;margin-bottom:4px;"></textarea><br>
            <button id="textboxSkinRoomTextImportBtn" style="margin: 0.5em 0;" type="button">å¾æ–‡å­—åŒ¯å…¥æˆ¿é–“æ•¸æ“š</button>
            <input type="file" id="roomFile" accept=".mosiroom,application/json">
          </div>
          <div style="margin-top: 1em;">
            <label style="display:block; margin-bottom:0.5em;">é¸æ“‡ç²¾éˆæª”æ¡ˆï¼š</label>
            <textarea id="textboxSkinSpriteTextImport" placeholder="è²¼ä¸Šç²¾éˆæ•¸æ“š..." style="width:90%;height:80px;margin-bottom:4px;"></textarea><br>
            <button id="textboxSkinSpriteTextImportBtn" style="margin: 0.5em 0;" type="button">å¾æ–‡å­—åŒ¯å…¥ç²¾éˆæ•¸æ“š</button>
            <input type="file" id="spriteFile" accept=".mosisprite,application/json">
          </div>
          <hr>
          <button id="convertTextboxSkinBtn" style="margin-bottom:1em;">è½‰æ›å°è©±æ¡†çš®è†š</button>
          <textarea id="textboxSkinOutput" style="display: none;"></textarea>
          <button id="textboxSkinDownloadBtn" style="display: none;">ä¸‹è¼‰è½‰æ›å¾Œæ•¸æ“š</button>
          <div id="textboxSkinResult"></div>
        </div>
        </div>
      </div>
    </div>

    <script>
        let currentImages = []; // æ”¯æ´å¤šåœ–
        let batchMode = false;
        let allImagesLoaded = false;
        let batchResults = [];
        let userHasManualInput = false; // <--- æ–°å¢ï¼šç”¨æˆ¶æ˜¯å¦æ‰‹å‹•è¼¸å…¥éå°ºå¯¸
        // ===== palette ç›¸é—œ =====
        let currentPalette = null; // [[r,g,b], ...]
        let paletteName = "";
        // ========== æ–°å¢ï¼šå…¨åŸŸ tab ç‹€æ…‹åŒæ­¥è®Šæ•¸ ==========
        let currentTabId = 'upload-img';
        // === æ–°é è¦½åˆ‡æ›èˆ‡æŒ‰éˆ•æ§åˆ¶ ===
        let currentPreviewIndex = 0;
        let showingCanvas = false; // å¤šè‰²æ¨¡å¼ä¸‹ true=canvas, false=img

        const uploadForm = document.getElementById("upload-form");
        const generateForm = document.getElementById("generate-form");
        const preview = document.getElementById("preview-img");
        const output = document.getElementById("output");
        const downloadBtn = document.getElementById("download-btn");
        const mergeFilesInput = document.getElementById("merge-files");
        const fileList = document.getElementById("file-list");
        const imageInfo = document.getElementById("image-info");
        const imageSize = document.getElementById("image-size");
        const suggestions = document.getElementById("suggestions");

        // åˆå§‹åŒ–è‡ªå‹•è¨ˆç®—åŠŸèƒ½
        setupAutoCalculation();

        // åœ–ç‰‡è¼‰å…¥è™•ç†
        uploadForm.addEventListener("submit", async (e) => {
            e.preventDefault();
            const fileInput = document.getElementById('file');
            const files = Array.from(fileInput.files);
            if (!files.length) {
                showMessage('è«‹é¸æ“‡åœ–ç‰‡æª”æ¡ˆ', 'error');
                return;
            }
            // æ–°å¢ï¼šæª¢æŸ¥æ¯å€‹æª”æ¡ˆå¤§å°
            const MAX_SIZE = 5 * 1024 * 1024; // 5MB
            for (const file of files) {
                if (file.size > MAX_SIZE) {
                    showMessage(`æª”æ¡ˆ ${file.name} è¶…é 5MBï¼Œè«‹é¸æ“‡è¼ƒå°çš„åœ–ç‰‡`, 'error');
                    return;
                }
            }
            currentImages = [];
            batchMode = files.length > 1;
            allImagesLoaded = false;
            userHasManualInput = false; // <--- æ–°å¢ï¼šé‡æ–°ä¸Šå‚³åœ–ç‰‡æ™‚é‡è¨­
            // ç¦ç”¨ç”ŸæˆæŒ‰éˆ•ç›´åˆ°å…¨éƒ¨è¼‰å…¥
            disableGenerateButtons();
            // é è¦½ç¬¬ä¸€å¼µï¼ˆç”¨æ–¼åˆå§‹åŒ– UIï¼‰
            const firstFile = files[0];
            
            // æ‰¹é‡æ¨¡å¼ä¸‹é å…ˆè¼‰å…¥æ‰€æœ‰åœ–ç‰‡
            if (batchMode) {
                let loaded = 0;
                currentImages = new Array(files.length);
                files.forEach((file, idx) => {
                    const img = new Image();
                    img.onload = function() {
                        currentImages[idx] = processImageToCanvas(img, file.name, idx);
                        loaded++;
                        if (loaded === files.length) {
                            handleImageLoadComplete(true);
                        }
                    };
                    img.onerror = function() {
                        resetAutoPaletteButton();
                        showMessage(`ç¬¬${idx+1}å¼µåœ–ç‰‡è¼‰å…¥å¤±æ•—`, 'error');
                    };
                    img.src = URL.createObjectURL(file);
                });
            } else {
                // å–®åœ–æ¨¡å¼
                const img = new Image();
                img.onload = function() {
                    currentImages = [processImageToCanvas(img, firstFile.name, 0)];
                    handleImageLoadComplete(false);
                };
                img.onerror = function() {
                    resetAutoPaletteButton();
                    showMessage('åœ–ç‰‡è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ ¼å¼', 'error');
                };
                img.src = URL.createObjectURL(firstFile);
            }
        });

        // ç”Ÿæˆæ•¸æ“šè™•ç†
        const generateRoomBtn = document.getElementById("generate-room-btn");
        const generatePictureBtn = document.getElementById("generate-picture-btn");

        generateRoomBtn.onclick = function(e) {
            e.preventDefault();
            generateMainData('room');
        };
        generatePictureBtn.onclick = function(e) {
            e.preventDefault();
            generateMainData('picture');
        };

        function generateMainData(type) {
            if (batchMode) {
                if (!currentImages.length || !allImagesLoaded) {
                    showMessage('è«‹å…ˆè¼‰å…¥æ‰€æœ‰åœ–ç‰‡', 'error');
                    return;
                }
                // å–å¾—è¨­å®š
                const data = {
                    spriteName: document.getElementById("spriteName").value,
                    spriteWidth: parseInt(document.getElementById("spriteWidth").value),
                    spriteHeight: parseInt(document.getElementById("spriteHeight").value),
                    isAvatar: document.getElementById("isAvatar").checked,
                    isWall: document.getElementById("isWall").checked,
                    isItem: document.getElementById("isItem").checked,
                    isTransparent: document.getElementById("isTransparent").checked,
                    colorIndex: parseInt(document.getElementById("colorIndex").value),
                    roomName: document.getElementById("roomName").value,
                    paletteName: paletteName || document.getElementById("paletteName").value,
                    musicName: document.getElementById("musicName").value,
                    roomWidth: parseInt(document.getElementById("roomWidth").value),
                    roomHeight: parseInt(document.getElementById("roomHeight").value)
                };
                // é©—è­‰
                if (data.spriteWidth <= 0 || data.spriteHeight <= 0) {
                    showMessage('ç²¾éˆå°ºå¯¸å¿…é ˆå¤§æ–¼0', 'error');
                    return;
                }
                if (data.roomWidth <= 0 || data.roomHeight <= 0) {
                    showMessage('æˆ¿é–“å°ºå¯¸å¿…é ˆå¤§æ–¼0', 'error');
                    return;
                }
                if (data.spriteWidth > 24 || data.spriteHeight > 24) {
                    showMessage('ç²¾éˆå°ºå¯¸ä¸èƒ½è¶…é24ï¼ˆMosiå¼•æ“é™åˆ¶ï¼‰', 'error');
                    return;
                }
                if (data.roomWidth > 24 || data.roomHeight > 24) {
                    showMessage('æˆ¿é–“å°ºå¯¸ä¸èƒ½è¶…é24ï¼ˆMosiå¼•æ“é™åˆ¶ï¼‰', 'error');
                    return;
                }
                batchResults = [];
                let failCount = 0;
                for (let i = 0; i < currentImages.length; i++) {
                    try {
                        // å–å¾—æ¯å¼µåœ–çš„ spriteName/colorIndex
                        const dataPerImg = {
                            ...data,
                            spriteName: currentImages[i].spriteName || data.spriteName,
                            colorIndex: currentImages[i].colorIndex || data.colorIndex
                        };

                        let resultData;
                        console.log(`è™•ç†ç¬¬${i+1}å¼µåœ–ç‰‡:`, {
                          hasPalette: !!currentPalette,
                          hasQuantized: !!currentImages[i].quantized,
                          type: type,
                          imageData: currentImages[i]
                        });
                        if (currentPalette && currentImages[i].quantized) {
                          // å¤šè‰²æ¨¡å¼
                          console.log('ä½¿ç”¨å¤šè‰²æ¨¡å¼è™•ç†');
                          try {
                            if (type === 'picture') {
                              resultData = processQuantizedToPictureData(currentImages[i], dataPerImg, currentPalette);
                            } else {
                              resultData = processQuantizedToRoomData(currentImages[i], dataPerImg, currentPalette);
                            }

                          } catch (error) {
                            console.error('å¤šè‰²æ¨¡å¼è™•ç†å¤±æ•—:', error);
                            throw error;
                          }
          
                        } else {
                          // å–®è‰²æ¨¡å¼
                          console.log('ä½¿ç”¨å–®è‰²æ¨¡å¼è™•ç†');
                          try {
                            if (type === 'picture') {
                              resultData = processImageToPictureData(currentImages[i], dataPerImg);
                            } else {
                              resultData = processImageToRoomData(currentImages[i], dataPerImg);
                            }

                          } catch (error) {
                            console.error('å–®è‰²æ¨¡å¼è™•ç†å¤±æ•—:', error);
                            throw error;
                          }
          
                        }
                        batchResults.push({
                            data: resultData,
                            fileName: dataPerImg.spriteName || data.roomName
                        });
                    } catch (error) {
                        showMessage(`ç¬¬${i+1}å¼µåœ–ç‰‡è™•ç†å¤±æ•—: ${error.message}`, 'error');
                        failCount++;
                    }
                }
                if (batchResults.length === 0) {
                    showMessage('æ‰€æœ‰åœ–ç‰‡è™•ç†éƒ½å¤±æ•—ï¼Œç„¡å¯ä¸‹è¼‰æ•¸æ“š', 'error');
                    return;
                }
                // éš±è—æ–‡å­—æ¡†ï¼Œé¡¯ç¤ºä¸€éµä¸‹è¼‰
                output.style.display = "none";
                downloadBtn.style.display = "none";
                // å…ˆç§»é™¤èˆŠçš„ batch-download-btn
                let oldBatchBtn = document.getElementById('batch-download-btn');
                if (oldBatchBtn) oldBatchBtn.remove();
                // æ–°å»ºä¸€å€‹æŒ‰éˆ•
                let batchBtn = document.createElement('button');
                batchBtn.id = 'batch-download-btn';
                batchBtn.textContent = 'ä¸€éµä¸‹è¼‰æ‰€æœ‰æª”æ¡ˆ';
                batchBtn.style.margin = '1em';
                downloadBtn.parentNode.insertBefore(batchBtn, downloadBtn.nextSibling);
                batchBtn.onclick = function() {
        
                    if (!batchResults.length) {
                        showMessage('æ²’æœ‰å¯ä¸‹è¼‰çš„æ•¸æ“š', 'error');
                        return;
                    }
                    batchResults.forEach((r, idx) => {
                        let ext = ".json";
                        let mimeType = "application/json";
                        let minified = false;
                        if (r.data && r.data.type === "picture") { 
                            ext = ".mosigraphic"; 
                            mimeType = "application/octet-stream";
                            minified = true; 
                        }
                        else if (r.data && r.data.frameList) { 
                            ext = ".mosisprite"; 
                            mimeType = "application/octet-stream";
                            minified = true; 
                        }
                        else if (r.data && (r.data.roomName || r.data.name) && r.data.tileList) { 
                            ext = ".mosiroom"; 
                            mimeType = "application/octet-stream";
                            minified = true; 
                        }
                        else if (r.data && r.data.roomList) { 
                            ext = ".mosi"; 
                            mimeType = "application/octet-stream";
                            minified = true; 
                        }
                        let content = minified ? JSON.stringify(r.data) : JSON.stringify(r.data, null, 4);
                        const blob = new Blob([content], { type: mimeType });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement("a");
                        a.href = url;
                        a.download = `${r.fileName}${ext}`;
                        a.click();
                        URL.revokeObjectURL(url);
                    });
                };
                showMessage('æ‰¹é‡æ•¸æ“šç”ŸæˆæˆåŠŸï¼', 'success');
                return;
            }
            if (!currentImages.length || !allImagesLoaded) {
                showMessage('è«‹å…ˆè¼‰å…¥åœ–ç‰‡', 'error');
                return;
            }
            
            try {
                // ç²å–è¨­å®šå€¼
                const data = {
                    spriteName: document.getElementById("spriteName").value,
                    spriteWidth: parseInt(document.getElementById("spriteWidth").value),
                    spriteHeight: parseInt(document.getElementById("spriteHeight").value),
                    isAvatar: document.getElementById("isAvatar").checked,
                    isWall: document.getElementById("isWall").checked,
                    isItem: document.getElementById("isItem").checked,
                    isTransparent: document.getElementById("isTransparent").checked,
                    colorIndex: parseInt(document.getElementById("colorIndex").value),
                    roomName: document.getElementById("roomName").value,
                    paletteName: paletteName || document.getElementById("paletteName").value,
                    musicName: document.getElementById("musicName").value,
                    roomWidth: parseInt(document.getElementById("roomWidth").value),
                    roomHeight: parseInt(document.getElementById("roomHeight").value)
                };
                let resultData;
                if (currentPalette && currentImages[0].quantized) {
                  // å¤šè‰²æ¨¡å¼
                  if (type === 'picture') {
                    resultData = processQuantizedToPictureData(currentImages[0], data, currentPalette);
                  } else {
                    resultData = processQuantizedToRoomData(currentImages[0], data, currentPalette);
                  }
  
                } else {
                  // å–®è‰²æ¨¡å¼
                  if (type === 'picture') {
                    resultData = processImageToPictureData(currentImages[0], data);
                  } else {
                    resultData = processImageToRoomData(currentImages[0], data);
                  }
  
                }
                output.value = (resultData && (resultData.frameList || resultData.tileList || resultData.roomList))
                    ? JSON.stringify(resultData)
                    : JSON.stringify(resultData, null, 4);
                output.style.display = "block";
                downloadBtn.style.display = "block";
                
                showMessage('æ•¸æ“šç”ŸæˆæˆåŠŸï¼', 'success');
                
            } catch (error) {
                console.error('æ•¸æ“šç”ŸæˆéŒ¯èª¤:', error);
                showMessage('æ•¸æ“šç”Ÿæˆæ™‚ç™¼ç”ŸéŒ¯èª¤: ' + error.message, 'error');
            }
        }

        // åœ–ç‰‡è™•ç†å‡½æ•¸ï¼ˆå–®è‰²æ¨¡å¼ï¼‰
        function processImageToRoomData(image, data) {
            const { width: imgWidth, height: imgHeight, context } = image;
            const { spriteWidth, spriteHeight, roomWidth, roomHeight } = data;
            
            // è¨ˆç®—éœ€è¦çš„åœ–ç‰‡å°ºå¯¸
            const requiredWidth = roomWidth * spriteWidth;
            const requiredHeight = roomHeight * spriteHeight;
            
            // æª¢æŸ¥æ˜¯å¦éœ€è¦ç¸®æ”¾
            let processedCanvas = image.canvas;
            let processedContext = image.context;
            let scale = 1;
            
            if (imgWidth !== requiredWidth || imgHeight !== requiredHeight) {
                // å‰µå»ºæ–°çš„ Canvas é€²è¡Œç¸®æ”¾
                const scaledCanvas = document.createElement('canvas');
                const scaledContext = scaledCanvas.getContext('2d');
                
                scaledCanvas.width = requiredWidth;
                scaledCanvas.height = requiredHeight;
                
                // ä½¿ç”¨ nearest-neighbor ç¸®æ”¾ä»¥ä¿æŒåƒç´ é¢¨æ ¼
                scaledContext.imageSmoothingEnabled = false;
                scaledContext.drawImage(image.canvas, 0, 0, requiredWidth, requiredHeight);
                
                processedCanvas = scaledCanvas;
                processedContext = scaledContext;
                scale = requiredWidth / imgWidth;
            }
            
            // è¨ˆç®—æ¯è¡Œçš„ç²¾éˆæ•¸é‡
            const spritesPerRow = Math.floor(processedCanvas.width / spriteWidth);
            const totalSprites = spritesPerRow * Math.floor(processedCanvas.height / spriteHeight);
            
            // æª¢æŸ¥æˆ¿é–“å°ºå¯¸æ˜¯å¦åˆç†
            if (roomWidth * roomHeight > totalSprites) {
                throw new Error(`æˆ¿é–“å°ºå¯¸éå¤§ï¼Œåœ–ç‰‡åªèƒ½æä¾› ${totalSprites} å€‹ç²¾éˆï¼Œä½†æˆ¿é–“éœ€è¦ ${roomWidth * roomHeight} å€‹`);
            }
            
            const spriteData = [];
            const tileList = [];
            const uniqueSprites = new Map();
            let validSpriteCount = 0;

            // è™•ç†æ¯å€‹ç²¾éˆ
            for (let spriteIndex = 0; spriteIndex < roomWidth * roomHeight; spriteIndex++) {
                const x = (spriteIndex % spritesPerRow) * spriteWidth;
                const y = Math.floor(spriteIndex / spritesPerRow) * spriteHeight;
                
                // ç²å–ç²¾éˆå€åŸŸçš„åƒç´ æ•¸æ“š
                const imageData = processedContext.getImageData(x, y, spriteWidth, spriteHeight);
                const pixels = imageData.data;
                
                // è½‰æ›ç‚ºäºŒå€¼æ•¸æ“š
                const binaryData = [];
                for (let i = 0; i < pixels.length; i += 4) {
                    const alpha = pixels[i + 3];
                    if (alpha < 128) {
                        binaryData.push(0); // é€æ˜ç›´æ¥ç•¶ 0
                    } else {
                        const gray = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
                        binaryData.push(gray < 128 ? 1 : 0);
                    }
                }
                
                // æª¢æŸ¥æ˜¯å¦ç‚ºç©ºç™½ç²¾éˆ
                if (binaryData.some(pixel => pixel === 1)) {
                    const binaryKey = binaryData.join(',');
                    
                    if (!uniqueSprites.has(binaryKey)) {
                        // æ–°çš„ç²¾éˆ
                        validSpriteCount++;
                        const spriteName = `${data.spriteName}-${validSpriteCount.toString().padStart(2, '0')}`;
                        uniqueSprites.set(binaryKey, spriteName);
                        
                        spriteData.push({
                            name: spriteName,
                            isAvatar: data.isAvatar,
                            isWall: data.isWall,
                            isItem: data.isItem,
                            isTransparent: data.isTransparent,
                            colorIndex: data.colorIndex,
                            width: spriteWidth,
                            height: spriteHeight,
                            frameList: [binaryData],
                            scriptList: {"on-push": "", "on-message": ""}
                        });
                    }
                    
                    // æ·»åŠ åˆ°ç“·ç£šåˆ—è¡¨
                    tileList.push({
                        spriteName: uniqueSprites.get(binaryKey),
                        x: spriteIndex % roomWidth,
                        y: Math.floor(spriteIndex / roomWidth)
                    });
                }
            }
            
            // ç”Ÿæˆæˆ¿é–“æ•¸æ“š
            return {
                name: data.roomName,
                paletteName: data.paletteName,
                musicName: data.musicName,
                tileList: tileList,
                scriptList: {"on-enter": "", "on-exit": ""},
                width: roomWidth,
                height: roomHeight,
                spriteWidth: spriteWidth,
                spriteHeight: spriteHeight,
                spriteList: spriteData
            };
        }

        // ä¸‹è¼‰æŒ‰éˆ•è™•ç†
        downloadBtn.addEventListener("click", () => {
            const roomName = document.getElementById("roomName").value || "room_data";
            let ext = ".json";
            let mimeType = "application/json";
            let minified = false;
            let obj = null;
            try {
                obj = JSON.parse(output.value);
                if (obj && obj.type === "picture") { 
                    ext = ".mosigraphic"; 
                    mimeType = "application/octet-stream";
                    minified = true; 
                }
                else if (obj && obj.frameList) { 
                    ext = ".mosisprite"; 
                    mimeType = "application/octet-stream";
                    minified = true; 
                }
                else if (obj && (obj.roomName || obj.name) && obj.tileList) { 
                    ext = ".mosiroom"; 
                    mimeType = "application/octet-stream";
                    minified = true; 
                }
                else if (obj && obj.roomList) { 
                    ext = ".mosi"; 
                    mimeType = "application/octet-stream";
                    minified = true; 
                }
            } catch {}
            let content = "";
            if (minified && obj) content = JSON.stringify(obj);
            else content = output.value;
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${roomName}${ext}`;
            a.click();
            URL.revokeObjectURL(url);
        });

        // æ¸…é™¤æŒ‰éˆ•è™•ç†
        document.getElementById("clearButton").addEventListener("click", function () {
            // æ¸…ç©ºåœ–ç‰‡é è¦½
            const fileInput = document.getElementById("file");
            const preview = document.getElementById("preview-img");
            fileInput.value = "";
            preview.src = "static/rest.png";
            
            // æ¸…ç©ºæ•¸æ“šè¼¸å‡º
            const output = document.getElementById("output");
            output.value = "";
            output.style.display = "none";
            
            // éš±è—ä¸‹è¼‰æŒ‰éˆ•
            const downloadBtn = document.getElementById("download-btn");
            downloadBtn.style.display = "none";
            
            // éš±è—åœ–ç‰‡è³‡è¨Š
            imageInfo.style.display = "none";
            
            // é‡ç½®åœ–ç‰‡æ•¸æ“š
            currentImages = [];
            batchMode = false;
            allImagesLoaded = false;
            const batchBtn = document.getElementById('batch-download-btn');
            if (batchBtn) batchBtn.style.display = 'none';
            
            // ===== æ–°å¢ï¼šé‡ç½®èª¿è‰²ç›¤ç›¸é—œæ•¸æ“š =====
            currentPalette = null;
            paletteName = "";
            showPalettePreview([]);
            updateColorIndexAndPaletteNameUI();
            updateCurrentPaletteStatus();
            renderBatchSpriteSettings();
            updatePreview();
            
            // éš±è—é¡è‰²é¸æ“‡ç•Œé¢
            const colorSelectionSection = document.getElementById('color-selection-section');
            if (colorSelectionSection) colorSelectionSection.style.display = 'none';
            
            // éš±è—è‡ªå‹•èª¿è‰²ç›¤çµæœå’Œä¸‹è¼‰æŒ‰éˆ•
            const autoPaletteResult = document.getElementById('autoPaletteResult');
            const autoPaletteDownloadBtn = document.getElementById('autoPaletteDownloadBtn');
            if (autoPaletteResult) autoPaletteResult.style.display = 'none';
            if (autoPaletteDownloadBtn) autoPaletteDownloadBtn.style.display = 'none';
            
            // æ¸…ç©ºæ–‡å­—åŒ¯å…¥èª¿è‰²ç›¤è¼¸å…¥æ¡†
            const paletteTextImport = document.getElementById('paletteTextImport');
            if (paletteTextImport) paletteTextImport.value = '';
            
            // æ¸…ç©ºèª¿è‰²ç›¤æª”æ¡ˆä¸Šå‚³
            const paletteFile = document.getElementById('paletteFile');
            if (paletteFile) paletteFile.value = '';
            
            // é‡ç½®è‡ªå‹•èª¿è‰²ç›¤åç¨±è¼¸å…¥æ¡†
            const autoPaletteName = document.getElementById('autoPaletteName');
            if (autoPaletteName) autoPaletteName.value = 'æ™ºèƒ½èª¿è‰²ç›¤';
            
            // é‡ç½®è‡ªå‹•åµæ¸¬æŒ‰éˆ•ç‹€æ…‹
            const autoPaletteBtn = document.getElementById('autoPaletteBtn');
            if (autoPaletteBtn) {
              autoPaletteBtn.textContent = 'åµæ¸¬åœ–ç‰‡é¡è‰²';
              autoPaletteBtn.disabled = false;
            }
            
            showMessage('æ•¸æ“šå·²æ¸…é™¤ï¼', 'success');
            batchResults = [];
            showAutoPaletteSection(false);
        });

        // æˆ¿é–“åˆä½µåŠŸèƒ½
        document.getElementById("merge-form").addEventListener("submit", async (e) => {
            e.preventDefault();

            const files = document.getElementById("merge-files").files;
            if (files.length < 2) {
                showMessage("è«‹ä¸Šå‚³è‡³å°‘å…©å€‹æˆ¿é–“æ•¸æ“šæª”æ¡ˆï¼", 'error');
                return;
            }

            try {
                let mergedData = null;

                for (const file of files) {
                    const text = await file.text();
                    const jsonData = JSON.parse(text);

                    if (!mergedData) {
                        mergedData = { ...jsonData };
                        mergedData.spriteList = [...jsonData.spriteList];
                        mergedData.tileList = [...jsonData.tileList];
                    } else {
                        // æª¢æŸ¥åŸºç¤è¨­å®šæ˜¯å¦ä¸€è‡´
                        if (
                            jsonData.roomName !== mergedData.roomName ||
                            jsonData.paletteName !== mergedData.paletteName ||
                            jsonData.musicName !== mergedData.musicName ||
                            jsonData.roomWidth !== mergedData.roomWidth ||
                            jsonData.roomHeight !== mergedData.roomHeight
                        ) {
                            showMessage(`æª”æ¡ˆ ${file.name} çš„åŸºç¤è¨­å®šèˆ‡å…¶ä»–æˆ¿é–“ä¸ä¸€è‡´ï¼Œç„¡æ³•åˆä½µï¼`, 'error');
                            return;
                        }

                        // åˆä½µç²¾éˆæ•¸æ“š
                        jsonData.spriteList.forEach(sprite => {
                            if (!mergedData.spriteList.some(s => JSON.stringify(s) === JSON.stringify(sprite))) {
                                mergedData.spriteList.push(sprite);
                            }
                        });

                        // åˆä½µç“·ç£šæ•¸æ“š
                        mergedData.tileList.push(...jsonData.tileList);
                    }
                }

                // é¡¯ç¤ºåˆä½µå¾Œæ•¸æ“š
                const mergeOutput = document.getElementById("merge-output");
                mergeOutput.value = (mergedData && (mergedData.frameList || mergedData.tileList || mergedData.roomList))
                    ? JSON.stringify(mergedData)
                    : JSON.stringify(mergedData, null, 4);
                mergeOutput.style.display = "block";

                // é¡¯ç¤ºä¸‹è¼‰æŒ‰éˆ•
                const mergeDownloadBtn = document.getElementById("merge-download-btn");
                mergeDownloadBtn.style.display = "block";

                showMessage('æˆ¿é–“åˆä½µæˆåŠŸï¼', 'success');

            } catch (error) {
                console.error('åˆä½µéŒ¯èª¤:', error);
                showMessage('åˆä½µæ™‚ç™¼ç”ŸéŒ¯èª¤: ' + error.message, 'error');
            }
        });

        // åˆä½µä¸‹è¼‰æŒ‰éˆ•
        document.getElementById("merge-download-btn").addEventListener("click", () => {
            const roomName = document.getElementById("roomName").value || "merged_room_data";
            const mergeOutput = document.getElementById("merge-output");
            let obj = null;
            let minified = false;
            let mimeType = "application/json";
            try {
                obj = JSON.parse(mergeOutput.value);
                if (obj && obj.frameList) { minified = true; mimeType = "application/octet-stream"; }
                else if (obj && (obj.roomName || obj.name) && obj.tileList) { minified = true; mimeType = "application/octet-stream"; }
                else if (obj && obj.roomList) { minified = true; mimeType = "application/octet-stream"; }
            } catch {}
            let content = (minified && obj) ? JSON.stringify(obj) : mergeOutput.value;
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${roomName}.mosiroom`;
            a.click();
            URL.revokeObjectURL(url);
        });

        // æª”æ¡ˆåˆ—è¡¨è™•ç†
        mergeFilesInput.addEventListener("change", () => {
            fileList.innerHTML = "";
            Array.from(mergeFilesInput.files).forEach((file, index) => {
                const listItem = document.createElement("li");
                listItem.innerHTML = `
                    <img src="static/file-icon.png" alt="File Icon"> ${file.name}
                `;
                listItem.draggable = true;
                listItem.dataset.index = index;
                fileList.appendChild(listItem);
            });

            // æ‹–æ›³åŠŸèƒ½
            let draggedItem = null;

            fileList.addEventListener("dragstart", (e) => {
                draggedItem = e.target;
                e.dataTransfer.effectAllowed = "move";
                fileList.classList.add("dragging");
            });

            fileList.addEventListener("dragover", (e) => {
                e.preventDefault();
                const target = e.target.closest("li");
                if (target && target !== draggedItem) {
                    target.classList.add("drag-hover");
                }
            });

            fileList.addEventListener("dragleave", (e) => {
                const target = e.target.closest("li");
                if (target) {
                    target.classList.remove("drag-hover");
                }
            });

            fileList.addEventListener("drop", (e) => {
                e.preventDefault();
                const target = e.target.closest("li");
                if (target && target !== draggedItem) {
                    fileList.insertBefore(draggedItem, target);
                }
                target.classList.remove("drag-hover");
            });

            fileList.addEventListener("dragend", () => {
                fileList.classList.remove("dragging");
                fileList.querySelectorAll("li").forEach((li) => li.classList.remove("drag-hover"));
            });
        });

        // é¡¯ç¤ºè¨Šæ¯å‡½æ•¸
        function showMessage(message, type) {
            // ç§»é™¤èˆŠçš„è¨Šæ¯
            const existingMessage = document.querySelector('.error, .success');
            if (existingMessage) {
                existingMessage.remove();
            }
            
            // å‰µå»ºæ–°è¨Šæ¯
            const messageDiv = document.createElement('div');
            messageDiv.className = type;
            messageDiv.textContent = message;
            
            // æ’å…¥åˆ°é é¢
            document.body.appendChild(messageDiv);
            
            // 3ç§’å¾Œè‡ªå‹•ç§»é™¤
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.remove();
                }
            }, 3000);
        }
        
        // è™•ç† file input çš„é¡¯ç¤ºæ–‡å­—
        function setupFileInputs() {
            const fileInputs = document.querySelectorAll('input[type="file"]');
            fileInputs.forEach(input => {
                // è¨­å®šåˆå§‹æ–‡å­—
                input.setAttribute('data-original-text', 'é¸æ“‡æª”æ¡ˆ');
                
                // ç›£è½æª”æ¡ˆé¸æ“‡äº‹ä»¶
                input.addEventListener('change', function() {
                    const files = this.files;
                    if (files.length > 0) {
                        // é¡¯ç¤ºé¸ä¸­çš„æª”æ¡ˆåç¨±
                        const fileNames = Array.from(files).map(file => file.name).join(', ');
                        this.setAttribute('data-original-text', fileNames);
                    } else {
                        // æ¢å¾©åŸå§‹æ–‡å­—
                        this.setAttribute('data-original-text', 'é¸æ“‡æª”æ¡ˆ');
                    }
                });
            });
        }

        // è¨ˆç®—å»ºè­°çš„ç²¾éˆå’Œæˆ¿é–“å°ºå¯¸çµ„åˆ
        function calculateSuggestions(width, height) {
            const suggestions = [];
            
            // å¸¸è¦‹çš„ç²¾éˆå°ºå¯¸ï¼ˆé™åˆ¶åœ¨24ä»¥å…§ï¼‰
            const commonSpriteSizes = [4, 8, 12, 16, 20, 24];
            
            // å¸¸è¦‹çš„æˆ¿é–“å°ºå¯¸ï¼ˆé™åˆ¶åœ¨24ä»¥å…§ï¼‰
            const commonRoomSizes = [5, 8, 10, 12, 15, 16, 20, 24];
            
            // æ–¹æ³•1ï¼šç›´æ¥æª¢æŸ¥ç²¾éˆå°ºå¯¸æ˜¯å¦èƒ½æ•´é™¤åœ–ç‰‡å°ºå¯¸
            for (const spriteSize of commonSpriteSizes) {
                if (width % spriteSize === 0 && height % spriteSize === 0) {
                    const roomWidth = width / spriteSize;
                    const roomHeight = height / spriteSize;
                    
                    // æª¢æŸ¥æˆ¿é–“å°ºå¯¸æ˜¯å¦åœ¨é™åˆ¶ç¯„åœå…§
                    if (roomWidth <= 24 && roomHeight <= 24) {
                        const score = calculateScore(roomWidth, roomHeight, spriteSize);
                        suggestions.push({
                            spriteWidth: spriteSize,
                            spriteHeight: spriteSize,
                            roomWidth: roomWidth,
                            roomHeight: roomHeight,
                            score: score,
                            description: `${roomWidth}Ã—${roomHeight} æˆ¿é–“ Ã— ${spriteSize}Ã—${spriteSize} ç²¾éˆ`,
                            scale: 1,
                            originalSize: `${width}Ã—${height}`
                        });
                    }
                }
            }
            
            // æ–¹æ³•2ï¼šå¦‚æœæ²’æœ‰æ‰¾åˆ°åˆé©çš„çµ„åˆï¼Œè¨ˆç®—ç¸®æ”¾æ¯”ä¾‹
            if (suggestions.length === 0) {
                const scaledSuggestions = calculateScaledSuggestions(width, height);
                suggestions.push(...scaledSuggestions);
            }
            
            // æŒ‰è©•åˆ†æ’åºï¼Œè©•åˆ†è¶Šé«˜è¶Šå„ªå…ˆ
            suggestions.sort((a, b) => b.score - a.score);
            
            // é™åˆ¶é¡¯ç¤ºæ•¸é‡
            return suggestions.slice(0, 10);
        }
        
        // è¨ˆç®—ç¸®æ”¾å¾Œçš„å»ºè­°çµ„åˆ
        function calculateScaledSuggestions(width, height) {
            const suggestions = [];
            const commonSpriteSizes = [4, 8, 12, 16, 20, 24];
            const commonRoomSizes = [5, 8, 10, 12, 15, 16, 20, 24];
            
            // å˜—è©¦ä¸åŒçš„ç¸®æ”¾æ¯”ä¾‹
            for (const roomWidth of commonRoomSizes) {
                for (const roomHeight of commonRoomSizes) {
                    for (const spriteSize of commonSpriteSizes) {
                        // è¨ˆç®—éœ€è¦çš„åœ–ç‰‡å°ºå¯¸
                        const requiredWidth = roomWidth * spriteSize;
                        const requiredHeight = roomHeight * spriteSize;
                        
                        // è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹
                        const scaleX = width / requiredWidth;
                        const scaleY = height / requiredHeight;
                        
                        // æª¢æŸ¥ç¸®æ”¾æ¯”ä¾‹æ˜¯å¦åˆç†ï¼ˆ0.1 åˆ° 10 ä¹‹é–“ï¼‰
                        if (scaleX >= 0.1 && scaleX <= 10 && scaleY >= 0.1 && scaleY <= 10) {
                            // ä½¿ç”¨è¼ƒå°çš„ç¸®æ”¾æ¯”ä¾‹ï¼ˆæ›´ä¿å®ˆï¼‰
                            const scale = Math.min(scaleX, scaleY);
                            
                            const score = calculateScore(roomWidth, roomHeight, spriteSize);
                            
                            // èª¿æ•´è©•åˆ†ï¼šç¸®æ”¾æ¯”ä¾‹è¶Šæ¥è¿‘1è¶Šå¥½
                            const scaleBonus = Math.max(0, 10 - Math.abs(scale - 1) * 5);
                            const finalScore = score + scaleBonus;
                            
                            suggestions.push({
                                spriteWidth: spriteSize,
                                spriteHeight: spriteSize,
                                roomWidth: roomWidth,
                                roomHeight: roomHeight,
                                score: finalScore,
                                description: `${roomWidth}Ã—${roomHeight} æˆ¿é–“ Ã— ${spriteSize}Ã—${spriteSize} ç²¾éˆ (ç¸®æ”¾ ${scale.toFixed(2)}x)`,
                                scale: scale,
                                originalSize: `${width}Ã—${height}`,
                                scaledSize: `${Math.round(requiredWidth * scale)}Ã—${Math.round(requiredHeight * scale)}`
                            });
                        }
                    }
                }
            }
            
            return suggestions;
        }
        
        // è¨ˆç®—å»ºè­°çš„è©•åˆ†
        function calculateScore(roomWidth, roomHeight, spriteSize) {
            let score = 0;
            
            // åå¥½é©ä¸­çš„æˆ¿é–“å°ºå¯¸ï¼ˆ8-20ä¹‹é–“ï¼Œä½†æœ€å¤§24ï¼‰
            if (roomWidth >= 8 && roomWidth <= 20) score += 10;
            if (roomHeight >= 8 && roomHeight <= 20) score += 10;
            
            // åå¥½é©ä¸­çš„ç²¾éˆå°ºå¯¸ï¼ˆ8-24ä¹‹é–“ï¼‰
            if (spriteSize >= 8 && spriteSize <= 24) score += 15;
            
            // åå¥½æ­£æ–¹å½¢æˆ¿é–“
            if (roomWidth === roomHeight) score += 5;
            
            // åå¥½è¼ƒå°çš„ç²¾éˆå°ºå¯¸ï¼ˆæ›´ç²¾ç´°ï¼Œä½†ä¸è¦å¤ªå°ï¼‰
            if (spriteSize >= 8 && spriteSize <= 16) score += 10;
            
            // åå¥½è¼ƒå°çš„æˆ¿é–“å°ºå¯¸ï¼ˆæ›´å¯¦ç”¨ï¼Œä½†ä¸è¦å¤ªå°ï¼‰
            if (roomWidth >= 8 && roomWidth <= 16) score += 5;
            if (roomHeight >= 8 && roomHeight <= 16) score += 5;
            
            // é¿å…æ¥µç«¯å€¼
            if (roomWidth < 5 || roomHeight < 5) score -= 10;
            if (spriteSize < 4) score -= 10;
            
            return score;
        }
        
        // é¡¯ç¤ºå»ºè­°åˆ—è¡¨
        function displaySuggestions(suggestions) {
            const suggestionsDiv = document.getElementById("suggestions");
            
            if (suggestions.length === 0) {
                suggestionsDiv.innerHTML = '<p style="color: var(--secondary-color);">ç„¡æ³•æ‰¾åˆ°åˆé©çš„çµ„åˆï¼Œè«‹æ‰‹å‹•èª¿æ•´å°ºå¯¸</p>';
                return;
            }
            
            let html = '<div style="margin-bottom: 10px;">é»æ“Šé¸æ“‡ï¼š</div>';
            
            suggestions.forEach((suggestion, index) => {
                const isRecommended = index === 0;
                const style = isRecommended ? 
                    'background: var(--bg-light); border: 2px solid var(--success-color);' : 
                    'background: var(--bg-color); border: 1px solid var(--bg-light);';
                
                // æ·»åŠ ç¸®æ”¾ä¿¡æ¯
                let scaleInfo = '';
                if (suggestion.scale !== 1) {
                    scaleInfo = `<div style="font-size: 0.8em; color: var(--success-color);">
                        ğŸ“ åŸåœ–: ${suggestion.originalSize} â†’ ç¸®æ”¾: ${suggestion.scale.toFixed(2)}x
                    </div>`;
                }
                
                html += `
                    <div class="suggestion-item" 
                         style="${style} padding: 8px; margin: 5px 0; border-radius: 4px; cursor: pointer;"
                         onclick="selectSuggestion(${suggestion.spriteWidth}, ${suggestion.spriteHeight}, ${suggestion.roomWidth}, ${suggestion.roomHeight})">
                        <div style="color: var(--main-color);">
                            ${isRecommended ? 'â­ ' : ''}${suggestion.description}
                        </div>
                        <div style="font-size: 0.9em; color: var(--secondary-color);">
                            è©•åˆ†: ${suggestion.score} | ç¸½ç²¾éˆæ•¸: ${suggestion.roomWidth * suggestion.roomHeight}
                        </div>
                        ${scaleInfo}
                    </div>
                `;
            });
            
            suggestionsDiv.innerHTML = html;
        }
        
        // é¸æ“‡å»ºè­°
        function selectSuggestion(spriteWidth, spriteHeight, roomWidth, roomHeight) {
            document.getElementById("spriteWidth").value = spriteWidth;
            document.getElementById("spriteHeight").value = spriteHeight;
            document.getElementById("roomWidth").value = roomWidth;
            document.getElementById("roomHeight").value = roomHeight;
            
            showMessage(`å·²é¸æ“‡: ${roomWidth}Ã—${roomHeight} æˆ¿é–“ Ã— ${spriteWidth}Ã—${spriteHeight} ç²¾éˆ`, 'success');
        }

        // è‡ªå‹•è¨ˆç®—åŠŸèƒ½
        function setupAutoCalculation() {
            const spriteWidthInput = document.getElementById("spriteWidth");
            const spriteHeightInput = document.getElementById("spriteHeight");
            const roomWidthInput = document.getElementById("roomWidth");
            const roomHeightInput = document.getElementById("roomHeight");

            // æ·»åŠ é˜²æŠ–åŠŸèƒ½
            let spriteTimeout, roomTimeout;

            // ç²¾éˆå°ºå¯¸è®Šæ›´æ™‚ï¼Œè‡ªå‹•è¨ˆç®—æˆ¿é–“å°ºå¯¸
            spriteWidthInput.addEventListener("input", () => {
                userHasManualInput = true; // <--- æ–°å¢ï¼šåµæ¸¬æ‰‹å‹•è¼¸å…¥
                clearTimeout(spriteTimeout);
                spriteTimeout = setTimeout(autoCalculateRoomSize, 300);
            });
            spriteHeightInput.addEventListener("input", () => {
                userHasManualInput = true;
                clearTimeout(spriteTimeout);
                spriteTimeout = setTimeout(autoCalculateRoomSize, 300);
            });

            // æˆ¿é–“å°ºå¯¸è®Šæ›´æ™‚ï¼Œè‡ªå‹•è¨ˆç®—ç²¾éˆå°ºå¯¸
            roomWidthInput.addEventListener("input", () => {
                userHasManualInput = true;
                clearTimeout(roomTimeout);
                roomTimeout = setTimeout(autoCalculateSpriteSize, 300);
            });
            roomHeightInput.addEventListener("input", () => {
                userHasManualInput = true;
                clearTimeout(roomTimeout);
                roomTimeout = setTimeout(autoCalculateSpriteSize, 300);
            });
        }

        // è‡ªå‹•è¨ˆç®—æˆ¿é–“å°ºå¯¸
        function autoCalculateRoomSize() {
            if (userHasManualInput) return; // <--- æ–°å¢ï¼šç”¨æˆ¶æ‰‹å‹•è¼¸å…¥å¾Œä¸å†è‡ªå‹•è¯å‹•
            if (!currentImages.length || !currentImages[0]) return;
            const spriteWidth = parseInt(document.getElementById("spriteWidth").value) || 0;
            const spriteHeight = parseInt(document.getElementById("spriteHeight").value) || 0;
            if (spriteWidth > 0 && spriteHeight > 0) {
                // è¨ˆç®—æˆ¿é–“å°ºå¯¸
                const roomWidth = Math.floor(currentImages[0].width / spriteWidth);
                const roomHeight = Math.floor(currentImages[0].height / spriteHeight);
                // æª¢æŸ¥æ˜¯å¦åœ¨é™åˆ¶ç¯„åœå…§
                if (roomWidth <= 24 && roomHeight <= 24 && roomWidth > 0 && roomHeight > 0) {
                    // æš«æ™‚ç§»é™¤äº‹ä»¶ç›£è½å™¨é¿å…å¾ªç’°
                    const roomWidthInput = document.getElementById("roomWidth");
                    const roomHeightInput = document.getElementById("roomHeight");
                    roomWidthInput.removeEventListener("input", autoCalculateSpriteSize);
                    roomHeightInput.removeEventListener("input", autoCalculateSpriteSize);
                    roomWidthInput.value = roomWidth;
                    roomHeightInput.value = roomHeight;
                    // é‡æ–°æ·»åŠ äº‹ä»¶ç›£è½å™¨
                    setTimeout(() => {
                        roomWidthInput.addEventListener("input", autoCalculateSpriteSize);
                        roomHeightInput.addEventListener("input", autoCalculateSpriteSize);
                    }, 100);

                } else {
                    // å¦‚æœè¶…å‡ºé™åˆ¶ï¼Œé¡¯ç¤ºè­¦å‘Š
                    const maxRoomWidth = Math.min(24, Math.floor(currentImages[0].width / spriteWidth));
                    const maxRoomHeight = Math.min(24, Math.floor(currentImages[0].height / spriteHeight));
                    if (maxRoomWidth > 0 && maxRoomHeight > 0) {
                        const roomWidthInput = document.getElementById("roomWidth");
                        const roomHeightInput = document.getElementById("roomHeight");
                        roomWidthInput.removeEventListener("input", autoCalculateSpriteSize);
                        roomHeightInput.removeEventListener("input", autoCalculateSpriteSize);
                        roomWidthInput.value = maxRoomWidth;
                        roomHeightInput.value = maxRoomHeight;
                        setTimeout(() => {
                            roomWidthInput.addEventListener("input", autoCalculateSpriteSize);
                            roomHeightInput.addEventListener("input", autoCalculateSpriteSize);
                        }, 100);
                    }
                }
            }
        }

        // è‡ªå‹•è¨ˆç®—ç²¾éˆå°ºå¯¸
        function autoCalculateSpriteSize() {
            if (userHasManualInput) return; // <--- æ–°å¢ï¼šç”¨æˆ¶æ‰‹å‹•è¼¸å…¥å¾Œä¸å†è‡ªå‹•è¯å‹•
            if (!currentImages.length || !currentImages[0]) return;
            const roomWidth = parseInt(document.getElementById("roomWidth").value) || 0;
            const roomHeight = parseInt(document.getElementById("roomHeight").value) || 0;
            if (roomWidth > 0 && roomHeight > 0) {
                // è¨ˆç®—ç²¾éˆå°ºå¯¸
                const spriteWidth = Math.floor(currentImages[0].width / roomWidth);
                const spriteHeight = Math.floor(currentImages[0].height / roomHeight);
                // æª¢æŸ¥æ˜¯å¦åœ¨é™åˆ¶ç¯„åœå…§
                if (spriteWidth <= 24 && spriteHeight <= 24 && spriteWidth > 0 && spriteHeight > 0) {
                    // æš«æ™‚ç§»é™¤äº‹ä»¶ç›£è½å™¨é¿å…å¾ªç’°
                    const spriteWidthInput = document.getElementById("spriteWidth");
                    const spriteHeightInput = document.getElementById("spriteHeight");
                    spriteWidthInput.removeEventListener("input", autoCalculateRoomSize);
                    spriteHeightInput.removeEventListener("input", autoCalculateRoomSize);
                    spriteWidthInput.value = spriteWidth;
                    spriteHeightInput.value = spriteHeight;
                    // é‡æ–°æ·»åŠ äº‹ä»¶ç›£è½å™¨
                    setTimeout(() => {
                        spriteWidthInput.addEventListener("input", autoCalculateRoomSize);
                        spriteHeightInput.addEventListener("input", autoCalculateRoomSize);
                    }, 100);

                } else {
                    // å¦‚æœè¶…å‡ºé™åˆ¶ï¼Œé¡¯ç¤ºè­¦å‘Š
                    const maxSpriteWidth = Math.min(24, Math.floor(currentImages[0].width / roomWidth));
                    const maxSpriteHeight = Math.min(24, Math.floor(currentImages[0].height / roomHeight));
                    if (maxSpriteWidth > 0 && maxSpriteHeight > 0) {
                        const spriteWidthInput = document.getElementById("spriteWidth");
                        const spriteHeightInput = document.getElementById("spriteHeight");
                        spriteWidthInput.removeEventListener("input", autoCalculateRoomSize);
                        spriteHeightInput.removeEventListener("input", autoCalculateRoomSize);
                        spriteWidthInput.value = maxSpriteWidth;
                        spriteHeightInput.value = maxSpriteHeight;
                        setTimeout(() => {
                            spriteWidthInput.addEventListener("input", autoCalculateRoomSize);
                            spriteHeightInput.addEventListener("input", autoCalculateRoomSize);
                        }, 100);
                    }
                }
            }
        }
        // ====== å…¨åŸŸå·¥å…·å‡½æ•¸ ======
        function padFrames(frames, maxLen) {
            if (frames.length === maxLen) return frames.slice();
            if (maxLen === 2) {
                return [frames[0], frames[0]];
            }
            if (maxLen === 3) {
                if (frames.length === 1) return [frames[0], frames[0], frames[0]];
                if (frames.length === 2) return [frames[0], frames[1], frames[0]];
            }
            if (maxLen === 4) {
                if (frames.length === 1) return [frames[0], frames[0], frames[0], frames[0]];
                if (frames.length === 2) return [frames[0], frames[1], frames[0], frames[1]];
                if (frames.length === 3) return [frames[0], frames[1], frames[1], frames[2]];
            }
            const arr = frames.slice();
            while (arr.length < maxLen) arr.push(JSON.parse(JSON.stringify(arr[arr.length - 1])));
            return arr;
        }
        
        // é€šç”¨æª”æ¡ˆåˆ—è¡¨æ¸²æŸ“å‡½æ•¸
        function renderGenericFileList(fileList, items, itemType = 'ç²¾éˆ') {
            fileList.innerHTML = '';
            items.forEach((item, i) => {
                const li = document.createElement('li');
                li.innerHTML = `<img src="static/file-icon.png" alt="File Icon"> ${item.file.name}`;
                li.draggable = true;
                li.dataset.idx = i;
                fileList.appendChild(li);
            });
        }
        
        // é€šç”¨å±¬æ€§é¸æ“‡æ¸²æŸ“å‡½æ•¸
        function renderGenericAttrSelect(attrSelect, items, attrSourceIdx, itemType = 'ç²¾éˆ') {
            attrSelect.style.display = '';
            attrSelect.innerHTML = `é¸æ“‡è¦ä¿ç•™å±¬æ€§çš„${itemType}ï¼š`;
            const select = document.createElement('select');
            items.forEach((item, i) => {
                const opt = document.createElement('option');
                opt.value = i;
                opt.textContent = `${item.file.name} (${item.data.name || ''})`;
                select.appendChild(opt);
            });
            select.value = attrSourceIdx;
            select.onchange = e => { attrSourceIdx = Number(e.target.value); };
            attrSelect.appendChild(select);
        }
        
        // é€šç”¨ç¯€æµå‡½æ•¸
        function createThrottledFunction(func) {
            let ticking = false;
            return function() {
                if (!ticking) {
                    requestAnimationFrame(() => {
                        func();
                        ticking = false;
                    });
                    ticking = true;
                }
            };
        }
        
        // é€šç”¨åœ–ç‰‡è™•ç†å‡½æ•¸
        function processImageToCanvas(img, fileName, index = 0) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            const imageData = {
                width: img.width,
                height: img.height,
                canvas: canvas,
                context: ctx,
                fileName: fileName,
                spriteName: `sprite${index+1}`,
                colorIndex: 1
            };
            
            // å¦‚æœæœ‰èª¿è‰²ç›¤ï¼Œé€²è¡Œè‰²éšåŒ–
            if (currentPalette) {
                const imgData = ctx.getImageData(0, 0, img.width, img.height);
                const quantizeMethod = document.getElementById('quantizeMethod').value;
                const useHsl = quantizeMethod === 'hsl';
                imageData.quantized = quantizeToPalette(imgData.data, currentPalette, useHsl);
                imageData.quantizedWidth = img.width;
                imageData.quantizedHeight = img.height;
            }
            
            return imageData;
        }
        
        // é€šç”¨åœ–ç‰‡è¼‰å…¥å®Œæˆè™•ç†å‡½æ•¸
        function handleImageLoadComplete(isBatchMode = false) {
            allImagesLoaded = true;
            enableGenerateButtons();
            
            const firstImg = currentImages[0];
            generateForm.style.display = "block";
            imageSize.textContent = `${firstImg.width} x ${firstImg.height}`;
            const suggestions = calculateSuggestions(firstImg.width, firstImg.height);
            displaySuggestions(suggestions);
            imageInfo.style.display = "block";
            
            if (suggestions.length > 0) {
                const firstSuggestion = suggestions[0];
                document.getElementById("spriteWidth").value = firstSuggestion.spriteWidth;
                document.getElementById("spriteHeight").value = firstSuggestion.spriteHeight;
                document.getElementById("roomWidth").value = firstSuggestion.roomWidth;
                document.getElementById("roomHeight").value = firstSuggestion.roomHeight;
            }
            
            showMessage(isBatchMode ? 'æ‰€æœ‰åœ–ç‰‡å·²è¼‰å…¥å®Œæˆï¼Œå¯ç”Ÿæˆæ•¸æ“š' : 'åœ–ç‰‡è¼‰å…¥æˆåŠŸï¼', 'success');
            renderBatchSpriteSettings();
            currentPreviewIndex = 0;
            updatePreview();
            updateColorIndexAndPaletteNameUI();
            updateCurrentPaletteStatus();
            showAutoPaletteSection(true);
            
            resetAutoPaletteButton();
        }
        
        // é‡æ–°è™•ç†æ‰€æœ‰å·²è¼‰å…¥çš„åœ–ç‰‡ä»¥æ‡‰ç”¨æ–°çš„èª¿è‰²ç›¤
        function reprocessImagesWithPalette() {
            if (!currentPalette || currentImages.length === 0) return;
            
            const quantizeMethod = document.getElementById('quantizeMethod').value;
            const useHsl = quantizeMethod === 'hsl';
            
            currentImages.forEach((imageData, index) => {
                if (imageData.canvas) {
                    const ctx = imageData.canvas.getContext('2d');
                    const imgData = ctx.getImageData(0, 0, imageData.width, imageData.height);
                    imageData.quantized = quantizeToPalette(imgData.data, currentPalette, useHsl);
                    imageData.quantizedWidth = imageData.width;
                    imageData.quantizedHeight = imageData.height;
                }
            });
        }
        
        // é‡ç½®è‡ªå‹•åµæ¸¬æŒ‰éˆ•ç‹€æ…‹
        function resetAutoPaletteButton() {
            const autoPaletteBtn = document.getElementById('autoPaletteBtn');
            if (autoPaletteBtn) {
                autoPaletteBtn.textContent = 'è‡ªå‹•åµæ¸¬åœ–ç‰‡é¡è‰²';
                autoPaletteBtn.disabled = false;
            }
        }

        // ===== ç²¾éˆåˆä½µå·¥å…· =====
        (function(){
            const input = document.getElementById('mergeSpriteInput');
            const fileList = document.getElementById('mergeSpriteFileList');
            const attrSelect = document.getElementById('mergeSpriteAttrSelect');
            const mergeBtn = document.getElementById('mergeSpriteBtn');
            // ç²¾éˆåˆä½µå·¥å…·çš„æ‹–æ›³æ’åºè™•ç†
            let sprites = [];
            let attrSourceIdx = 0;

            // æ‹–æ›³æ’åº
            let dragIdx = null;
            fileList.addEventListener('dragstart', e => {
                dragIdx = Number(e.target.dataset.idx);
                e.dataTransfer.effectAllowed = 'move';
            });
            fileList.addEventListener('dragover', e => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                const target = e.target.closest("li");
                if (target) {
                    // å…ˆç§»é™¤æ‰€æœ‰ drag-hover é¡åˆ¥
                    fileList.querySelectorAll("li").forEach((li) => li.classList.remove("drag-hover"));
                    // å†æ·»åŠ çµ¦ç›®æ¨™å…ƒç´ 
                    target.classList.add("drag-hover");
                }
            });
            fileList.addEventListener('drop', e => {
                e.preventDefault();
                const targetIdx = Number(e.target.closest('li').dataset.idx);
                if (dragIdx !== null && targetIdx !== dragIdx) {
                    const moved = sprites.splice(dragIdx, 1)[0];
                    sprites.splice(targetIdx, 0, moved);
                    renderGenericFileList(fileList, sprites, 'ç²¾éˆ');
                    renderGenericAttrSelect(attrSelect, sprites, attrSourceIdx, 'ç²¾éˆ');
                }
                dragIdx = null;
                // ç§»é™¤æ‰€æœ‰ drag-hover é¡åˆ¥
                fileList.querySelectorAll("li").forEach((li) => li.classList.remove("drag-hover"));
            });

            input.addEventListener('change', async e => {
                sprites = [];
                attrSelect.style.display = 'none';
                mergeBtn.style.display = 'none';
                fileList.innerHTML = '';
                const files = Array.from(input.files);
                for (const file of files) {
                    try {
                        const text = await file.text();
                        const data = JSON.parse(text);
                        sprites.push({file, data});
                    } catch {
                        showMessage(`æª”æ¡ˆ ${file.name} è§£æå¤±æ•—`, 'error');
                        return;
                    }
                }
                if (sprites.length < 2) {
                    showMessage('è«‹é¸æ“‡è‡³å°‘å…©å€‹ç²¾éˆæª”æ¡ˆ', 'error');
                    return;
                }
                // æª¢æŸ¥é•·å¯¬ä¸€è‡´
                const w = sprites[0].data.width, h = sprites[0].data.height;
                if (!sprites.every(s => s.data.width === w && s.data.height === h)) {
                    showMessage('æ‰€æœ‰ç²¾éˆçš„å¯¬é«˜å¿…é ˆä¸€è‡´ï¼', 'error');
                    return;
                }
                renderGenericFileList(fileList, sprites, 'ç²¾éˆ');
                renderGenericAttrSelect(attrSelect, sprites, attrSourceIdx, 'ç²¾éˆ');
                mergeBtn.style.display = '';
            });

            // ä½¿ç”¨é€šç”¨å‡½æ•¸ï¼Œç„¡éœ€é‡è¤‡å®šç¾©

            mergeBtn.onclick = function() {
                if (sprites.length < 2) {
                    showMessage('è«‹é¸æ“‡è‡³å°‘å…©å€‹ç²¾éˆæª”æ¡ˆ', 'error');
                    return;
                }
                // è™•ç†å–®è‰²å’Œå¤šè‰²ç²¾éˆçš„ frameList
                const colorFrameLists = sprites.map(s => {
                    // æª¢æŸ¥æ˜¯å¦ç‚ºå–®è‰²ç²¾éˆï¼ˆæœ‰ colorIndexï¼‰
                    if (s.data.colorIndex !== undefined) {
                        // å–®è‰²ç²¾éˆï¼šå°‡ 1 è½‰æ›ç‚º colorIndexï¼Œ0 ä¿æŒç‚º 0
                        const color = s.data.colorIndex;
                        return s.data.frameList.map(frame => frame.map(px => px === 1 ? color : 0));
                    } else {
                        // å¤šè‰²ç²¾éˆï¼šç›´æ¥ä½¿ç”¨åŸå§‹ frameListï¼ˆå·²ç¶“æ˜¯é¡è‰²å€¼ï¼‰
                        return s.data.frameList.map(frame => [...frame]);
                    }
                });
                // ====== æ–°å¢ï¼šå‹•ç•«å¹€è£œé½Š ======
                const maxFrameLen = Math.max(...colorFrameLists.map(frames => frames.length));
                const paddedColorFrameLists = colorFrameLists.map(frames => padFrames(frames, maxFrameLen));
                // ====== åˆä½µæ™‚ colorFrameLists æ›æˆ paddedColorFrameLists ======
                const w = sprites[0].data.width, h = sprites[0].data.height;
                const mergedFrameList = [];
                for (let f = 0; f < maxFrameLen; f++) {
                    const mergedFrame = [];
                    for (let i = 0; i < w * h; i++) {
                        let val = 0;
                        for (let sIdx = 0; sIdx < paddedColorFrameLists.length; sIdx++) {
                            const frameArr = paddedColorFrameLists[sIdx][f] || paddedColorFrameLists[sIdx][0];
                            if (frameArr[i] !== 0) val = frameArr[i];
                        }
                        mergedFrame.push(val);
                    }
                    mergedFrameList.push(mergedFrame);
                }
                // ç›´æ¥å¾ä¸‹æ‹‰é¸å–® DOM å–å€¼ï¼Œç¢ºä¿æ­£ç¢º
                const select = attrSelect.querySelector('select');
                const idx = select ? Number(select.value) : attrSourceIdx;
                const src = sprites[idx].data;
                const merged = {
                    name: src.name,
                    isAvatar: src.isAvatar,
                    isWall: src.isWall,
                    isItem: src.isItem,
                    isTransparent: src.isTransparent,
                    width: src.width,
                    height: src.height,
                    frameList: mergedFrameList,
                    scriptList: JSON.parse(JSON.stringify(src.scriptList || {}))
                };
                delete merged.colorIndex;
                
                // é¡¯ç¤ºåˆä½µå¾Œæ•¸æ“š
                const mergeOutput = document.getElementById("mergeSpriteOutput");
                mergeOutput.value = (merged && merged.frameList)
                    ? JSON.stringify(merged)
                    : JSON.stringify(merged, null, 4);
                mergeOutput.style.display = "block";
                
                // é¡¯ç¤ºä¸‹è¼‰æŒ‰éˆ•
                const mergeDownloadBtn = document.getElementById("mergeSpriteDownloadBtn");
                mergeDownloadBtn.style.display = "block";
                
                showMessage('ç²¾éˆåˆä½µæˆåŠŸï¼', 'success');
            };
            
            // ç²¾éˆåˆä½µä¸‹è¼‰æŒ‰éˆ•
            document.getElementById("mergeSpriteDownloadBtn").addEventListener("click", () => {
                const mergeOutput = document.getElementById("mergeSpriteOutput");
                const fileName = sprites[attrSourceIdx].file.name.replace(/\.(json|mosisprite)?$/, "") + ".mosisprite";
                const content = JSON.stringify(JSON.parse(mergeOutput.value));
                const blob = new Blob([content], {type:'application/octet-stream'});
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = fileName;
                a.click();
                URL.revokeObjectURL(a.href);
            });
        })();

        // ===== æˆ¿é–“åˆä½µå–®è‰²ç²¾éˆå·¥å…· =====
        (function(){
            const input = document.getElementById('mergeRoomInput');
            const mergeBtn = document.getElementById('mergeRoomBtn');
            let roomData = null, fileName = '';
            input.onchange = async function(e) {
                mergeBtn.style.display = 'none';
                if (!input.files[0]) return;
                fileName = input.files[0].name;
                try {
                    const text = await input.files[0].text();
                    roomData = JSON.parse(text);
                    mergeBtn.style.display = '';
                } catch {
                    showMessage('æª”æ¡ˆæ ¼å¼éŒ¯èª¤ï¼Œè«‹ä¸Šå‚³æ­£ç¢ºçš„ .mosiroom æª”æ¡ˆ', 'error');
                    roomData = null;
                }
            };
            mergeBtn.onclick = function() {
                if (!roomData) return;
                try {
                    const room = JSON.parse(JSON.stringify(roomData));
                    const spriteMap = {};
                    room.spriteList.forEach(s => spriteMap[s.name] = s);
                    // ====== é è™•ç†ï¼šæ¯å€‹é‡è¤‡æ”¾ç½®çš„ sprite éƒ½åˆ†é…ä¸€å€‹ç¨ç«‹è¤‡è£½ï¼ˆåç¨±åŠ ç·¨è™Ÿï¼‰ ======
                    // ï¼ˆå·²ä¸éœ€è¦ï¼Œç›´æ¥è·³éï¼Œä¿ç•™åŸå§‹ tileList èˆ‡ spriteListï¼‰
                    // ä¾åº§æ¨™åˆ†çµ„
                    const posMap = {};
                    room.tileList.forEach((t, idx) => {
                        const key = t.x + ',' + t.y;
                        if (!posMap[key]) posMap[key] = [];
                        posMap[key].push(idx);
                    });
                    let mergedCount = 0;
                    Object.entries(posMap).forEach(([key, idxArr]) => {
                        // æ¯ä¸€æ ¼éƒ½ç”¢ç”Ÿä¸€å€‹ç¨ç«‹çš„åˆä½µç²¾éˆ
                        const [x, y] = key.split(',').map(Number);
                        const sprites = idxArr.map(idx => spriteMap[room.tileList[idx].spriteName]);
                        // ====== æ–°å¢ï¼šå‹•ç•«å¹€è£œé½Š ======
                        // 1. è™•ç†å–®è‰²å’Œå¤šè‰²ç²¾éˆçš„ frameList
                        const colorFrameLists = sprites.map(s => {
                            // æª¢æŸ¥æ˜¯å¦ç‚ºå–®è‰²ç²¾éˆï¼ˆæœ‰ colorIndexï¼‰
                            if (s.colorIndex !== undefined) {
                                // å–®è‰²ç²¾éˆï¼šå°‡ 1 è½‰æ›ç‚º colorIndexï¼Œ0 ä¿æŒç‚º 0
                                const color = s.colorIndex;
                                return s.frameList.map(frame => frame.map(px => px === 1 ? color : 0));
                            } else {
                                // å¤šè‰²ç²¾éˆï¼šç›´æ¥ä½¿ç”¨åŸå§‹ frameListï¼ˆå·²ç¶“æ˜¯é¡è‰²å€¼ï¼‰
                                return s.frameList.map(frame => [...frame]);
                            }
                        });
                        // 2. å–å¾—æœ€å¤§å‹•ç•«å¹€æ•¸
                        const maxFrameLen = Math.max(...colorFrameLists.map(frames => frames.length));
                        // 3. å¹€æ•¸ä¸è¶³è£œé½Š
                        const paddedColorFrameLists = colorFrameLists.map(frames => padFrames(frames, maxFrameLen));
                        // ====== åˆä½µæ™‚ colorFrameLists æ›æˆ paddedColorFrameLists ======
                        const w = sprites[0].width, h = sprites[0].height;
                        const mergedFrameList = [];
                        for (let f = 0; f < maxFrameLen; f++) {
                            const mergedFrame = [];
                            for (let i = 0; i < w * h; i++) {
                                let color = 0;
                                for (let sIdx = 0; sIdx < paddedColorFrameLists.length; sIdx++) {
                                    const val = paddedColorFrameLists[sIdx][f][i];
                                    if (val && val !== 0) color = val;
                                }
                                mergedFrame.push(color);
                            }
                            mergedFrameList.push(mergedFrame);
                        }
                        // å…ˆå®£å‘Š topSprite
                        const topSprite = sprites[sprites.length - 1];
                        // æ±ºå®šåˆä½µç²¾éˆåç¨±ï¼šåªæœ‰å¤šè‰²æ‰åŠ  -åˆä½µ(x,y)ï¼Œå–®è‰²ç¶­æŒåŸå
                        let mergedName = topSprite.name;
                        if (sprites.length > 1) {
                            mergedName = `${topSprite.name}-åˆä½µ(${x},${y})`;
                        }
                        // ===== scriptList æ–°é‚è¼¯ =====
                        let mergedScriptList = {};
                        let scriptLog = [];
                        for (let i = sprites.length - 1; i >= 0; i--) {
                            scriptLog.push({name: sprites[i].name, scriptList: sprites[i].scriptList});
                            if (isScriptListValid(sprites[i].scriptList)) {
                                mergedScriptList = JSON.parse(JSON.stringify(sprites[i].scriptList));
                                break;
                            }
                        }
        
                        const mergedSprite = {
                            name: mergedName,
                            isAvatar: false,
                            isWall: false,
                            isItem: false,
                            isTransparent: true,
                            width: w,
                            height: h,
                            frameList: mergedFrameList,
                            scriptList: mergedScriptList
                        };
                        // å±¬æ€§ä¾†æºï¼šå–æœ€ä¸Šå±¤ç²¾éˆï¼ˆå¯èª¿æ•´ï¼‰
                        mergedSprite.isAvatar = topSprite.isAvatar;
                        mergedSprite.isWall = topSprite.isWall;
                        mergedSprite.isItem = topSprite.isItem;
                        mergedSprite.isTransparent = topSprite.isTransparent;
                        mergedSprite.scriptList = mergedScriptList;
        
                        room.spriteList.push(mergedSprite);
                        // åª log é™¤ frameList ä»¥å¤–çš„å±¬æ€§
                        const { frameList, ...spriteInfo } = mergedSprite;
                        // tileList ä¿ç•™æ‰€æœ‰åŸ tileï¼Œå…¨éƒ¨æŒ‡å‘æ–°åˆä½µç²¾éˆ
                        idxArr.forEach(idx => {
                            room.tileList[idx] = {
                                spriteName: mergedSprite.name,
                                x: room.tileList[idx].x,
                                y: room.tileList[idx].y
                            };
                        });
                        mergedCount++;
                    });
                    // ç§»é™¤è¢«åˆä½µçš„ tile
                    room.tileList = room.tileList.filter(t => t);
                    if (mergedCount === 0) {
                        showMessage('æ²’æœ‰éœ€è¦åˆä½µçš„åŒæ ¼å–®è‰²ç²¾éˆ', 'error');
                        return;
                    }
                    // ====== æ–°å¢ï¼šåˆä½µç²¾éˆå…§å®¹å»é‡ ======
                    if (room.spriteList && room.spriteList.length > 0) {
                        const spriteContentMap = {};
                        const nameMap = {};
                        room.spriteList.forEach(s => {
                            const hash = JSON.stringify({
                                isAvatar: s.isAvatar,
                                isWall: s.isWall,
                                isItem: s.isItem,
                                isTransparent: s.isTransparent,
                                width: s.width,
                                height: s.height,
                                frameList: s.frameList,
                                scriptList: s.scriptList
                            });
                            if (!spriteContentMap[hash]) {
                                spriteContentMap[hash] = s;
                                nameMap[s.name] = s.name;
                            } else {
                                nameMap[s.name] = spriteContentMap[hash].name;
                            }
                        });
                        room.spriteList = Object.values(spriteContentMap);
                        // ä¿®æ­£ tileList æŒ‡å‘å”¯ä¸€ç²¾éˆåç¨±
                        room.tileList.forEach(tile => {
                            if (nameMap[tile.spriteName]) {
                                tile.spriteName = nameMap[tile.spriteName];
                            }
                        });
                    }
                    // é¡¯ç¤ºåˆä½µå¾Œæ•¸æ“š
                    const mergeOutput = document.getElementById("mergeRoomOutput");
                    mergeOutput.value = (room && room.tileList)
                        ? JSON.stringify(room)
                        : JSON.stringify(room, null, 4);
                    mergeOutput.style.display = "block";
                    
                    // é¡¯ç¤ºä¸‹è¼‰æŒ‰éˆ•
                    const mergeDownloadBtn = document.getElementById("mergeRoomDownloadBtn");
                    mergeDownloadBtn.style.display = "block";
                    
                    showMessage('æˆ¿é–“åˆä½µæˆåŠŸï¼', 'success');
                } catch (e) {
                    showMessage('åˆä½µå¤±æ•—ï¼š' + e.message, 'error');
                    console.error('åˆä½µæˆ¿é–“å–®è‰²ç²¾éˆéŒ¯èª¤', e);
                }
            };
            
            // æˆ¿é–“åˆä½µå–®è‰²ç²¾éˆä¸‹è¼‰æŒ‰éˆ•
            document.getElementById("mergeRoomDownloadBtn").addEventListener("click", () => {
                const mergeOutput = document.getElementById("mergeRoomOutput");
                let downloadName = (fileName || "merged_room")
                  .replace(/\.(json|mosiroom)?$/, "") + ".mosiroom";
                const content = JSON.stringify(JSON.parse(mergeOutput.value));
                const blob = new Blob([content], {type:'application/octet-stream'});
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = downloadName;
                a.click();
                URL.revokeObjectURL(a.href);
            });
            
            // æˆ¿é–“åˆä½µå–®è‰²ç²¾éˆå·¥å…·æ–‡å­—åŒ¯å…¥
            document.getElementById('mergeRoomTextImportBtn').onclick = function() {
                const text = document.getElementById('mergeRoomTextImport').value.trim();
                if (!text) {
                    showMessage('è«‹è²¼ä¸Šæˆ¿é–“æ•¸æ“š', 'error');
                    return;
                }
                try {
                    const data = JSON.parse(text);
                    roomData = data;
                    // å˜—è©¦å¾æˆ¿é–“æ•¸æ“šä¸­æå–åç¨±
                    fileName = data.name || data.roomName || 'imported_room';
                    mergeBtn.style.display = '';
                    showMessage('æˆ¿é–“æ•¸æ“šåŒ¯å…¥æˆåŠŸ', 'success');
                } catch (err) {
                    showMessage('æˆ¿é–“æ•¸æ“šè§£æå¤±æ•—: ' + err.message, 'error');
                    roomData = null;
                }
            };
        })();

        // ===== ä¸–ç•Œç´šåˆä½µå·¥å…· =====
        (function(){
            const input = document.getElementById('mergeWorldInput');
            const mergeBtn = document.getElementById('mergeWorldBtn');
            let worldData = null, fileName = '';
            input.onchange = async function(e) {
                mergeBtn.style.display = 'none';
                if (!input.files[0]) return;
                fileName = input.files[0].name;
                try {
                    const text = await input.files[0].text();
                    worldData = JSON.parse(text);
                    mergeBtn.style.display = '';
                } catch {
                    showMessage('æª”æ¡ˆæ ¼å¼éŒ¯èª¤ï¼Œè«‹ä¸Šå‚³æ­£ç¢ºçš„ .mosi ä¸–ç•Œæª”æ¡ˆ', 'error');
                    worldData = null;
                }
            };
            mergeBtn.onclick = function() {
                if (!worldData) return;
                try {
                    // æ·±æ‹·è²ä¸–ç•Œæ•¸æ“šï¼Œå®Œæ•´ä¿ç•™æ‰€æœ‰å±¬æ€§
                    const world = JSON.parse(JSON.stringify(worldData));
                    if (!Array.isArray(world.roomList) || !Array.isArray(world.spriteList)) {
                        showMessage('ä¸–ç•Œæ•¸æ“šæ ¼å¼éŒ¯èª¤ï¼Œç¼ºå°‘ roomList æˆ– spriteList', 'error');
                        return;
                    }
                    // å»ºç«‹ spriteName->sprite æ˜ å°„
                    const globalSpriteMap = {};
                    world.spriteList.forEach(s => globalSpriteMap[s.name] = s);
                    // ç”¨ä¾†è¨˜éŒ„æ‰€æœ‰åˆä½µå¾Œæ–°ç²¾éˆåç¨±
                    const mergedSpriteNames = new Set();
                    // ç”¨ä¾†è¨˜éŒ„æ‰€æœ‰è¢«åˆä½µçš„åŸå§‹ç²¾éˆåç¨±
                    const mergedSourceNames = new Set();
                    // è™•ç†æ¯å€‹æˆ¿é–“
                    world.roomList.forEach(room => {
                        // å»ºç«‹æœ¬æˆ¿é–“ spriteName->sprite
                        const roomSpriteMap = {};
                        (room.spriteList||[]).forEach(s => roomSpriteMap[s.name] = s);
                        // åˆä½µ tileList
                        const posMap = {};
                        (room.tileList||[]).forEach((t, idx) => {
                            const key = t.x + ',' + t.y;
                            if (!posMap[key]) posMap[key] = [];
                            posMap[key].push(idx);
                        });
                        Object.entries(posMap).forEach(([key, idxArr]) => {
                            // æ¯æ ¼éƒ½ç”¢ç”Ÿä¸€å€‹åˆä½µç²¾éˆ
                            const [x, y] = key.split(',').map(Number);
                            // æ”¯æ´æˆ¿é–“è‡ªå¸¶ spriteListï¼Œå¦å‰‡ç”¨ä¸–ç•Œ spriteList
                            const sprites = idxArr.map(idx => {
                                const sn = room.tileList[idx].spriteName;
                                return roomSpriteMap[sn] || globalSpriteMap[sn];
                            });
                            // è¨˜éŒ„æ‰€æœ‰è¢«åˆä½µçš„åŸå§‹ç²¾éˆåç¨±
                            sprites.forEach(s => mergedSourceNames.add(s.name));
                            // è™•ç†å–®è‰²å’Œå¤šè‰²ç²¾éˆçš„ frameList
                            const colorFrameLists = sprites.map(s => {
                                // æª¢æŸ¥æ˜¯å¦ç‚ºå–®è‰²ç²¾éˆï¼ˆæœ‰ colorIndexï¼‰
                                if (s.colorIndex !== undefined) {
                                    // å–®è‰²ç²¾éˆï¼šå°‡ 1 è½‰æ›ç‚º colorIndexï¼Œ0 ä¿æŒç‚º 0
                                    const color = s.colorIndex;
                                    return s.frameList.map(frame => frame.map(px => px === 1 ? color : 0));
                                } else {
                                    // å¤šè‰²ç²¾éˆï¼šç›´æ¥ä½¿ç”¨åŸå§‹ frameListï¼ˆå·²ç¶“æ˜¯é¡è‰²å€¼ï¼‰
                                    return s.frameList.map(frame => [...frame]);
                                }
                            });
                            // å¹€è£œé½Š
                            const maxFrameLen = Math.max(...colorFrameLists.map(frames => frames.length));
                            const paddedColorFrameLists = colorFrameLists.map(frames => padFrames(frames, maxFrameLen));
                            const w = sprites[0].width, h = sprites[0].height;
                            const mergedFrameList = [];
                            for (let f = 0; f < maxFrameLen; f++) {
                                const mergedFrame = [];
                                for (let i = 0; i < w * h; i++) {
                                    let color = 0;
                                    for (let sIdx = 0; sIdx < paddedColorFrameLists.length; sIdx++) {
                                        const val = paddedColorFrameLists[sIdx][f][i];
                                        if (val && val !== 0) color = val;
                                    }
                                    mergedFrame.push(color);
                                }
                                mergedFrameList.push(mergedFrame);
                            }
                            // å–æœ€ä¸Šå±¤ç²¾éˆ
                            const topSprite = sprites[sprites.length - 1];
                            let mergedName = topSprite.name;
                            if (sprites.length > 1) {
                                mergedName = `${topSprite.name}-åˆä½µ(${x},${y})`;
                            }
                            // ===== scriptList æ–°é‚è¼¯ =====
                            let mergedScriptList = {};
                            let scriptLog = [];
                            for (let i = sprites.length - 1; i >= 0; i--) {
                                scriptLog.push({name: sprites[i].name, scriptList: sprites[i].scriptList});
                                if (isScriptListValid(sprites[i].scriptList)) {
                                    mergedScriptList = JSON.parse(JSON.stringify(sprites[i].scriptList));
                                    break;
                                }
                            }
            
                            const mergedSprite = {
                                name: mergedName,
                                isAvatar: topSprite.isAvatar,
                                isWall: topSprite.isWall,
                                isItem: topSprite.isItem,
                                isTransparent: topSprite.isTransparent,
                                width: w,
                                height: h,
                                frameList: mergedFrameList,
                                scriptList: mergedScriptList
                            };
                            // æ–°å¢åˆ°ä¸–ç•Œ spriteList
                            world.spriteList.push(mergedSprite);
                            mergedSpriteNames.add(mergedName);
                            // tileList æŒ‡å‘æ–°åˆä½µç²¾éˆ
                            idxArr.forEach(idx => {
                                room.tileList[idx] = {
                                    spriteName: mergedSprite.name,
                                    x: room.tileList[idx].x,
                                    y: room.tileList[idx].y
                                };
                            });
                        });
                    });
                    // åˆä½µå¾Œæ¸…ç† spriteListï¼š
                    // 1. ä¿ç•™åˆä½µå¾Œçš„æ–°ç²¾éˆï¼ˆmergedSpriteNamesï¼‰
                    // 2. ç§»é™¤è¢«åˆä½µçš„åŸå§‹ç²¾éˆï¼ˆmergedSourceNamesï¼‰
                    // 3. ä¿ç•™æœªåƒèˆ‡åˆä½µçš„ç²¾éˆï¼ˆæ—¢ä¸åœ¨ mergedSpriteNames ä¹Ÿä¸åœ¨ mergedSourceNamesï¼‰
                    // 4. ç§»é™¤é‡è¤‡ç²¾éˆï¼ˆåŒååªç•™ä¸€å€‹ï¼‰
                    const uniqueSpriteMap = {};
                    world.spriteList.forEach(s => {
                        // ä¿ç•™åˆä½µå¾Œçš„æ–°ç²¾éˆ
                        if (mergedSpriteNames.has(s.name)) {
                            uniqueSpriteMap[s.name] = s;
                        }
                        // ä¿ç•™æœªåƒèˆ‡åˆä½µçš„ç²¾éˆï¼ˆæ—¢ä¸æ˜¯åˆä½µå¾Œçš„æ–°ç²¾éˆï¼Œä¹Ÿä¸æ˜¯è¢«åˆä½µçš„åŸå§‹ç²¾éˆï¼‰
                        else if (!mergedSourceNames.has(s.name)) {
                            uniqueSpriteMap[s.name] = s;
                        }
                        // è¢«åˆä½µçš„åŸå§‹ç²¾éˆæœƒè¢«ç§»é™¤ï¼ˆä¸åŠ å…¥ uniqueSpriteMapï¼‰
                    });
                    world.spriteList = Object.values(uniqueSpriteMap);
                    // ====== æ–°å¢ï¼šåˆä½µç²¾éˆå…§å®¹å»é‡ ======
                    const spriteContentMap = {};
                    const nameMap = {};
                    world.spriteList.forEach(s => {
                        const hash = JSON.stringify({
                            isAvatar: s.isAvatar,
                            isWall: s.isWall,
                            isItem: s.isItem,
                            isTransparent: s.isTransparent,
                            width: s.width,
                            height: s.height,
                            frameList: s.frameList,
                            scriptList: s.scriptList
                        });
                        if (!spriteContentMap[hash]) {
                            spriteContentMap[hash] = s;
                            nameMap[s.name] = s.name;
                        } else {
                            nameMap[s.name] = spriteContentMap[hash].name;
                        }
                    });
                    world.spriteList = Object.values(spriteContentMap);
                    // ä¿®æ­£æ‰€æœ‰æˆ¿é–“ tileList æŒ‡å‘å”¯ä¸€ç²¾éˆåç¨±
                    world.roomList.forEach(room => {
                        room.tileList.forEach(tile => {
                            if (nameMap[tile.spriteName]) {
                                tile.spriteName = nameMap[tile.spriteName];
                            }
                        });
                    });
                    // æª¢æŸ¥æ•¸æ“šå¤§å°
                    const worldString = JSON.stringify(world);
                    const dataSize = new Blob([worldString]).size;
                    const maxSize = 5 * 1024 * 1024; // 5MB
                    
                    const mergeOutput = document.getElementById("mergeWorldOutput");
                    const mergeDownloadBtn = document.getElementById("mergeWorldDownloadBtn");
                    
                    if (dataSize <= maxSize) {
                        // æ•¸æ“šä¸å¤§ï¼Œé¡¯ç¤ºæ–‡å­—æ¡†
                        mergeOutput.value = (world && world.roomList)
                            ? JSON.stringify(world)
                            : JSON.stringify(world, null, 4);
                        mergeOutput.style.display = "block";
                        mergeDownloadBtn.style.display = "block";
                        showMessage('ä¸–ç•Œåˆä½µæˆåŠŸï¼', 'success');
                    } else {
                        // æ•¸æ“šå¤ªå¤§ï¼Œåªé¡¯ç¤ºä¸‹è¼‰æŒ‰éˆ•
                        mergeOutput.style.display = "none";
                        mergeDownloadBtn.style.display = "block";
                        // å°‡æ•¸æ“šå­˜å„²åˆ°å…¨åŸŸè®Šæ•¸ä¾›ä¸‹è¼‰ä½¿ç”¨
                        window.largeWorldData = world;
                        showMessage(`ä¸–ç•Œåˆä½µæˆåŠŸï¼æ•¸æ“šå¤§å° ${(dataSize / 1024 / 1024).toFixed(1)}MBï¼Œå·²è¶…é5MBï¼Œåƒ…æä¾›ä¸‹è¼‰åŠŸèƒ½`, 'success');
                    }
                } catch (e) {
                    showMessage('åˆä½µå¤±æ•—ï¼š' + e.message, 'error');
                    console.error('ä¸–ç•Œç´šåˆä½µéŒ¯èª¤', e);
                }
            };
            
            // ä¸–ç•Œç´šåˆä½µä¸‹è¼‰æŒ‰éˆ•
            document.getElementById("mergeWorldDownloadBtn").addEventListener("click", () => {
                let downloadName = (fileName || "merged_world")
                  .replace(/\.(json|mosi)?$/, "") + ".mosi";
                
                let content;
                if (window.largeWorldData) {
                    // å¤§æ•¸æ“šæƒ…æ³ï¼Œä½¿ç”¨å­˜å„²çš„æ•¸æ“š
                    content = JSON.stringify(window.largeWorldData);
                    // ä¸‹è¼‰å¾Œæ¸…ç†
                    delete window.largeWorldData;
                } else {
                    // å°æ•¸æ“šæƒ…æ³ï¼Œå¾æ–‡å­—æ¡†è®€å–
                    const mergeOutput = document.getElementById("mergeWorldOutput");
                    content = JSON.stringify(JSON.parse(mergeOutput.value));
                }
                
                const blob = new Blob([content], {type:'application/octet-stream'});
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = downloadName;
                a.click();
                URL.revokeObjectURL(a.href);
            });
            
            // ä¸–ç•Œç´šåˆä½µå·¥å…·æ–‡å­—åŒ¯å…¥
            document.getElementById('mergeWorldTextImportBtn').onclick = function() {
                const text = document.getElementById('mergeWorldTextImport').value.trim();
                if (!text) {
                    showMessage('è«‹è²¼ä¸Šä¸–ç•Œæ•¸æ“š', 'error');
                    return;
                }
                try {
                    const data = JSON.parse(text);
                    worldData = data;
                    // å˜—è©¦å¾ä¸–ç•Œæ•¸æ“šä¸­æå–åç¨±
                    fileName = data.name || data.worldName || 'imported_world';
                    mergeBtn.style.display = '';
                    showMessage('ä¸–ç•Œæ•¸æ“šåŒ¯å…¥æˆåŠŸ', 'success');
                } catch (err) {
                    showMessage('ä¸–ç•Œæ•¸æ“šè§£æå¤±æ•—: ' + err.message, 'error');
                    worldData = null;
                }
            };
        })();

        // ===== æ’åœ–åˆä½µå·¥å…· =====
        (function(){
            const input = document.getElementById('mergePictureInput');
            const fileList = document.getElementById('mergePictureFileList');
            const attrSelect = document.getElementById('mergePictureAttrSelect');
            const mergeBtn = document.getElementById('mergePictureBtn');
            // æ’åœ–åˆä½µå·¥å…·çš„æ‹–æ›³æ’åºè™•ç†
            let sprites = [];
            let attrSourceIdx = 0;

            // æ‹–æ›³æ’åº
            let dragIdx = null;
            fileList.addEventListener('dragstart', e => {
                dragIdx = Number(e.target.dataset.idx);
                e.dataTransfer.effectAllowed = 'move';
            });
            fileList.addEventListener('dragover', e => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                const target = e.target.closest("li");
                if (target) {
                    // å…ˆç§»é™¤æ‰€æœ‰ drag-hover é¡åˆ¥
                    fileList.querySelectorAll("li").forEach((li) => li.classList.remove("drag-hover"));
                    // å†æ·»åŠ çµ¦ç›®æ¨™å…ƒç´ 
                    target.classList.add("drag-hover");
                }
            });
            fileList.addEventListener('drop', e => {
                e.preventDefault();
                const targetIdx = Number(e.target.closest('li').dataset.idx);
                if (dragIdx !== null && targetIdx !== dragIdx) {
                    const moved = sprites.splice(dragIdx, 1)[0];
                    sprites.splice(targetIdx, 0, moved);
                    renderGenericFileList(fileList, sprites, 'æ’åœ–');
                    renderGenericAttrSelect(attrSelect, sprites, attrSourceIdx, 'æ’åœ–');
                }
                dragIdx = null;
                // ç§»é™¤æ‰€æœ‰ drag-hover é¡åˆ¥
                fileList.querySelectorAll("li").forEach((li) => li.classList.remove("drag-hover"));
            });

            input.addEventListener('change', async e => {
                sprites = [];
                attrSelect.style.display = 'none';
                mergeBtn.style.display = 'none';
                fileList.innerHTML = '';
                const files = Array.from(input.files);
                for (const file of files) {
                    try {
                        const text = await file.text();
                        const data = JSON.parse(text);
                        sprites.push({file, data});
                    } catch {
                        showMessage(`æª”æ¡ˆ ${file.name} è§£æå¤±æ•—`, 'error');
                        return;
                    }
                }
                if (sprites.length < 2) {
                    showMessage('è«‹é¸æ“‡è‡³å°‘å…©å€‹æ’åœ–æª”æ¡ˆ', 'error');
                    return;
                }
                // æª¢æŸ¥é•·å¯¬ä¸€è‡´
                const w = sprites[0].data.width, h = sprites[0].data.height;
                if (!sprites.every(s => s.data.width === w && s.data.height === h)) {
                    showMessage('æ‰€æœ‰æ’åœ–çš„å¯¬é«˜å¿…é ˆä¸€è‡´ï¼', 'error');
                    return;
                }
                renderGenericFileList(fileList, sprites, 'æ’åœ–');
                renderGenericAttrSelect(attrSelect, sprites, attrSourceIdx, 'æ’åœ–');
                mergeBtn.style.display = '';
            });

            // ä½¿ç”¨é€šç”¨å‡½æ•¸ï¼Œç„¡éœ€é‡è¤‡å®šç¾©

            mergeBtn.onclick = function() {
                if (sprites.length < 2) {
                    showMessage('è«‹é¸æ“‡è‡³å°‘å…©å€‹æ’åœ–æª”æ¡ˆ', 'error');
                    return;
                }
                // è™•ç†å–®è‰²å’Œå¤šè‰²æ’åœ–çš„ frameList
                const colorFrameLists = sprites.map(s => {
                    // æª¢æŸ¥æ˜¯å¦ç‚ºå–®è‰²æ’åœ–ï¼ˆæœ‰ colorIndexï¼‰
                    if (s.data.colorIndex !== undefined) {
                        // å–®è‰²æ’åœ–ï¼šå°‡ 1 è½‰æ›ç‚º colorIndexï¼Œ0 ä¿æŒç‚º 0
                        const color = s.data.colorIndex;
                        return s.data.frameList.map(frame => frame.map(px => px === 1 ? color : 0));
                    } else {
                        // å¤šè‰²æ’åœ–ï¼šç›´æ¥ä½¿ç”¨åŸå§‹ frameListï¼ˆå·²ç¶“æ˜¯é¡è‰²å€¼ï¼‰
                        return s.data.frameList.map(frame => [...frame]);
                    }
                });
                // ====== æ–°å¢ï¼šå‹•ç•«å¹€è£œé½Š ======
                const maxFrameLen = Math.max(...colorFrameLists.map(frames => frames.length));
                const paddedColorFrameLists = colorFrameLists.map(frames => padFrames(frames, maxFrameLen));
                // ====== åˆä½µæ™‚ colorFrameLists æ›æˆ paddedColorFrameLists ======
                const w = sprites[0].data.width, h = sprites[0].data.height;
                const mergedFrameList = [];
                for (let f = 0; f < maxFrameLen; f++) {
                    const mergedFrame = [];
                    for (let i = 0; i < w * h; i++) {
                        let val = 0;
                        for (let sIdx = 0; sIdx < paddedColorFrameLists.length; sIdx++) {
                            const frameArr = paddedColorFrameLists[sIdx][f] || paddedColorFrameLists[sIdx][0];
                            if (frameArr[i] !== 0) val = frameArr[i];
                        }
                        mergedFrame.push(val);
                    }
                    mergedFrameList.push(mergedFrame);
                }
                // ç›´æ¥å¾ä¸‹æ‹‰é¸å–® DOM å–å€¼ï¼Œç¢ºä¿æ­£ç¢º
                const select = attrSelect.querySelector('select');
                const idx = select ? Number(select.value) : attrSourceIdx;
                const src = sprites[idx].data;
                // åˆä½µ picture ç‰©ä»¶ï¼Œæ‰€æœ‰æ¬„ä½éƒ½è¤‡è£½ä¾†æºï¼Œåªè¦†è“‹ frameList
                const merged = Object.assign({}, src, { frameList: mergedFrameList });
                
                // é¡¯ç¤ºåˆä½µå¾Œæ•¸æ“š
                const mergeOutput = document.getElementById("mergePictureOutput");
                mergeOutput.value = (merged && merged.frameList)
                    ? JSON.stringify(merged)
                    : JSON.stringify(merged, null, 4);
                mergeOutput.style.display = "block";
                
                // é¡¯ç¤ºä¸‹è¼‰æŒ‰éˆ•
                const mergeDownloadBtn = document.getElementById("mergePictureDownloadBtn");
                mergeDownloadBtn.style.display = "block";
                
                showMessage('æ’åœ–åˆä½µæˆåŠŸï¼', 'success');
            };
            
            // æ’åœ–åˆä½µä¸‹è¼‰æŒ‰éˆ•
            document.getElementById("mergePictureDownloadBtn").addEventListener("click", () => {
                const mergeOutput = document.getElementById("mergePictureOutput");
                const fileName = (sprites[attrSourceIdx].data.name || 'merged_picture').replace(/\.(json|mosigraphic)?$/, "") + ".mosigraphic";
                const content = JSON.stringify(JSON.parse(mergeOutput.value));
                const blob = new Blob([content], {type:'application/octet-stream'});
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = fileName;
                a.click();
                URL.revokeObjectURL(a.href);
            });
        })();

        // ===== æˆ¿é–“è½‰æ’åœ–å·¥å…· =====
        (function(){
            const input = document.getElementById('roomToPictureInput');
            const pictureBtn = document.getElementById('roomToPicturePictureBtn');
            let roomData = null;
            input.onchange = async function(e) {
                pictureBtn.style.display = 'none';
                if (!input.files[0]) return;
                try {
                    const text = await input.files[0].text();
                    roomData = JSON.parse(text);
                    pictureBtn.style.display = '';
                } catch {
                    showMessage('æª”æ¡ˆæ ¼å¼éŒ¯èª¤ï¼Œè«‹ä¸Šå‚³æ­£ç¢ºçš„ .mosiroom æª”æ¡ˆ', 'error');
                    roomData = null;
                }
            };
            pictureBtn.onclick = function() {
                if (!roomData) return;
                try {
                    const picture = roomToPictureData(roomData);
                    
                    // é¡¯ç¤ºè½‰æ›å¾Œæ•¸æ“š
                    const mergeOutput = document.getElementById("roomToPictureOutput");
                    mergeOutput.value = (picture && picture.frameList)
                        ? JSON.stringify(picture)
                        : JSON.stringify(picture, null, 4);
                    mergeOutput.style.display = "block";
                    
                    // é¡¯ç¤ºä¸‹è¼‰æŒ‰éˆ•
                    const mergeDownloadBtn = document.getElementById("roomToPictureDownloadBtn");
                    mergeDownloadBtn.style.display = "block";
                    
                    showMessage('æˆ¿é–“è½‰æ’åœ–æˆåŠŸï¼', 'success');
                } catch (e) {
                    showMessage('è½‰æ›å¤±æ•—ï¼š' + e.message, 'error');
                }
            };
            
            // æˆ¿é–“è½‰æ’åœ–ä¸‹è¼‰æŒ‰éˆ•
            document.getElementById("roomToPictureDownloadBtn").addEventListener("click", () => {
                const mergeOutput = document.getElementById("roomToPictureOutput");
                const fileName = (roomData.name || 'picture').replace(/\.(json|mosigraphic)?$/, "") + ".mosigraphic";
                const content = JSON.stringify(JSON.parse(mergeOutput.value));
                const blob = new Blob([content], {type:'application/octet-stream'});
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = fileName;
                a.click();
                URL.revokeObjectURL(a.href);
            });
            
            // æˆ¿é–“è½‰æ’åœ–å·¥å…·æ–‡å­—åŒ¯å…¥
            document.getElementById('roomToPictureTextImportBtn').onclick = function() {
                const text = document.getElementById('roomToPictureTextImport').value.trim();
                if (!text) {
                    showMessage('è«‹è²¼ä¸Šæˆ¿é–“æ•¸æ“š', 'error');
                    return;
                }
                try {
                    const data = JSON.parse(text);
                    roomData = data;
                    pictureBtn.style.display = '';
                    showMessage('æˆ¿é–“æ•¸æ“šåŒ¯å…¥æˆåŠŸ', 'success');
                } catch (err) {
                    showMessage('æˆ¿é–“æ•¸æ“šè§£æå¤±æ•—: ' + err.message, 'error');
                    roomData = null;
                }
            };
        })();

        // ========== æ‰‹æ©Ÿç‰ˆ tab åˆ†é¡ä¸‹æ‹‰é¸å–® ===========
        // å®šç¾©åˆ†é¡èˆ‡å­é …
        const tabCategories = [
          {
            label: 'åœ–ç‰‡å·¥å…·',
            value: 'img',
            children: [
              { label: 'åœ–ç‰‡ä¸Šå‚³', value: 'upload-img' },
              { label: 'ç²¾éˆè¨­å®š', value: 'sprite-settings' },
              { label: 'æˆ¿é–“è¨­å®š', value: 'room-settings' },
              { label: 'ç”Ÿæˆçµæœ', value: 'data' },
            ]
          },
          {
            label: 'åˆä½µå·¥å…·',
            value: 'merge',
            children: [
              { label: 'æˆ¿é–“åˆä½µå·¥å…·', value: 'merge-rooms' },
              { label: 'ç²¾éˆåˆä½µå·¥å…·', value: 'merge-sprite-section' },
              { label: 'æˆ¿é–“åˆä½µå–®è‰²ç²¾éˆå·¥å…·', value: 'merge-room-section' },
              { label: 'ä¸–ç•Œç´šåˆä½µå·¥å…·', value: 'merge-world-section' },
              { label: 'æ’åœ–åˆä½µå·¥å…·', value: 'merge-picture-section' },
            ]
          },
          {
            label: 'è½‰æ›å·¥å…·',
            value: 'convert',
            children: [
              { label: 'æˆ¿é–“è½‰æ’åœ–å·¥å…·', value: 'room-to-picture-section' },
              { label: 'å°è©±æ¡†çš®è†šè½‰æ›å·¥å…·', value: 'textbox-skin-section' },
            ]
          }
        ];

        // Tab åˆ‡æ›é‚è¼¯
        function setTab(tabId) {
            currentTabId = tabId;
            
            // ç§»é™¤èˆŠçš„ sticky/fixed äº‹ä»¶ç›£è½
            if (window.stickyScrollHandler) {
                window.removeEventListener('scroll', window.stickyScrollHandler);
                window.removeEventListener('resize', window.stickyScrollHandler);
                window.stickyScrollHandler = null;
            }
            if (window.stickyTabContentHandler) {
                const tabContent = document.querySelector('.tab-content');
                if (tabContent) {
                    tabContent.removeEventListener('scroll', window.stickyTabContentHandler);
                }
                window.removeEventListener('resize', window.stickyTabContentHandler);
                window.stickyTabContentHandler = null;
            }
            
            // åˆ‡æ›å…§å®¹
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-section').forEach(sec => sec.classList.remove('active'));
            const btn = document.querySelector('.tab-btn[data-tab="' + tabId + '"]');
            if (btn) btn.classList.add('active');
            const sec = document.getElementById(tabId);
            if (sec) sec.classList.add('active');
            // ====== æ¡Œé¢æ‰‹é¢¨ç´åŒæ­¥å±•é–‹/é«˜äº® ======
            // æ‰¾åˆ°è©² tab-btn æ‰€å±¬çš„ accordion-panel
            if (btn) {
                // 1. æ‰¾åˆ°æ‰€æœ‰ accordion-panelï¼Œå…¨éƒ¨æ”¶èµ·
                document.querySelectorAll('.accordion-panel').forEach(panel => {
                    panel.style.display = 'none';
                });
                // 2. æ‰¾åˆ°æ‰€æœ‰ accordion-btnï¼Œå…¨éƒ¨ç§»é™¤ active
                document.querySelectorAll('.accordion-btn').forEach(abtn => {
                    abtn.classList.remove('active');
                });
                // 3. å±•é–‹è©² tab-btn æ‰€å±¬çš„ accordion-panelï¼Œä¸¦é«˜äº®å°æ‡‰çš„ accordion-btn
                const panel = btn.closest('.accordion-panel');
                if (panel) {
                    panel.style.display = 'block';
                    const accordionBtn = panel.previousElementSibling;
                    if (accordionBtn && accordionBtn.classList.contains('accordion-btn')) {
                        accordionBtn.classList.add('active');
                    }
                }
            }
            // æ‰‹æ©Ÿä¸‹æ‹‰åŒæ­¥
            const tabSel = document.getElementById('tab-select');
            if (tabSel && tabSel.value !== tabId) {
                // æ‰¾åˆ°é€™å€‹ tabId å±¬æ–¼å“ªå€‹æ¯é¡åˆ¥
                let found = false;
                for (let cat of tabCategories) {
                    if (cat.children.some(child => child.value === tabId)) {
                        // è¨­å®šæ¯é¡åˆ¥
                        document.getElementById('tab-category-select').value = cat.value;
                        updateTabSelectByCategory(cat.value);
                        found = true;
                        break;
                    }
                }
                tabSel.value = tabId;
            }
            
            // åªåœ¨ upload-img åˆ†é åˆå§‹åŒ– sticky/fixed
            if (tabId === 'upload-img') {
                initStickyPreview();
            }
            
            updateColorIndexAndPaletteNameUI();
            updateCurrentPaletteStatus();
        }
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.onclick = function() {
                setTab(btn.dataset.tab);
            };
        });
        // éŸ¿æ‡‰å¼ä¸‹æ‹‰é¸å–®åˆ‡æ›
        document.getElementById('tab-select').addEventListener('change', function() {
            setTab(this.value);
        });
        // é è¨­é¡¯ç¤ºç¬¬ä¸€å€‹ tab
        setTab('upload-img');

        // Header é–‹åˆé‚è¼¯
        const headerBtn = document.getElementById('headerToggleBtn');
        const headerContent = document.getElementById('headerContent');
        let headerOpen = true;
        headerBtn.onclick = function() {
            headerOpen = !headerOpen;
            if (headerOpen) {
                headerContent.classList.remove('header-collapsed');
                headerBtn.classList.remove('rotate');
            } else {
                headerContent.classList.add('header-collapsed');
                headerBtn.classList.add('rotate');
            }
        };

        // ===== scriptList æœ‰æ•ˆæ€§åˆ¤æ–· =====
        function isScriptListValid(scriptList) {
            if (!scriptList || typeof scriptList !== 'object') return false;
            return Object.values(scriptList).some(v => typeof v === 'string' && v.trim() !== '');
        }

        // æ–°å¢ï¼šæ‰¹é‡è¨­å®šå€
        function renderBatchSpriteSettings() {
            const batchDiv = document.getElementById('batch-sprite-settings');
            if (!batchMode || !currentImages.length) {
                batchDiv.style.display = 'none';
                batchDiv.innerHTML = '';
                document.getElementById('spriteName').parentNode.style.display = '';
                document.getElementById('colorIndex').parentNode.style.display = '';
                return;
            }
            batchDiv.style.display = '';
            batchDiv.innerHTML = '<b>æ‰¹é‡è¨­å®šï¼š</b>';
            document.getElementById('spriteName').parentNode.style.display = 'none';
            document.getElementById('colorIndex').parentNode.style.display = 'none';
            // å»ºç«‹æ¯å¼µåœ–çš„è¨­å®šæ¬„
            currentImages.forEach((img, idx) => {
                // é è¨­åç¨±èˆ‡è‰²ç¢¼
                if (!img.spriteName) img.spriteName = `sprite${idx+1}`;
                if (!img.colorIndex) img.colorIndex = 1;
                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.alignItems = 'center';
                row.style.margin = '6px 0';
                // åœ–ç‰‡é è¦½
                const thumb = document.createElement('img');
                thumb.src = img.canvas.toDataURL();
                thumb.style.width = '32px';
                thumb.style.height = '32px';
                thumb.style.marginRight = '8px';
                // åç¨±è¼¸å…¥
                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.value = img.spriteName;
                nameInput.style.width = '6em';
                nameInput.oninput = e => { img.spriteName = e.target.value; };
                row.appendChild(thumb);
                const label1 = document.createElement('span');
                label1.textContent = 'åç¨±:';
                label1.style.margin = '0 4px';
                row.appendChild(label1);
                row.appendChild(nameInput);
                // é¡è‰²ç´¢å¼• select åªåœ¨å–®è‰²æ¨¡å¼é¡¯ç¤º
                if (!currentPalette) {
                  const label2 = document.createElement('span');
                  label2.textContent = 'é¡è‰²:';
                  label2.style.margin = '0 4px';
                  const colorSel = document.createElement('select');
                  for (let i=1; i<=7; i++) {
                      const opt = document.createElement('option');
                      opt.value = i;
                      opt.textContent = i;
                      if (i == img.colorIndex) opt.selected = true;
                      colorSel.appendChild(opt);
                  }
                  colorSel.onchange = e => { img.colorIndex = parseInt(e.target.value); };
                  row.appendChild(label2);
                  row.appendChild(colorSel);
                }
                batchDiv.appendChild(row);
            });
        }

        // æ–°å¢ processImageToPictureData å‡½æ•¸
        function processImageToPictureData(image, data) {
            const { width: imgWidth, height: imgHeight, context } = image;
            const { spriteWidth, spriteHeight, roomWidth, roomHeight } = data;
            const requiredWidth = roomWidth * spriteWidth;
            const requiredHeight = roomHeight * spriteHeight;
            let processedCanvas = image.canvas;
            let processedContext = image.context;
            let scale = 1;
            if (imgWidth !== requiredWidth || imgHeight !== requiredHeight) {
                const scaledCanvas = document.createElement('canvas');
                const scaledContext = scaledCanvas.getContext('2d');
                scaledCanvas.width = requiredWidth;
                scaledCanvas.height = requiredHeight;
                scaledContext.imageSmoothingEnabled = false;
                scaledContext.drawImage(image.canvas, 0, 0, requiredWidth, requiredHeight);
                processedCanvas = scaledCanvas;
                processedContext = scaledContext;
                scale = requiredWidth / imgWidth;
            }
            // å–®è‰²æ’åœ– frameList åªç”¨ 0/è‰²ç¢¼
            const pixels = processedContext.getImageData(0, 0, requiredWidth, requiredHeight).data;
            const frame = [];
            const colorIndex = data.colorIndex || 1;
            for (let i = 0; i < pixels.length; i += 4) {
                const alpha = pixels[i + 3];
                if (alpha < 128) {
                    frame.push(0);
                } else {
                    const gray = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
                    frame.push(gray < 128 ? colorIndex : 0);
                }
            }
            return {
                name: data.spriteName,
                type: 'picture',
                paletteName: data.paletteName,
                musicName: data.musicName,
                roomWidth: data.roomWidth,
                roomHeight: data.roomHeight,
                spriteWidth: data.spriteWidth,
                spriteHeight: data.spriteHeight,
                width: requiredWidth,
                height: requiredHeight,
                frameList: [frame],
                scriptList: {"on-show": "", "on-hide": ""}
            };
        }

        // ç¦ç”¨ç”ŸæˆæŒ‰éˆ•
        function disableGenerateButtons() {
            document.getElementById('generate-room-btn').disabled = true;
            document.getElementById('generate-picture-btn').disabled = true;
        }
        // å•Ÿç”¨ç”ŸæˆæŒ‰éˆ•
        function enableGenerateButtons() {
            document.getElementById('generate-room-btn').disabled = false;
            document.getElementById('generate-picture-btn').disabled = false;
        }

        // ===== æˆ¿é–“è½‰æ’åœ–ä¸»é‚è¼¯ =====
        function roomToPictureData(room) {
            // å–å¾—æˆ¿é–“åŸºæœ¬è³‡è¨Š
            const roomWidth = room.width || room.roomWidth;
            const roomHeight = room.height || room.roomHeight;
            const spriteWidth = room.spriteWidth;
            const spriteHeight = room.spriteHeight;
            const width = roomWidth * spriteWidth;
            const height = roomHeight * spriteHeight;
            // å»ºç«‹ spriteName->sprite æ˜ å°„ï¼Œä¸¦é è™•ç† colorFrameList
            const spriteMap = {};
            const colorFrameMap = {};
            (room.spriteList||[]).forEach(s => {
                spriteMap[s.name] = s;
                // é è™•ç†ï¼šå–®è‰²ç²¾éˆ frameList è½‰ colorIndexï¼Œå¤šè‰²ç›´æ¥è¤‡è£½
                if (s.colorIndex !== undefined) {
                    const color = s.colorIndex;
                    colorFrameMap[s.name] = s.frameList.map(frame => frame.map(px => px === 1 ? color : 0));
                } else {
                    colorFrameMap[s.name] = s.frameList.map(frame => [...frame]);
                }
            });
            // å–å¾—æœ€å¤§å‹•ç•«å¹€æ•¸
            let maxFrameLen = 1;
            Object.values(colorFrameMap).forEach(frames => {
                if (Array.isArray(frames)) maxFrameLen = Math.max(maxFrameLen, frames.length);
            });
            // ä½¿ç”¨å…¨åŸŸçš„ padFrames å‡½æ•¸
            const paddedColorFrameMap = {};
            Object.entries(colorFrameMap).forEach(([name, frames]) => {
                paddedColorFrameMap[name] = padFrames(frames, maxFrameLen);
            });
            // å°æ¯å€‹ tileï¼Œè¨˜éŒ„å…¶ sprite åŠåº§æ¨™
            const tileGrid = Array.from({length: roomHeight}, () => Array(roomWidth).fill(null));
            (room.tileList||[]).forEach(tile => {
                if (tile.x >= 0 && tile.x < roomWidth && tile.y >= 0 && tile.y < roomHeight) {
                    if (!tileGrid[tile.y][tile.x]) tileGrid[tile.y][tile.x] = [];
                    tileGrid[tile.y][tile.x].push(tile.spriteName);
                }
            });
            // ç”¢ç”Ÿæ¯ä¸€å¹€çš„å¤§åœ–
            const frameList = [];
            for (let f = 0; f < maxFrameLen; f++) {
                const frame = new Array(width * height).fill(0);
                for (let y = 0; y < roomHeight; y++) {
                    for (let x = 0; x < roomWidth; x++) {
                        const spriteNames = tileGrid[y][x] || [];
                        // ç–ŠåŠ æ‰€æœ‰ spriteï¼Œå¾Œè€…è¦†è“‹å‰è€…
                        for (let sIdx = 0; sIdx < spriteNames.length; sIdx++) {
                            const sprite = spriteMap[spriteNames[sIdx]];
                            if (!sprite) continue;
                            const paddedColorFrames = paddedColorFrameMap[spriteNames[sIdx]];
                            const spriteFrame = paddedColorFrames[f];
                            for (let sy = 0; sy < spriteHeight; sy++) {
                                for (let sx = 0; sx < spriteWidth; sx++) {
                                    const px = x * spriteWidth + sx;
                                    const py = y * spriteHeight + sy;
                                    const idx = py * width + px;
                                    const val = spriteFrame[sy * spriteWidth + sx];
                                    if (val !== 0) frame[idx] = val;
                                }
                            }
                        }
                    }
                }
                frameList.push(frame);
            }
            // scriptList è½‰æ›
            let scriptList = {};
            if (room.scriptList) {
                scriptList["on-show"] = room.scriptList["on-enter"] ?? "";
                scriptList["on-hide"] = room.scriptList["on-exit"] ?? "";
            } else {
                scriptList["on-show"] = "";
                scriptList["on-hide"] = "";
            }
            return {
                name: room.name || room.roomName || "picture",
                type: "picture",
                paletteName: room.paletteName || "palette-1",
                musicName: room.musicName || "song-1",
                roomWidth,
                roomHeight,
                spriteWidth,
                spriteHeight,
                width,
                height,
                frameList,
                scriptList
            };
        }

        // å°è©±æ¡†çš®è†šè½‰æ›å·¥å…· JS
        function readJsonFile(file) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = e => {
              try {
                resolve(JSON.parse(e.target.result));
              } catch (err) {
                reject('JSON è§£æå¤±æ•—: ' + err);
              }
            };
            reader.onerror = () => reject('æª”æ¡ˆè®€å–å¤±æ•—');
            reader.readAsText(file);
          });
        }

        function generateTextboxSkin(room, sprite) {
          // é©—è­‰æˆ¿é–“å°ºå¯¸
          if (room.width !== 3 || room.height !== 3) {
            throw new Error('æˆ¿é–“å°ºå¯¸å¿…é ˆç‚º 3x3');
          }
          // é©—è­‰æˆ¿é–“ç²¾éˆæ•¸é‡å¿…é ˆç‚º 9
          if (!Array.isArray(room.spriteList) || room.spriteList.length !== 9) {
            throw new Error('æˆ¿é–“å¿…é ˆå‰›å¥½æœ‰ 9 å€‹ç²¾éˆï¼ˆä¹å®®æ ¼ï¼‰');
          }
          // å–å¾—ç²¾éˆå°ºå¯¸
          const fontWidth = sprite.width;
          const fontHeight = sprite.height;

          // === é©—è­‰æ©Ÿåˆ¶è£œå…… ===
          // 2. æˆ¿é–“å…§æ‰€æœ‰ç²¾éˆ frameList é•·åº¦å¿…é ˆç‚º 1
          if (Array.isArray(room.spriteList)) {
            for (const spr of room.spriteList) {
              if (!Array.isArray(spr.frameList) || spr.frameList.length !== 1) {
                throw new Error(`æˆ¿é–“å…§ç²¾éˆã€Œ${spr.name || ''}ã€æœ‰å‹•ç•«å¹€ï¼Œè«‹ç¢ºä¿æ‰€æœ‰æˆ¿é–“ç²¾éˆåƒ…æœ‰ä¸€å¹€ï¼ˆframeList é•·åº¦ç‚º 1ï¼‰`);
              }
            }
          }
          // 3. æˆ¿é–“å…§æ‰€æœ‰ç²¾éˆ isTransparent å¿…é ˆä¸€è‡´
          let transparentSet = new Set();
          if (Array.isArray(room.spriteList)) {
            room.spriteList.forEach(spr => {
              if (typeof spr.isTransparent !== 'undefined') transparentSet.add(spr.isTransparent);
            });
          }
          if (transparentSet.size > 1) {
            throw new Error('æˆ¿é–“å…§æ‰€æœ‰ç²¾éˆçš„é€æ˜åŒ–å±¬æ€§ï¼ˆisTransparentï¼‰å¿…é ˆä¸€è‡´ï¼');
          }
          // å–å¾—çµ±ä¸€çš„ isTransparent å±¬æ€§ï¼ˆè‹¥ç„¡å‰‡é è¨­ falseï¼‰
          let isTransparent = transparentSet.size === 1 ? [...transparentSet][0] : 
          false;
          // 4. æˆ¿é–“å…§æ‰€æœ‰ç²¾éˆå°ºå¯¸å¿…é ˆä¸€è‡´
          let roomSpriteWidth = null, roomSpriteHeight = null;
          if (Array.isArray(room.spriteList) && room.spriteList.length > 0) {
            roomSpriteWidth = room.spriteList[0].width;
            roomSpriteHeight = room.spriteList[0].height;
            for (const spr of room.spriteList) {
              if (spr.width !== roomSpriteWidth || spr.height !== roomSpriteHeight) {
                throw new Error(`æˆ¿é–“å…§ç²¾éˆå°ºå¯¸ä¸ä¸€è‡´ï¼Œè«‹ç¢ºä¿æ‰€æœ‰æˆ¿é–“ç²¾éˆå°ºå¯¸ç›¸åŒï¼ˆ${roomSpriteWidth}x${roomSpriteHeight}ï¼‰`);
              }
            }
          }
          // 5. spriteï¼ˆç®­é ­ç²¾éˆï¼‰å°ºå¯¸å¿…é ˆèˆ‡æˆ¿é–“ç²¾éˆå°ºå¯¸ä¸€è‡´
          if (sprite.width !== roomSpriteWidth || sprite.height !== roomSpriteHeight) {
            throw new Error(`ç®­é ­ç²¾éˆå°ºå¯¸ï¼ˆ${sprite.width}x${sprite.height}ï¼‰å¿…é ˆèˆ‡æˆ¿é–“ç²¾éˆå°ºå¯¸ï¼ˆ${roomSpriteWidth}x${roomSpriteHeight}ï¼‰ä¸€è‡´ï¼`);
          }
          // === é©—è­‰æ©Ÿåˆ¶è£œå……çµæŸ ===

          // è™•ç† indicatorListï¼ˆç›´æ¥ç”¨ sprite æª”æ¡ˆçš„ frameListï¼Œè£œé½Šå‹•ç•«å¹€æ•¸ï¼‰
          let indicatorList = [];
          if (sprite.colorIndex !== undefined) {
            // å–®è‰²ç²¾éˆï¼šå°‡ 1 è½‰ colorIndexï¼Œ0 ä¿æŒ 0
            const color = sprite.colorIndex;
            indicatorList = padFrames(sprite.frameList.map(frame => frame.map(px => px === 1 ? color : 0)), sprite.frameList.length);
          } else {
            // å¤šè‰²ç²¾éˆï¼šç›´æ¥è¤‡è£½
            indicatorList = padFrames(sprite.frameList.map(frame => [...frame]), sprite.frameList.length);
          }

          // è™•ç† fillListï¼ˆä¹å®®æ ¼ï¼Œä¾ tileList ä½ç½®é †åºï¼Œå…§å®¹ç‚ºè©²æ ¼ç²¾éˆçš„ frameList ç¶“ padFrames å¾Œåˆä½µæˆä¸€ç¶­é™£åˆ—ï¼‰
          // ä¹å®®æ ¼é †åºï¼š0,0â†’0 1,0â†’1 2,0â†’2 0,1â†’3 1,1â†’4 2,1â†’5 0,2â†’6 1,2â†’7 2,2â†’8
          const fillList = [];
          for (let y = 0; y < 3; y++) {
            for (let x = 0; x < 3; x++) {
              // æ‰¾åˆ° tileList ä¸­å°æ‡‰ (x, y) çš„ç²¾éˆ index
              let spriteIdx = null;
              if (Array.isArray(room.tileList)) {
                // æ”¯æ´äºŒç¶­é™£åˆ—æˆ–ç‰©ä»¶é™£åˆ—
                if (Array.isArray(room.tileList[0])) {
                  spriteIdx = room.tileList[y][x];
                } else {
                  // ç‰©ä»¶é™£åˆ—æ ¼å¼
                  const tile = room.tileList.find(t => t.x === x && t.y === y);
                  spriteIdx = tile ? tile.spriteIndex || tile.sprite || tile.spriteName || 0 : 0;
                }
              }
              // å–å¾—å°æ‡‰ç²¾éˆ
              let spr = null;
              if (Array.isArray(room.spriteList)) {
                if (typeof spriteIdx === 'number') {
                  spr = room.spriteList[spriteIdx];
                } else if (typeof spriteIdx === 'string') {
                  spr = room.spriteList.find(s => s.name === spriteIdx);
                }
              }
              if (!spr) {
                fillList.push([]);
                continue;
              }
              // è™•ç†å–®è‰²/å¤šè‰²ç²¾éˆ
              let frames;
              if (spr.colorIndex !== undefined) {
                const color = spr.colorIndex;
                frames = padFrames(spr.frameList.map(frame => frame.map(px => px === 1 ? color : 0)), spr.frameList.length);
              } else {
                frames = padFrames(spr.frameList.map(frame => [...frame]), spr.frameList.length);
              }
              // åˆä½µæ‰€æœ‰å¹€æˆä¸€ç¶­é™£åˆ—
              fillList.push([].concat(...frames));
            }
          }

          // name: æˆ¿é–“åç¨±
          const name = room.name || room.roomName || 'æ–°å°è©±æ¡†çš®è†š';
          return {
            name,
            isTransparent,
            fontWidth,
            fontHeight,
            fillList,
            indicatorList
          };
        }

        // ä¿®æ­£ä¸‹è¼‰æ™‚å£“æˆä¸€è¡Œ
        const oldTextboxSkinBtn = document.getElementById('convertTextboxSkinBtn').onclick;
        document.getElementById('convertTextboxSkinBtn').onclick = async function() {
          const roomFile = document.getElementById('roomFile').files[0];
          const spriteFile = document.getElementById('spriteFile').files[0];
          
          let room, sprite;
          
          // æª¢æŸ¥æ˜¯å¦æœ‰æ–‡å­—åŒ¯å…¥çš„æ•¸æ“š
          if (window.importedRoomData && window.importedSpriteData) {
            room = window.importedRoomData;
            sprite = window.importedSpriteData;
          } else if (roomFile && spriteFile) {
            // ä½¿ç”¨æª”æ¡ˆä¸Šå‚³çš„æ•¸æ“š
            try {
              [room, sprite] = await Promise.all([
                readJsonFile(roomFile),
                readJsonFile(spriteFile)
              ]);
            } catch (err) {
              showMessage('æª”æ¡ˆè®€å–å¤±æ•—ï¼š' + err.message, 'error');
              return;
            }
          } else {
            showMessage('è«‹é¸æ“‡ .mosiroom èˆ‡ .mosisprite æª”æ¡ˆï¼Œæˆ–ä½¿ç”¨æ–‡å­—åŒ¯å…¥åŠŸèƒ½', 'error');
            return;
          }
          
          try {
            const skin = generateTextboxSkin(room, sprite);
            
            // é¡¯ç¤ºè½‰æ›å¾Œæ•¸æ“š
            const mergeOutput = document.getElementById("textboxSkinOutput");
            mergeOutput.value = (skin && (skin.fillList || skin.indicatorList))
                ? JSON.stringify(skin)
                : JSON.stringify(skin, null, 4);
            mergeOutput.style.display = "block";
            
            // é¡¯ç¤ºä¸‹è¼‰æŒ‰éˆ•
            const mergeDownloadBtn = document.getElementById("textboxSkinDownloadBtn");
            mergeDownloadBtn.style.display = "block";
            
            showMessage('å°è©±æ¡†çš®è†šè½‰æ›æˆåŠŸï¼', 'success');
          } catch (err) {
            showMessage('è½‰æ›å¤±æ•—ï¼š' + err.message, 'error');
          }
        };
        
        // å°è©±æ¡†çš®è†šè½‰æ›ä¸‹è¼‰æŒ‰éˆ•
        document.getElementById("textboxSkinDownloadBtn").addEventListener("click", () => {
          const mergeOutput = document.getElementById("textboxSkinOutput");
          const skin = JSON.parse(mergeOutput.value);
          const blob = new Blob([JSON.stringify(skin)], {type: 'application/octet-stream'});
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `${skin.name}.mositextbox`;
          document.body.appendChild(a);
          a.click();
          setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          }, 100);
        });
        
        // å°è©±æ¡†çš®è†šè½‰æ›å·¥å…·æ–‡å­—åŒ¯å…¥
        document.getElementById('textboxSkinRoomTextImportBtn').onclick = function() {
            const text = document.getElementById('textboxSkinRoomTextImport').value.trim();
            if (!text) {
                showMessage('è«‹è²¼ä¸Šæˆ¿é–“æ•¸æ“š', 'error');
                return;
            }
            try {
                const data = JSON.parse(text);
                // å°‡æˆ¿é–“æ•¸æ“šå­˜å„²åˆ°å…¨åŸŸè®Šæ•¸ï¼Œä¾›è½‰æ›æŒ‰éˆ•ä½¿ç”¨
                window.importedRoomData = data;
                showMessage('æˆ¿é–“æ•¸æ“šåŒ¯å…¥æˆåŠŸ', 'success');
            } catch (err) {
                showMessage('æˆ¿é–“æ•¸æ“šè§£æå¤±æ•—: ' + err.message, 'error');
                window.importedRoomData = null;
            }
        };
        
        document.getElementById('textboxSkinSpriteTextImportBtn').onclick = function() {
            const text = document.getElementById('textboxSkinSpriteTextImport').value.trim();
            if (!text) {
                showMessage('è«‹è²¼ä¸Šç²¾éˆæ•¸æ“š', 'error');
                return;
            }
            try {
                const data = JSON.parse(text);
                // å°‡ç²¾éˆæ•¸æ“šå­˜å„²åˆ°å…¨åŸŸè®Šæ•¸ï¼Œä¾›è½‰æ›æŒ‰éˆ•ä½¿ç”¨
                window.importedSpriteData = data;
                showMessage('ç²¾éˆæ•¸æ“šåŒ¯å…¥æˆåŠŸ', 'success');
            } catch (err) {
                showMessage('ç²¾éˆæ•¸æ“šè§£æå¤±æ•—: ' + err.message, 'error');
                window.importedSpriteData = null;
            }
        };

        // Accordion æ‰‹é¢¨ç´å±•é–‹/æ”¶åˆé‚è¼¯
        document.querySelectorAll('.accordion-btn').forEach((btn, idx) => {
            btn.onclick = function() {
                const panel = btn.nextElementSibling;
                const isOpen = btn.classList.contains('active');
                // é—œé–‰æ‰€æœ‰
                document.querySelectorAll('.accordion-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.accordion-panel').forEach(p => p.style.display = 'none');
                // å¦‚æœåŸæœ¬æ²’é–‹ï¼Œå‰‡æ‰“é–‹
                if (!isOpen) {
                    btn.classList.add('active');
                    panel.style.display = 'block'; // é€™è£¡ç”± flex æ”¹ç‚º block
                }
            };
        });
        // é è¨­å±•é–‹ç¬¬ä¸€å€‹åˆ†é¡
        document.querySelectorAll('.accordion-btn')[0].classList.add('active');
        document.querySelectorAll('.accordion-panel')[0].style.display = 'block';

        // palette æª”æ¡ˆä¸Šå‚³äº‹ä»¶
        document.getElementById('paletteFile').addEventListener('change', async function(e) {
          const file = e.target.files[0];
          if (!file) return;
          try {
            const reader = new FileReader();
            reader.onload = function(ev) {
              try {
                const obj = JSON.parse(ev.target.result);
                paletteName = obj.name || "palette";
                let colorList = obj.colorList || [];
                // ç›´æ¥ä½¿ç”¨åŸå§‹é¡è‰²ï¼Œä¸é€²è¡Œæ™ºèƒ½å»é‡
                if (colorList.length < 2) {
                  showMessage('èª¿è‰²ç›¤é¡è‰²æ•¸é‡éœ€è‡³å°‘2è‰²', 'error');
                  currentPalette = null;
                  paletteName = "";
                  showPalettePreview([]);
                  return;
                }
                // ç¢ºä¿ currentPalette æ˜¯ RGB é™£åˆ—æ ¼å¼
                currentPalette = colorList.map(color => {
                  if (Array.isArray(color)) {
                    return color;
                  } else if (typeof color === 'string') {
                    return hexToRgb(color);
                  } else {
                    return [0, 0, 0];
                  }
                });
                showPalettePreview(currentPalette);
                showMessage('èª¿è‰²ç›¤è¼‰å…¥æˆåŠŸ', 'success');
                // åœ¨æˆåŠŸè¼‰å…¥å¾Œæ›´æ–°ç‹€æ…‹é¡¯ç¤º
                updateColorIndexAndPaletteNameUI();
                updateCurrentPaletteStatus();
                renderBatchSpriteSettings();
                // é‡æ–°è™•ç†æ‰€æœ‰å·²è¼‰å…¥çš„åœ–ç‰‡ä»¥æ‡‰ç”¨æ–°çš„èª¿è‰²ç›¤
                reprocessImagesWithPalette();
                // èª¿è‰²ç›¤è¼‰å…¥å¾Œè‡ªå‹•åˆ‡æ›åˆ° canvas é è¦½
                showingCanvas = true;
                updatePreview();
              } catch (err) {
                showMessage('palette è§£æå¤±æ•—: ' + err, 'error');
                currentPalette = null;
                paletteName = "";
                showPalettePreview([]);
                updateColorIndexAndPaletteNameUI();
                updateCurrentPaletteStatus();
              }
            };
            reader.readAsText(file);
          } catch (err) {
            showMessage('palette æª”æ¡ˆè®€å–å¤±æ•—', 'error');
            currentPalette = null;
            paletteName = "";
            showPalettePreview([]);
            updateColorIndexAndPaletteNameUI();
            updateCurrentPaletteStatus();
          }
        });
        function hexToRgb(hex) {
          hex = hex.replace('#', '');
          if (hex.length === 3) hex = hex.split('').map(x => x + x).join('');
          const num = parseInt(hex, 16);
          return [num >> 16 & 255, num >> 8 & 255, num & 255];
        }
        function showPalettePreview(colorList) {
          const div = document.getElementById('palette-preview');
          if (!colorList || colorList.length === 0) {
            div.innerHTML = '';
            div.style.display = 'none';
            return;
          }
          div.style.display = 'block';
          div.innerHTML = colorList.map(c => {
            // è™•ç†ä¸åŒæ ¼å¼çš„é¡è‰²ï¼šRGBé™£åˆ—æˆ–åå…­é€²åˆ¶å­—ä¸²
            let rgb;
            if (Array.isArray(c)) {
              rgb = c;
            } else if (typeof c === 'string') {
              rgb = hexToRgb(c);
            } else {
              return '';
            }
            return `<span style="display:inline-block;width:24px;height:24px;background:rgb(${rgb.join(',')});margin-right:2px;"></span>`;
          }).join('');
        }
        // ===== åœ–ç‰‡è‰²éšåŒ–ï¼ˆpaletteï¼‰ =====
        function quantizeToPalette(imageData, palette, useHsl = false) {
          let paletteColors, pixelColor;
          
          if (useHsl) {
            // ä½¿ç”¨ HSL è‰²å½©ç©ºé–“
            paletteColors = palette.map(([r, g, b]) => rgbToHsl(r, g, b));
          } else {
            // ä½¿ç”¨ LAB è‰²å½©ç©ºé–“ï¼ˆé è¨­ï¼‰
            paletteColors = palette.map(([r, g, b]) => rgbToLab(r, g, b));
          }
          
          const result = [];
          for (let i = 0; i < imageData.length; i += 4) {
            const r = imageData[i], g = imageData[i+1], b = imageData[i+2], a = imageData[i+3];
            if (a < 128) {
              result.push(0); // é€æ˜æ­¸ 0
              continue;
            }
            
            if (useHsl) {
              pixelColor = rgbToHsl(r, g, b);
            } else {
              pixelColor = rgbToLab(r, g, b);
            }
            
            let minDist = Infinity, idx = 0;
            for (let j = 0; j < paletteColors.length; j++) {
              let dist;
              if (useHsl) {
                // HSL è·é›¢è¨ˆç®—ï¼ˆè€ƒæ…®è‰²ç›¸ç’°ï¼‰
                const hueDiff = Math.abs(pixelColor[0] - paletteColors[j][0]);
                const satDiff = Math.abs(pixelColor[1] - paletteColors[j][1]);
                const lightDiff = Math.abs(pixelColor[2] - paletteColors[j][2]);
                
                // è‰²ç›¸å·®ç•°éœ€è¦è€ƒæ…®ç’°å½¢è·é›¢
                const hueDist = Math.min(hueDiff, 360 - hueDiff);
                dist = Math.sqrt(hueDist * hueDist + satDiff * satDiff + lightDiff * lightDiff);
              } else {
                dist = labDist(pixelColor, paletteColors[j]);
              }
              
              if (dist < minDist) { minDist = dist; idx = j; }
            }
            result.push(idx);
          }
          return result;
        }
        function drawQuantizedPreview(canvas, width, height, quantized, palette) {
          const ctx = canvas.getContext('2d');
          const imgData = ctx.createImageData(width, height);
          for (let i = 0; i < quantized.length; i++) {
            const idx = quantized[i];
            const [r, g, b] = palette[idx] || [0,0,0];
            imgData.data[i*4] = r;
            imgData.data[i*4+1] = g;
            imgData.data[i*4+2] = b;
            imgData.data[i*4+3] = 255;
          }
          ctx.putImageData(imgData, 0, 0);
        }

        // ===== å¤šè‰²æ¨¡å¼ï¼šquantized è½‰æˆ¿é–“/æ’åœ–æ•¸æ“š =====
        function processQuantizedToRoomData(image, data, palette) {
          // å…ˆç”¨ data è§£æ§‹è®Šæ•¸
          const { spriteWidth, spriteHeight, roomWidth, roomHeight } = data;
          
          // ç›´æ¥ç”¨ quantized é™£åˆ—åˆ‡å‰²æˆ tileList èˆ‡ spriteList
          const { quantized, quantizedWidth, quantizedHeight } = image;
          const requiredWidth = roomWidth * spriteWidth;
          const requiredHeight = roomHeight * spriteHeight;
          // è‹¥ quantized å°ºå¯¸èˆ‡éœ€æ±‚ä¸åŒï¼Œéœ€ç¸®æ”¾
          let qArr = quantized;
          let w = quantizedWidth, h = quantizedHeight;
          if (w !== requiredWidth || h !== requiredHeight) {
            // æœ€è¿‘é„°ç¸®æ”¾
            qArr = new Array(requiredWidth * requiredHeight);
            for (let y = 0; y < requiredHeight; y++) {
              for (let x = 0; x < requiredWidth; x++) {
                const srcX = Math.floor(x * w / requiredWidth);
                const srcY = Math.floor(y * h / requiredHeight);
                qArr[y * requiredWidth + x] = quantized[srcY * w + srcX];
              }
            }
            w = requiredWidth; h = requiredHeight;
          }
          // åˆ‡å‰²æˆ sprite
          const spritesPerRow = Math.floor(w / spriteWidth);
          const totalSprites = spritesPerRow * Math.floor(h / spriteHeight);

          if (roomWidth * roomHeight > totalSprites) {
            throw new Error(`æˆ¿é–“å°ºå¯¸éå¤§ï¼Œåœ–ç‰‡åªèƒ½æä¾› ${totalSprites} å€‹ç²¾éˆï¼Œä½†æˆ¿é–“éœ€è¦ ${roomWidth * roomHeight} å€‹`);
          }
          const spriteData = [];
          const tileList = [];
          const uniqueSprites = new Map();
          let validSpriteCount = 0;
          for (let spriteIndex = 0; spriteIndex < roomWidth * roomHeight; spriteIndex++) {
            const x = (spriteIndex % spritesPerRow) * spriteWidth;
            const y = Math.floor(spriteIndex / spritesPerRow) * spriteHeight;

            // å–å¾—ç²¾éˆå€åŸŸçš„ quantized
            const frame = [];
            try {
              for (let sy = 0; sy < spriteHeight; sy++) {
                for (let sx = 0; sx < spriteWidth; sx++) {
                  const index = (y+sy)*w + (x+sx);
                  if (index >= qArr.length) {
                    console.error('ç´¢å¼•è¶…å‡ºç¯„åœ:', { index, qArrLength: qArr.length, y, sy, x, sx, w });
                    throw new Error(`ç´¢å¼•è¶…å‡ºç¯„åœ: ${index} >= ${qArr.length}`);
                  }
                  frame.push(qArr[index]);
                }
              }
            } catch (error) {
              console.error('è™•ç†ç²¾éˆæ™‚å‡ºéŒ¯:', error);
              throw error;
            }
            // æª¢æŸ¥æ˜¯å¦ç‚ºå…¨é€æ˜
            if (frame.some(px => px !== 0)) {
              const key = frame.join(',');
              if (!uniqueSprites.has(key)) {
                validSpriteCount++;
                const spriteName = `${data.spriteName}-${validSpriteCount.toString().padStart(2, '0')}`;
                uniqueSprites.set(key, spriteName);
                spriteData.push({
                  name: spriteName,
                  isAvatar: data.isAvatar,
                  isWall: data.isWall,
                  isItem: data.isItem,
                  isTransparent: data.isTransparent,
                  width: spriteWidth,
                  height: spriteHeight,
                  frameList: [frame],
                  scriptList: {"on-push": "", "on-message": ""}
                });
              }
              tileList.push({
                spriteName: uniqueSprites.get(key),
                x: spriteIndex % roomWidth,
                y: Math.floor(spriteIndex / roomWidth)
              });
            }
          }

          return {
            name: data.roomName,
            paletteName: data.paletteName,
            musicName: data.musicName,
            tileList: tileList,
            scriptList: {"on-enter": "", "on-exit": ""},
            width: roomWidth,
            height: roomHeight,
            spriteWidth: spriteWidth,
            spriteHeight: spriteHeight,
            spriteList: spriteData
          };
        }
        function processQuantizedToPictureData(image, data, palette) {
          const { quantized, quantizedWidth, quantizedHeight } = image;
          const { spriteWidth, spriteHeight, roomWidth, roomHeight } = data;
          const requiredWidth = roomWidth * spriteWidth;
          const requiredHeight = roomHeight * spriteHeight;
          let qArr = quantized;
          let w = quantizedWidth, h = quantizedHeight;
          if (w !== requiredWidth || h !== requiredHeight) {
            // æœ€è¿‘é„°ç¸®æ”¾
            qArr = new Array(requiredWidth * requiredHeight);
            for (let y = 0; y < requiredHeight; y++) {
              for (let x = 0; x < requiredWidth; x++) {
                const srcX = Math.floor(x * w / requiredWidth);
                const srcY = Math.floor(y * h / requiredHeight);
                qArr[y * requiredWidth + x] = quantized[srcY * w + srcX];
              }
            }
            w = requiredWidth; h = requiredHeight;
          }
          return {
            name: data.spriteName,
            type: 'picture',
            paletteName: data.paletteName,
            musicName: data.musicName,
            roomWidth: data.roomWidth,
            roomHeight: data.roomHeight,
            spriteWidth: data.spriteWidth,
            spriteHeight: data.spriteHeight,
            width: requiredWidth,
            height: requiredHeight,
            frameList: [qArr],
            scriptList: {"on-show": "", "on-hide": ""}
          };
        }


        // åœ¨åœ–ç‰‡ä¸Šå‚³å®Œæˆã€æˆ– batchMode æ™‚å‘¼å« updatePreview()
        // å–®åœ–æ¨¡å¼
        if (!batchMode) {
          currentPreviewIndex = 0;
          updatePreview();
        }
        // æ‰¹é‡æ¨¡å¼ä¸‹é å…ˆè¼‰å…¥æ‰€æœ‰åœ–ç‰‡
        if (batchMode) {
            let loaded = 0;
            currentImages = new Array(files.length);
            files.forEach((file, idx) => {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    currentImages[idx] = {
                        width: img.width,
                        height: img.height,
                        canvas: canvas,
                        context: ctx,
                        fileName: file.name,
                        spriteName: `sprite${idx+1}`,
                        colorIndex: 1
                    };
                    // ===== æ–°å¢ï¼šå¤šåœ–ä¹Ÿè¦ quantized =====
                    if (currentPalette) {
                        const imgData = ctx.getImageData(0, 0, img.width, img.height);
                        // æ ¹æ“šç”¨æˆ¶é¸æ“‡çš„è‰²å½©ç©ºé–“é€²è¡Œè‰²éšåŒ–
                        const quantizeMethod = document.getElementById('quantizeMethod').value;
                        const useHsl = quantizeMethod === 'hsl';
                        currentImages[idx].quantized = quantizeToPalette(imgData.data, currentPalette, useHsl);
                        currentImages[idx].quantizedWidth = img.width;
                        currentImages[idx].quantizedHeight = img.height;
                        
                    }
                    loaded++;
                    if (loaded === files.length) {
                        allImagesLoaded = true;
                        enableGenerateButtons();
                        showMessage('æ‰€æœ‰åœ–ç‰‡å·²è¼‰å…¥å®Œæˆï¼Œå¯ç”Ÿæˆæ•¸æ“š', 'success');
                        renderBatchSpriteSettings();
                        currentPreviewIndex = 0;
                        updatePreview();
                        updateColorIndexAndPaletteNameUI();
                        updateCurrentPaletteStatus();
                        showAutoPaletteSection(true);
                    }
                };
                img.onerror = function() {
                    showMessage(`ç¬¬${idx+1}å¼µåœ–ç‰‡è¼‰å…¥å¤±æ•—`, 'error');
                };
                img.src = URL.createObjectURL(file);
            });
        }

        // æ–°å¢ï¼šæ›´æ–°ç•¶å‰èª¿è‰²ç›¤ç‹€æ…‹é¡¯ç¤º
        function updateCurrentPaletteStatus() {
          const statusElement = document.getElementById('current-palette-name');
          if (statusElement) {
            if (currentPalette && paletteName) {
              statusElement.textContent = paletteName;
              statusElement.style.color = 'var(--secondary-color)';
            } else {
              statusElement.textContent = 'ç„¡';
              statusElement.style.color = 'var(--secondary-color)';
            }
          }
        }

        // æ–°å¢ï¼špalette æ§åˆ¶é¡è‰²ç´¢å¼•èˆ‡ paletteName UI é¡¯ç¤º/éš±è—
        function updateColorIndexAndPaletteNameUI() {
          const colorIndexRow = document.getElementById('colorIndex').parentNode;
          const paletteNameRow = document.getElementById('paletteName').parentNode;
          const batchDiv = document.getElementById('batch-sprite-settings');
          
          if (currentPalette) {
            // å¤šè‰²æ¨¡å¼
            colorIndexRow.style.display = 'none';
            if (paletteNameRow) paletteNameRow.style.display = 'none';
            // å¤šåœ–æ¨¡å¼ä¸‹é¡¯ç¤ºæ‰¹é‡è¨­å®šå€ï¼ˆä½†ä¸é¡¯ç¤ºé¡è‰²ç´¢å¼•ï¼‰
            if (batchDiv) batchDiv.style.display = batchMode ? '' : 'none';
          } else {
            // å–®è‰²æ¨¡å¼
            if (batchMode) {
              // å¤šåœ–æ¨¡å¼ï¼šéš±è—é è¨­é¡è‰²ç´¢å¼•ï¼Œé¡¯ç¤ºæ‰¹é‡è¨­å®šå€
              colorIndexRow.style.display = 'none';
              if (batchDiv) batchDiv.style.display = '';
            } else {
              // å–®åœ–æ¨¡å¼ï¼šé¡¯ç¤ºé è¨­é¡è‰²ç´¢å¼•ï¼Œéš±è—æ‰¹é‡è¨­å®šå€
              colorIndexRow.style.display = '';
              if (batchDiv) batchDiv.style.display = 'none';
            }
            if (paletteNameRow) paletteNameRow.style.display = '';
          }
        }



        function showAutoPaletteSection(show) {
          document.getElementById('auto-palette-section').style.display = show ? '' : 'none';
        }
        function rgbToHex(r,g,b) {
          return '#' + [r,g,b].map(x => x.toString(16).padStart(2,'0')).join('');
        }
        // å°‡ getMostFrequentColors æ›æˆç°¡æ˜“åˆ†ç¾¤æ³•
        function getPaletteByQuantize(imageData, maxColors=8, quant=32) {
          const colorMap = {};
          for (let i=0; i<imageData.length; i+=4) {
            const a = imageData[i+3];
            if (a < 128) continue;
            const r = Math.round(imageData[i] / quant) * quant;
            const g = Math.round(imageData[i+1] / quant) * quant;
            const b = Math.round(imageData[i+2] / quant) * quant;
            const key = `${r},${g},${b}`;
            colorMap[key] = (colorMap[key]||0)+1;
          }
          const sorted = Object.entries(colorMap).sort((a,b)=>b[1]-a[1]);
          return sorted.slice(0, maxColors).map(([k]) => {
            const [r,g,b] = k.split(',').map(Number);
            return rgbToHex(r,g,b);
          });
        }
        // æ–°å¢ç°¡æ˜“ k-means åˆ†ç¾¤å‡½æ•¸
        function getPaletteKMeans(imageData, maxColors=16, maxIter=10) {
          const pixels = [];
          for (let i=0; i<imageData.length; i+=4) {
            if (imageData[i+3] < 128) continue;
            pixels.push([imageData[i], imageData[i+1], imageData[i+2]]);
          }
          if (pixels.length === 0) return ['var(--main-color)', 'var(--bg-color)'];
          // éš¨æ©Ÿåˆå§‹åŒ–ä¸­å¿ƒ
          const centers = [];
          for (let i=0; i<maxColors; i++) {
            centers.push(pixels[Math.floor(Math.random()*pixels.length)].slice());
          }
          for (let iter=0; iter<maxIter; iter++) {
            // åˆ†é…æ¯å€‹åƒç´ åˆ°æœ€è¿‘ä¸­å¿ƒ
            const clusters = Array.from({length:maxColors}, ()=>[]);
            for (const p of pixels) {
              let minDist = Infinity, idx = 0;
              for (let c=0; c<maxColors; c++) {
                const d = (p[0]-centers[c][0])**2 + (p[1]-centers[c][1])**2 + (p[2]-centers[c][2])**2;
                if (d < minDist) { minDist = d; idx = c; }
              }
              clusters[idx].push(p);
            }
            // æ›´æ–°ä¸­å¿ƒ
            for (let c=0; c<maxColors; c++) {
              if (clusters[c].length === 0) continue;
              const sum = clusters[c].reduce((a,b)=>[a[0]+b[0],a[1]+b[1],a[2]+b[2]],[0,0,0]);
              centers[c] = sum.map(x=>Math.round(x/clusters[c].length));
            }
          }
          // ===== æ–°å¢ï¼šä¾æ¯å€‹ä¸­å¿ƒçš„åƒç´ æ•¸é‡æ’åºï¼ˆä¸»è‰²å„ªå…ˆï¼‰ =====
          // çµ±è¨ˆæ¯å€‹ä¸­å¿ƒçš„åƒç´ æ•¸é‡
          const countArr = new Array(maxColors).fill(0);
          for (const p of pixels) {
            let minDist = Infinity, idx = 0;
            for (let c=0; c<maxColors; c++) {
              const d = (p[0]-centers[c][0])**2 + (p[1]-centers[c][1])**2 + (p[2]-centers[c][2])**2;
              if (d < minDist) { minDist = d; idx = c; }
            }
            countArr[idx]++;
          }
          // ä¾ç…§æ•¸é‡æ’åº
          const centerWithCount = centers.map((c,i)=>({color:c, count:countArr[i]}));
          centerWithCount.sort((a,b)=>b.count-a.count);
          // è½‰ HEX
          return centerWithCount.map(obj=>rgbToHex(obj.color[0],obj.color[1],obj.color[2]));
        }
        function hexToRgbArr(hex) {
          hex = hex.replace('#','');
          if (hex.length === 3) hex = hex.split('').map(x=>x+x).join('');
          const num = parseInt(hex, 16);
          return [num>>16&255, num>>8&255, num&255];
        }
        // åªåšå–®ç´” 8 è‰²åˆ†æ•£ï¼Œä¸ä¿ç•™ä¸»è‰²
        function distinctColorsMaxDistance(colors, maxColors=8) {
          if (!colors.length) return [];
          const arr = colors.map(c => Array.isArray(c) ? c : hexToRgbArr(c));
          const result = [arr[0]];
          for (let i = 1; i < arr.length && result.length < maxColors; i++) {
            let tooClose = false;
            for (let j = 0; j < result.length; j++) {
              if (colorDist(result[j], arr[i]) < 40) { tooClose = true; break; }
            }
            if (!tooClose) result.push(arr[i]);
          }
          // å¦‚æœé‚„ä¸å¤  8 è‰²ï¼Œéš¨ä¾¿è£œ
          for (let i = 0; i < arr.length && result.length < maxColors; i++) {
            let already = false;
            for (let j = 0; j < result.length; j++) {
              if (colorDist(result[j], arr[i]) < 1) { already = true; break; }
            }
            if (!already) result.push(arr[i]);
          }
          return result;
        }
        function colorDist(a, b) {
          return Math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2 + (a[2]-b[2])**2);
        }
        
        // ===== æ–°å¢ï¼šRGB è½‰ HSL å‡½æ•¸ =====
        function rgbToHsl(r, g, b) {
          r /= 255;
          g /= 255;
          b /= 255;
          
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h, s, l = (max + min) / 2;
          
          if (max === min) {
            h = s = 0; // ç„¡è‰²ç›¸
          } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            
            switch (max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
          }
          
          return [h * 360, s * 100, l * 100]; // è‰²ç›¸(0-360), é£½å’Œåº¦(0-100), æ˜åº¦(0-100)
        }
        
        // ===== æ–°å¢ï¼šHSL è½‰ RGB å‡½æ•¸ =====
        function hslToRgb(h, s, l) {
          h /= 360;
          s /= 100;
          l /= 100;
          
          const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
          };
          
          let r, g, b;
          
          if (s === 0) {
            r = g = b = l; // ç„¡è‰²ç›¸
          } else {
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
          }
          
          return [
            Math.round(r * 255),
            Math.round(g * 255),
            Math.round(b * 255)
          ];
        }
        
                 // ===== æ–°å¢ï¼šæ™ºèƒ½é¡è‰²é¸æ“‡å‡½æ•¸ =====
                  function smartColorSelection(colors, maxColors=8) {
                      if (!colors.length) return [];
           
           // ç°¡åŒ–çš„å»é‡è™•ç†ï¼šä½¿ç”¨æ›´ç›´æ¥çš„ RGB è·é›¢æª¢æ¸¬
           const uniqueColors = [];
           for (const color of colors) {
             const rgb = Array.isArray(color) ? color : hexToRgbArr(color);
             
             // æª¢æŸ¥æ˜¯å¦èˆ‡å·²å­˜åœ¨çš„é¡è‰²éæ–¼ç›¸ä¼¼
             let isDuplicate = false;
             for (const existing of uniqueColors) {
               const existingRgb = Array.isArray(existing) ? existing : hexToRgbArr(existing);
               
               // ä½¿ç”¨ RGB æ­å¹¾é‡Œå¾—è·é›¢
               const distance = Math.sqrt(
                 Math.pow(rgb[0] - existingRgb[0], 2) +
                 Math.pow(rgb[1] - existingRgb[1], 2) +
                 Math.pow(rgb[2] - existingRgb[2], 2)
               );
               
               // å°æ–¼æ·ºè‰²ç³»ä½¿ç”¨æ›´åš´æ ¼çš„æ¨™æº–
               const isLightColor = rgb[0] > 240 && rgb[1] > 240 && rgb[2] > 240;
               const isExistingLight = existingRgb[0] > 240 && existingRgb[1] > 240 && existingRgb[2] > 240;
               
               const threshold = (isLightColor && isExistingLight) ? 15 : 40;
               
               if (distance < threshold) {
                 isDuplicate = true;
                 break;
               }
             }
             
             if (!isDuplicate) {
               uniqueColors.push(color);
             }
           }
           
           // å¦‚æœå»é‡å¾Œçš„é¡è‰²æ•¸é‡å°‘æ–¼ç­‰æ–¼ maxColorsï¼Œç›´æ¥è¿”å›
           if (uniqueColors.length <= maxColors) {
             
             return uniqueColors.map(c => typeof c === 'string' ? c : rgbToHex(...c));
           }
          
          // ç°¡åŒ–çš„é¸æ“‡é‚è¼¯ï¼šæŒ‰ RGB å€¼æ’åº
          const colorsWithRgb = uniqueColors.map((color, index) => {
            const rgb = Array.isArray(color) ? color : hexToRgbArr(color);
            return {
              original: color,
              rgb: rgb,
              index: index
            };
          });
          
          // æŒ‰ RGB ç¸½å’Œæ’åºï¼Œå„ªå…ˆé¸æ“‡é¡è‰²è¼ƒæ·±çš„é¡è‰²
          colorsWithRgb.sort((a, b) => {
            const sumA = a.rgb[0] + a.rgb[1] + a.rgb[2];
            const sumB = b.rgb[0] + b.rgb[1] + b.rgb[2];
            return sumA - sumB; // å„ªå…ˆé¸æ“‡è¼ƒæ·±çš„é¡è‰²
          });
          
          // é¸æ“‡å‰ maxColors å€‹é¡è‰²ï¼Œä½†é¿å…éæ–¼ç›¸ä¼¼çš„é¡è‰²
          const selectedColors = [];
          for (const color of colorsWithRgb) {
            if (selectedColors.length >= maxColors) break;
            
            // æª¢æŸ¥æ˜¯å¦èˆ‡å·²é¸é¡è‰²éæ–¼ç›¸ä¼¼
            let tooClose = false;
            for (const selected of selectedColors) {
              const distance = Math.sqrt(
                Math.pow(color.rgb[0] - selected.rgb[0], 2) +
                Math.pow(color.rgb[1] - selected.rgb[1], 2) +
                Math.pow(color.rgb[2] - selected.rgb[2], 2)
              );
              
              // å°æ–¼æ·ºè‰²ç³»ä½¿ç”¨æ›´åš´æ ¼çš„æ¨™æº–
              const isLightColor = color.rgb[0] > 240 && color.rgb[1] > 240 && color.rgb[2] > 240;
              const isSelectedLight = selected.rgb[0] > 240 && selected.rgb[1] > 240 && selected.rgb[2] > 240;
              const threshold = (isLightColor && isSelectedLight) ? 20 : 50;
              
              if (distance < threshold) {
                tooClose = true;
                break;
              }
            }
            
            if (!tooClose) {
              selectedColors.push(color);
            }
          }
          
          // ç¢ºä¿ä¸è¶…é maxColors æ•¸é‡
          const finalColors = selectedColors.slice(0, maxColors);
          
          
          // è½‰æ›å›åŸå§‹æ ¼å¼
          return finalColors.map(color => 
            typeof color.original === 'string' ? color.original : rgbToHex(...color.rgb)
          );
        }
        // å…¨å±€è®Šæ•¸ï¼šå­˜å„²åµæ¸¬åˆ°çš„æ‰€æœ‰é¡è‰²
        let detectedColors = [];
        let selectedColors = [];
        
        // å›ºå®šé è¦½å®¹å™¨çš„ JavaScript æ§åˆ¶
        function initStickyPreview() {
            // æª¢æŸ¥æ˜¯å¦åœ¨åœ–ç‰‡ä¸Šå‚³åˆ†é 
            if (currentTabId !== 'upload-img') return;
            
            const previewContainer = document.getElementById('preview-container');
            if (!previewContainer) return;
            
            // æª¢æŸ¥æ˜¯å¦ç‚ºæ‰‹æ©Ÿç‰ˆ
            const isMobile = window.innerWidth <= 768;
            
            if (isMobile) {
                // æ‰‹æ©Ÿç‰ˆï¼šä½¿ç”¨ç°¡å–®çš„ fixed å®šä½
                let isFixed = false;
                let originalTop = 0;
                let initialized = false;
                
                function updateSticky() {
                    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                    
                    // ç¢ºä¿åœ¨é é¢å®Œå…¨è¼‰å…¥å¾Œæ‰åˆå§‹åŒ–
                    if (!initialized) {
                        // ç­‰å¾…ä¸€ä¸‹ç¢ºä¿å…ƒç´ å®Œå…¨æ¸²æŸ“
                        setTimeout(() => {
                            originalTop = previewContainer.offsetTop;
                            initialized = true;
                        }, 100);
                        return;
                    }
                    
                    if (!isFixed) {
                        // æª¢æŸ¥æ˜¯å¦éœ€è¦è®Šæˆ fixed - ç•¶åœ–ç‰‡é è¦½å®Œå…¨é›¢é–‹ç•«é¢é ‚éƒ¨æ™‚
                        const previewRect = previewContainer.getBoundingClientRect();
                        // ç­‰åˆ°åœ–ç‰‡é è¦½å®Œå…¨é›¢é–‹ç•«é¢é ‚éƒ¨æ‰è®Šæˆ fixed
                        if (previewRect.bottom <= 0) {
                            isFixed = true;
                            previewContainer.style.position = 'fixed';
                            previewContainer.style.top = '-10px';
                            previewContainer.style.left = '50%';
                            previewContainer.style.transform = 'translateX(-50%)';
                            previewContainer.style.zIndex = '100';
                            previewContainer.style.boxShadow = '0 2px 8px var(--bg-hover)';
                            previewContainer.style.maxWidth = '95vw';
                        }
                    } else {
                        // æª¢æŸ¥æ˜¯å¦éœ€è¦ç§»é™¤ fixed - ç•¶æ»¾å‹•å›åˆ°åŸå§‹ä½ç½®é™„è¿‘æ™‚
                        if (scrollTop < originalTop - 10) {
                            isFixed = false;
                            previewContainer.style.position = '';
                            previewContainer.style.top = '';
                            previewContainer.style.left = '';
                            previewContainer.style.transform = '';
                            previewContainer.style.zIndex = '';
                            previewContainer.style.boxShadow = '';
                            previewContainer.style.maxWidth = '';
                        }
                    }
                }
                
                // ä½¿ç”¨é€šç”¨ç¯€æµå‡½æ•¸
                const throttledUpdate = createThrottledFunction(updateSticky);
                
                // å„²å­˜äº‹ä»¶ç›£è½å™¨åˆ°å…¨åŸŸè®Šæ•¸ï¼Œä»¥ä¾¿å¾ŒçºŒç§»é™¤
                window.stickyScrollHandler = throttledUpdate;
                window.addEventListener('scroll', throttledUpdate);
                window.addEventListener('resize', throttledUpdate);
                updateSticky();
                
            } else {
                // æ¡Œé¢ç‰ˆï¼šä½¿ç”¨ JavaScript æ§åˆ¶çš„ stickyï¼Œèˆ‡æ‰‹æ©Ÿç‰ˆé‚è¼¯ä¸€è‡´
                let isSticky = false;
                let originalTop = 0;
                let initialized = false;
                
                function updateDesktopSticky() {
                    // æ¡Œé¢ç‰ˆè¦åµæ¸¬ tab-content çš„æ»¾å‹•ï¼Œä¸æ˜¯ window çš„æ»¾å‹•
                    const tabContent = document.querySelector('.tab-content');
                    const scrollTop = tabContent ? tabContent.scrollTop : 0;
                    
                    // ç¢ºä¿åœ¨é é¢å®Œå…¨è¼‰å…¥å¾Œæ‰åˆå§‹åŒ–
                    if (!initialized) {
                        setTimeout(() => {
                            originalTop = previewContainer.offsetTop;
                            initialized = true;
                        }, 100);
                        return;
                    }
                    
                    if (!isSticky) {
                        // æª¢æŸ¥æ˜¯å¦éœ€è¦è®Šæˆ sticky - ç•¶åœ–ç‰‡é è¦½å®Œå…¨é›¢é–‹ç•«é¢é ‚éƒ¨æ™‚
                        const previewRect = previewContainer.getBoundingClientRect();
                        if (previewRect.bottom <= 0) {
                            isSticky = true;
                            previewContainer.style.position = 'sticky';
                            previewContainer.style.top = '10px';
                            previewContainer.style.zIndex = '100';
                            previewContainer.style.boxShadow = '0 2px 8px var(--bg-hover)';
                            previewContainer.style.maxWidth = '90vw';
                        }
                    } else {
                        // æª¢æŸ¥æ˜¯å¦éœ€è¦ç§»é™¤ sticky - ç•¶æ»¾å‹•å›åˆ°åŸå§‹ä½ç½®é™„è¿‘æ™‚
                        if (scrollTop < originalTop - 10) {
                            isSticky = false;
                            previewContainer.style.position = '';
                            previewContainer.style.top = '';
                            previewContainer.style.zIndex = '';
                            previewContainer.style.boxShadow = '';
                            previewContainer.style.maxWidth = '';
                        }
                    }
                }
                
                // ä½¿ç”¨é€šç”¨ç¯€æµå‡½æ•¸
                const throttledUpdate = createThrottledFunction(updateDesktopSticky);
                
                // å„²å­˜äº‹ä»¶ç›£è½å™¨åˆ°å…¨åŸŸè®Šæ•¸ï¼Œä»¥ä¾¿å¾ŒçºŒç§»é™¤
                window.stickyScrollHandler = throttledUpdate;
                window.stickyTabContentHandler = throttledUpdate;
                
                // æ¡Œé¢ç‰ˆè¦ç›£è½ tab-content çš„æ»¾å‹•äº‹ä»¶
                const tabContent = document.querySelector('.tab-content');
                if (tabContent) {
                    tabContent.addEventListener('scroll', throttledUpdate);
                }
                window.addEventListener('resize', throttledUpdate);
                updateDesktopSticky();
            }
        }
        
        document.getElementById('autoPaletteBtn').onclick = function() {
          if (!currentImages.length) {
            alert('è«‹å…ˆä¸Šå‚³åœ–ç‰‡');
            return;
          }
          
          // ===== é¡¯ç¤ºè¼‰å…¥ä¸­æç¤º =====
          const btn = document.getElementById('autoPaletteBtn');
          const originalText = btn.textContent;
          btn.textContent = 'è¼‰å…¥ä¸­...';
          btn.disabled = true;
          showMessage('æ­£åœ¨åˆ†æåœ–ç‰‡é¡è‰²ï¼Œè«‹ç¨å€™...', 'success');
          
          // ä½¿ç”¨ setTimeout è®“ UI æœ‰æ™‚é–“æ›´æ–°
          setTimeout(() => {
            try {
              const img = currentImages[currentPreviewIndex] || currentImages[0];
              let ctx = img.context;
              if (!ctx && img.canvas) ctx = img.canvas.getContext('2d');
              if (!ctx) {
                alert('ç„¡æ³•å–å¾—åœ–ç‰‡åƒç´ ');
                return;
              }
              const w = img.width || img.canvas.width;
              const h = img.height || img.canvas.height;
              const imageData = ctx.getImageData(0,0,w,h).data;
              
              // æ™ºèƒ½åµæ¸¬åœ–ç‰‡ä¸­çš„æ‰€æœ‰ä¸»è¦é¡è‰²
              showMessage('æ­£åœ¨æ™ºèƒ½åˆ†æåœ–ç‰‡é¡è‰²...', 'success');
              
              // ä½¿ç”¨ K-means ç”¢ç”Ÿå€™é¸é¡è‰²
              let centers = getPaletteKMeans(imageData, 128, 15); // ç”¢ç”Ÿæ›´å¤šå€™é¸é¡è‰²
              let centersRgb = centers.map(hex => hexToRgbArr(hex));
              
              // æ™ºèƒ½å»é‡å’Œæ’åºï¼Œä½†ä¸é™åˆ¶æ•¸é‡
              detectedColors = smartColorSelection(centersRgb, 25); // å¢åŠ åˆ°25å€‹é¡è‰²ä¾›é¸æ“‡
              
              
              // é¡¯ç¤ºé¡è‰²é¸æ“‡ç•Œé¢
              showColorSelectionInterface();
              
              // ===== æ¢å¾©æŒ‰éˆ•ç‹€æ…‹ä¸¦åˆ‡æ›æ–‡å­— =====
              btn.textContent = 'é‡æ–°åµæ¸¬é¡è‰²';
              btn.disabled = false;
              showMessage(`åµæ¸¬å®Œæˆï¼è«‹å¾ ${detectedColors.length} å€‹é¡è‰²ä¸­é¸æ“‡ 2-8 å€‹é¡è‰²`, 'success');
              
            } catch (error) {
              // ===== éŒ¯èª¤è™•ç† =====
              btn.textContent = 'åµæ¸¬åœ–ç‰‡é¡è‰²';
              btn.disabled = false;
              showMessage('é¡è‰²åˆ†æå¤±æ•—ï¼š' + error.message, 'error');
              console.error('è‡ªå‹•åµæ¸¬é¡è‰²éŒ¯èª¤:', error);
            }
          }, 10);
        };
        // ç¢ºèªç”Ÿæˆèª¿è‰²ç›¤
        document.getElementById('confirmPaletteBtn').onclick = function() {
          if (selectedColors.length < 2) {
            showMessage('è«‹è‡³å°‘é¸æ“‡2å€‹é¡è‰²', 'error');
            return;
          }
          
          // è¨­å®šèª¿è‰²ç›¤åç¨±
          paletteName = document.getElementById('autoPaletteName').value || 'æ™ºèƒ½èª¿è‰²ç›¤';
          
          // è¨­å®š currentPaletteï¼ˆå°‡åå…­é€²åˆ¶é¡è‰²è½‰æ›ç‚º RGB é™£åˆ—ï¼‰
          currentPalette = selectedColors.map(color => {
            if (Array.isArray(color)) {
              return color;
            } else if (typeof color === 'string') {
              return hexToRgb(color);
            } else {
              console.error('æœªçŸ¥çš„é¡è‰²æ ¼å¼:', color);
              return [0, 0, 0];
            }
          });
          
          // æ›´æ–° UI é¡¯ç¤º
          updateColorIndexAndPaletteNameUI();
          updateCurrentPaletteStatus();
          
          // ç”Ÿæˆèª¿è‰²ç›¤æ•¸æ“š
          const paletteObj = { name: paletteName, colorList: selectedColors };
          const result = JSON.stringify(paletteObj);
          document.getElementById('autoPaletteResult').value = result;
          document.getElementById('autoPaletteResult').style.display = '';
          document.getElementById('autoPaletteDownloadBtn').style.display = '';
          
          showMessage(`å·²ç”Ÿæˆèª¿è‰²ç›¤ï¼ŒåŒ…å« ${selectedColors.length} å€‹é¡è‰²`, 'success');
          
          // é‡æ–°è™•ç†æ‰€æœ‰å·²è¼‰å…¥çš„åœ–ç‰‡ä»¥æ‡‰ç”¨æ–°çš„èª¿è‰²ç›¤
          reprocessImagesWithPalette();
          // èª¿è‰²ç›¤è¼‰å…¥å¾Œè‡ªå‹•åˆ‡æ›åˆ° canvas é è¦½
          showingCanvas = true;
          updatePreview();
        };
        

        
        document.getElementById('autoPaletteDownloadBtn').onclick = function() {
          const text = document.getElementById('autoPaletteResult').value;
          const name = document.getElementById('autoPaletteName').value || 'æ™ºèƒ½èª¿è‰²ç›¤';
          const blob = new Blob([text], {type:'application/octet-stream'});
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = name + '.mosipalette';
          document.body.appendChild(a);
          a.click();
          setTimeout(()=>{ document.body.removeChild(a); }, 100);
        };
        // åœ¨åœ–ç‰‡ onloadï¼ˆå–®åœ–/å¤šåœ–ï¼‰å¾Œå‘¼å« showAutoPaletteSection(true)
        // åœ¨æ¸…é™¤æŒ‰éˆ•æ™‚å‘¼å« showAutoPaletteSection(false)

        // æ–°å¢ï¼šè‰²å½©ç©ºé–“é¸æ“‡è®Šæ›´äº‹ä»¶
        document.getElementById('quantizeMethod').addEventListener('change', function() {
          // ç•¶ç”¨æˆ¶æ”¹è®Šè‰²å½©ç©ºé–“é¸æ“‡æ™‚ï¼Œé‡æ–°è¨ˆç®—è‰²éšåŒ–
          if (currentImages.length && currentPalette) {
            reprocessImagesWithPalette();
            updatePreview();
            showMessage(`å·²åˆ‡æ›åˆ° ${this.value === 'hsl' ? 'HSL' : 'LAB'} è‰²å½©ç©ºé–“`, 'success');
          }
        });

        // æ–°å¢ï¼šå¾æ–‡å­—åŒ¯å…¥èª¿è‰²ç›¤
        document.getElementById('paletteTextImportBtn').onclick = function() {
          const text = document.getElementById('paletteTextImport').value.trim();
          if (!text) {
            showMessage('è«‹è²¼ä¸Šèª¿è‰²ç›¤æ•¸æ“š', 'error');
            return;
          }
          try {
            const obj = JSON.parse(text);
            paletteName = obj.name || "palette";
            let colorList = obj.colorList || [];
            // ç›´æ¥ä½¿ç”¨åŸå§‹é¡è‰²ï¼Œä¸é€²è¡Œæ™ºèƒ½å»é‡
            if (colorList.length < 2) {
              showMessage('èª¿è‰²ç›¤é¡è‰²æ•¸é‡éœ€è‡³å°‘2è‰²', 'error');
              currentPalette = null;
              paletteName = "";
              showPalettePreview([]);
              
              return;
            }
            // ç¢ºä¿ currentPalette æ˜¯ RGB é™£åˆ—æ ¼å¼
            currentPalette = colorList.map(color => {
              if (Array.isArray(color)) {
                return color;
              } else if (typeof color === 'string') {
                return hexToRgb(color);
              } else {
                return [0, 0, 0];
              }
            });
            showPalettePreview(currentPalette);
            showMessage('èª¿è‰²ç›¤åŒ¯å…¥æˆåŠŸ', 'success');
            
          } catch (err) {
            showMessage('palette è§£æå¤±æ•—: ' + err, 'error');
            currentPalette = null;
            paletteName = "";
            showPalettePreview([]);
            
          }
          updateColorIndexAndPaletteNameUI();
          updateCurrentPaletteStatus();
          renderBatchSpriteSettings();
          // é‡æ–°è™•ç†æ‰€æœ‰å·²è¼‰å…¥çš„åœ–ç‰‡ä»¥æ‡‰ç”¨æ–°çš„èª¿è‰²ç›¤
          reprocessImagesWithPalette();
          // èª¿è‰²ç›¤è¼‰å…¥å¾Œè‡ªå‹•åˆ‡æ›åˆ° canvas é è¦½
          showingCanvas = true;
          updatePreview();
        };
        // åˆå§‹åŒ–ä¸‹æ‹‰é¸å–®
        function initMobileTabSelect() {
          const catSel = document.getElementById('tab-category-select');
          const tabSel = document.getElementById('tab-select');
          // å¡«å……æ¯é¡åˆ¥
          catSel.innerHTML = '';
          tabCategories.forEach((cat, i) => {
            const opt = document.createElement('option');
            opt.value = cat.value;
            opt.textContent = cat.label;
            catSel.appendChild(opt);
          });
          // æ ¹æ“šç¬¬ä¸€å€‹æ¯é¡åˆ¥å¡«å……å­é¡åˆ¥
          updateTabSelectByCategory(catSel.value || tabCategories[0].value);
        }
        function updateTabSelectByCategory(catValue) {
          const tabSel = document.getElementById('tab-select');
          tabSel.innerHTML = '';
          const cat = tabCategories.find(c => c.value === catValue) || tabCategories[0];
          cat.children.forEach(child => {
            const opt = document.createElement('option');
            opt.value = child.value;
            opt.textContent = child.label;
            tabSel.appendChild(opt);
          });
        }
        // åˆ‡æ›æ¯é¡åˆ¥æ™‚ï¼Œæ›´æ–°å­é¡åˆ¥
        document.getElementById('tab-category-select').addEventListener('change', function() {
          updateTabSelectByCategory(this.value);
          // åˆ‡åˆ°ç¬¬ä¸€å€‹å­é¡åˆ¥
          const tabSel = document.getElementById('tab-select');
          setTab(tabSel.value);
        });
        // åˆ‡æ›å­é¡åˆ¥æ™‚ï¼Œé¡¯ç¤ºå°æ‡‰ tab
        document.getElementById('tab-select').addEventListener('change', function() {
          setTab(this.value);
        });
        // éŸ¿æ‡‰å¼é¡¯ç¤º/éš±è—ä¸‹æ‹‰é¸å–®
        function updateTabSelectVisibility() {
          const isMobile = window.innerWidth <= 768;
          document.getElementById('tab-category-select').style.display = isMobile ? '' : 'none';
          document.getElementById('tab-select').style.display = isMobile ? '' : 'none';
          // ====== æ–°å¢ï¼šåˆ‡æ›é¡¯ç¤ºæ–¹å¼æ™‚è‡ªå‹•åŒæ­¥ç•¶å‰ tab ç‹€æ…‹ ======
          if (isMobile) {
            // æ‰‹æ©Ÿç‰ˆï¼šæ ¹æ“š currentTabId è¨­å®šä¸‹æ‹‰é¸å–®
            let found = false;
            for (let cat of tabCategories) {
              if (cat.children.some(child => child.value === currentTabId)) {
                document.getElementById('tab-category-select').value = cat.value;
                updateTabSelectByCategory(cat.value);
                document.getElementById('tab-select').value = currentTabId;
                found = true;
                break;
              }
            }
            if (!found) {
              document.getElementById('tab-category-select').value = tabCategories[0].value;
              updateTabSelectByCategory(tabCategories[0].value);
              document.getElementById('tab-select').value = tabCategories[0].children[0].value;
              setTab(tabCategories[0].children[0].value);
            }
          } else {
            // æ¡Œé¢ç‰ˆï¼šæ ¹æ“š currentTabId è¨­å®š active æ¨™ç±¤
            setTab(currentTabId);
          }
        }
        window.addEventListener('resize', updateTabSelectVisibility);
        // åˆå§‹åŒ–
        initMobileTabSelect();
        updateTabSelectVisibility();
        // é è¨­é¡¯ç¤ºç¬¬ä¸€å€‹ tab
        setTab(document.getElementById('tab-select').value);

        // palette å¤šçµ„é è¦½å€å¡Š
        // æ–°å¢ï¼šé¡è‰²é¸æ“‡ç•Œé¢
        function showColorSelectionInterface() {
          const section = document.getElementById('color-selection-section');
          const grid = document.getElementById('color-grid');
          const selectedCount = document.getElementById('selected-count');
          const confirmBtn = document.getElementById('confirmPaletteBtn');
          
          if (!section || !grid) return;
          
          // é‡ç½®é¸æ“‡ç‹€æ…‹
          selectedColors = [];
          selectedCount.textContent = '0';
          confirmBtn.style.display = 'none';
          
          // é¡¯ç¤ºé¡è‰²é¸æ“‡å€åŸŸ
          section.style.display = '';
          grid.innerHTML = '';
          
          // ç‚ºæ¯å€‹åµæ¸¬åˆ°çš„é¡è‰²å‰µå»ºé¸æ“‡æŒ‰éˆ•
          detectedColors.forEach((color, index) => {
            const colorBtn = document.createElement('div');
            colorBtn.style.cssText = `
              width: 40px;
              height: 40px;
              background: ${color};
              border: 2px solid var(--bg-light);
              border-radius: 4px;
              cursor: pointer;
              position: relative;
              transition: all 0.2s;
            `;
            
            // æ·»åŠ é¸ä¸­æ¨™è¨˜
            const checkmark = document.createElement('div');
            checkmark.style.cssText = `
              position: absolute;
              top: 2px;
              right: 2px;
              width: 12px;
              height: 12px;
              background: var(--bg-color);
              border-radius: 50%;
              display: none;
              align-items: center;
              justify-content: center;
              font-size: 8px;
              color: var(--main-color);
            `;
            checkmark.textContent = 'âœ“';
            colorBtn.appendChild(checkmark);
            
            // é»æ“Šäº‹ä»¶
            colorBtn.onclick = function() {
              const isSelected = selectedColors.includes(color);
              
              if (isSelected) {
                // å–æ¶ˆé¸æ“‡
                selectedColors = selectedColors.filter(c => c !== color);
                colorBtn.style.border = '2px solid var(--bg-light)';
                checkmark.style.display = 'none';
              } else {
                // é¸æ“‡é¡è‰²
                if (selectedColors.length >= 8) {
                  showMessage('æœ€å¤šåªèƒ½é¸æ“‡8å€‹é¡è‰²', 'error');
                  return;
                }
                selectedColors.push(color);
                colorBtn.style.border = '2px solid var(--main-color)';
                checkmark.style.display = 'flex';
              }
              
              // æ›´æ–°è¨ˆæ•¸
              selectedCount.textContent = selectedColors.length;
              
              // æ›´æ–°ç¢ºèªæŒ‰éˆ•ç‹€æ…‹
              if (selectedColors.length >= 2) {
                confirmBtn.style.display = '';
              } else {
                confirmBtn.style.display = 'none';
              }
              
              // å³æ™‚é è¦½
              updatePreviewWithSelectedColors();
            };
            
            grid.appendChild(colorBtn);
          });
        }
        
        // æ–°å¢ï¼šæ ¹æ“šé¸æ“‡çš„é¡è‰²æ›´æ–°é è¦½
        function updatePreviewWithSelectedColors() {
          if (selectedColors.length >= 2) {
            currentPalette = selectedColors.map(hexToRgb);
            showPalettePreview(currentPalette);
            // æ›´æ–° quantized é è¦½
            if (currentImages.length && currentImages[0] && currentImages[0].canvas) {
              for (let i = 0; i < currentImages.length; i++) {
                const img = currentImages[i];
                if (img && img.canvas && currentPalette) {
                  const ctx = img.context || img.canvas.getContext('2d');
                  const w = img.width || img.canvas.width;
                  const h = img.height || img.canvas.height;
                  const imgData = ctx.getImageData(0, 0, w, h);
                  // æ ¹æ“šç”¨æˆ¶é¸æ“‡çš„è‰²å½©ç©ºé–“é€²è¡Œè‰²éšåŒ–
                  const quantizeMethod = document.getElementById('quantizeMethod').value;
                  const useHsl = quantizeMethod === 'hsl';
                  img.quantized = quantizeToPalette(imgData.data, currentPalette, useHsl);
                  img.quantizedWidth = w;
                  img.quantizedHeight = h;
                }
              }
              // palette è®Šæˆå¤šè‰²æ™‚è‡ªå‹•åˆ‡ canvas é è¦½
              showingCanvas = true;
              updatePreview();
              renderBatchSpriteSettings();
            }
          }
        }

        // ===== RGB è½‰ LAB è‰²ç©ºé–“ =====
        function rgbToXyz(r, g, b) {
          r = r / 255; g = g / 255; b = b / 255;
          r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
          g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
          b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
          let x = r * 0.4124 + g * 0.3576 + b * 0.1805;
          let y = r * 0.2126 + g * 0.7152 + b * 0.0722;
          let z = r * 0.0193 + g * 0.1192 + b * 0.9505;
          return [x * 100, y * 100, z * 100];
        }
        function xyzToLab(x, y, z) {
          let refX = 95.047, refY = 100.0, refZ = 108.883;
          x = x / refX; y = y / refY; z = z / refZ;
          x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;
          y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;
          z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;
          let L = (116 * y) - 16;
          let a = 500 * (x - y);
          let b = 200 * (y - z);
          return [L, a, b];
        }
        function rgbToLab(r, g, b) {
          const [x, y, z] = rgbToXyz(r, g, b);
          return xyzToLab(x, y, z);
        }
        function labDist(lab1, lab2) {
          return Math.sqrt(
            (lab1[0] - lab2[0]) ** 2 +
            (lab1[1] - lab2[1]) ** 2 +
            (lab1[2] - lab2[2]) ** 2
          );
        }
        
        // é é¢è¼‰å…¥å®Œæˆå¾Œåˆå§‹åŒ–
        window.addEventListener('load', function() {
            setupFileInputs();
            // åˆå§‹åŒ–æ™‚éš±è—æŒ‰éˆ•å®¹å™¨ï¼ˆå–®åœ–æ¨¡å¼ï¼‰
            document.getElementById('preview-btn-container').style.display = 'none';
            // åˆå§‹åŒ–èª¿è‰²ç›¤ç‹€æ…‹é¡¯ç¤º
            updateCurrentPaletteStatus();
            

        });

        function updatePreview() {
          const imgEl = document.getElementById('preview-img');
          const canvasEl = document.getElementById('preview-canvas');
          const prevBtn = document.getElementById('preview-prev-btn');
          const nextBtn = document.getElementById('preview-next-btn');
          const label = document.getElementById('preview-index-label');
          const previewResultBtn = document.getElementById('preview-result-btn');
          
          // æ§åˆ¶é è¦½è½‰æ›çµæœæŒ‰éˆ•çš„é¡¯ç¤º
          if (currentImages.length > 0 && allImagesLoaded) {
            previewResultBtn.style.display = 'block';
          } else {
            previewResultBtn.style.display = 'none';
          }
          // å–®è‰²æ¨¡å¼
          if (!currentPalette) {
            showingCanvas = false;
            imgEl.style.display = '';
            canvasEl.style.display = 'none';
            if (!batchMode || currentImages.length <= 1) {
              document.getElementById('preview-btn-container').style.display = 'none';
            } else {
              document.getElementById('preview-btn-container').style.display = 'flex';
              prevBtn.disabled = (currentPreviewIndex === 0);
              nextBtn.disabled = (currentPreviewIndex === currentImages.length-1);
              label.textContent = `${currentPreviewIndex+1} / ${currentImages.length}`;
            }
            // ç«‹å³è¨­å®šimg src
            if (currentImages[currentPreviewIndex] && currentImages[currentPreviewIndex].canvas) {
              imgEl.src = currentImages[currentPreviewIndex].canvas.toDataURL();
            }
            imgEl.style.cursor = 'default';
            imgEl.onclick = null;
            canvasEl.onclick = null;
            imgEl.classList.remove('clickable');
            canvasEl.classList.remove('clickable');
            imgEl.classList.remove('clicked');
            canvasEl.classList.remove('clicked');
          } else {
            // å¤šè‰²æ¨¡å¼
            if (showingCanvas) {
              imgEl.style.display = 'none';
              canvasEl.style.display = '';
              // ç•«canvas
              const img = currentImages[currentPreviewIndex];
              if (img && img.quantized) {
                canvasEl.width = img.quantizedWidth;
                canvasEl.height = img.quantizedHeight;
                drawQuantizedPreview(canvasEl, img.quantizedWidth, img.quantizedHeight, img.quantized, currentPalette);
              }
              canvasEl.style.cursor = 'pointer';
              canvasEl.onclick = () => { 
                showingCanvas = false; 
                canvasEl.classList.add('clicked');
                showMessage('åˆ‡æ›ç‚ºåŸåœ–é è¦½', 'success');
                setTimeout(() => {
                  updatePreview();
                }, 200);
              };
              canvasEl.onmouseleave = () => {
                canvasEl.classList.remove('clicked');
              };
              canvasEl.classList.add('clickable');
            } else {
              imgEl.style.display = '';
              canvasEl.style.display = 'none';
              // ç«‹å³è¨­å®šimg src
              if (currentImages[currentPreviewIndex] && currentImages[currentPreviewIndex].canvas) {
                imgEl.src = currentImages[currentPreviewIndex].canvas.toDataURL();
              }
              imgEl.style.cursor = 'pointer';
              imgEl.onclick = () => { 
                showingCanvas = true; 
                imgEl.classList.add('clicked');
                showMessage('åˆ‡æ›ç‚ºè‰²éšåŒ–é è¦½', 'success');
                setTimeout(() => {
                  updatePreview();
                }, 200);
              };
              imgEl.onmouseleave = () => {
                imgEl.classList.remove('clicked');
              };
              imgEl.classList.add('clickable');
            }
            if (batchMode && currentImages.length > 1) {
              document.getElementById('preview-btn-container').style.display = 'flex';
              prevBtn.disabled = (currentPreviewIndex === 0);
              nextBtn.disabled = (currentPreviewIndex === currentImages.length-1);
              label.textContent = `${currentPreviewIndex+1} / ${currentImages.length}`;
            } else {
              document.getElementById('preview-btn-container').style.display = 'none';
            }
          }
        }

        document.getElementById('preview-prev-btn').onclick = function() {
          if (currentPreviewIndex > 0) {
            currentPreviewIndex--;
            updatePreview();
          }
        };
        document.getElementById('preview-next-btn').onclick = function() {
          if (currentPreviewIndex < currentImages.length-1) {
            currentPreviewIndex++;
            updatePreview();
          }
        };

        // 2. ç²å–ç¾æœ‰çš„é è¦½è½‰æ›çµæœæŒ‰éˆ•å’Œå®¹å™¨
        const previewResultBtn = document.getElementById('preview-result-btn');
        const previewResultContainer = document.getElementById('preview-result-container');

        // æ–°å¢é è¦½çµæœç›¸é—œè®Šæ•¸
        let currentPreviewResultIndex = 0;
        let previewResultData = [];

        previewResultBtn.onclick = function() {
            if (!currentImages.length || !allImagesLoaded) {
                showMessage('è«‹å…ˆè¼‰å…¥åœ–ç‰‡', 'error');
                return;
            }
            
            // æ¸…ç©ºé è¦½å€
            previewResultContainer.innerHTML = '';
            previewResultContainer.style.display = 'block';
            
            // å–å¾—è¨­å®š
            const data = {
                spriteName: document.getElementById("spriteName").value,
                spriteWidth: parseInt(document.getElementById("spriteWidth").value),
                spriteHeight: parseInt(document.getElementById("spriteHeight").value),
                isAvatar: document.getElementById("isAvatar").checked,
                isWall: document.getElementById("isWall").checked,
                isItem: document.getElementById("isItem").checked,
                isTransparent: document.getElementById("isTransparent").checked,
                colorIndex: parseInt(document.getElementById("colorIndex").value),
                roomName: document.getElementById("roomName").value,
                paletteName: paletteName || document.getElementById("paletteName").value,
                musicName: document.getElementById("musicName").value,
                roomWidth: parseInt(document.getElementById("roomWidth").value),
                roomHeight: parseInt(document.getElementById("roomHeight").value)
            };
            
            // è™•ç†æ‰€æœ‰åœ–ç‰‡
            previewResultData = [];
            let isMultiColor = !!(currentPalette && currentImages[0].quantized);
            
            for (let i = 0; i < currentImages.length; i++) {
                try {
                    let resultData;
                    if (isMultiColor) {
                        resultData = processQuantizedToRoomData(currentImages[i], data, currentPalette);
                    } else {
                        resultData = processImageToRoomData(currentImages[i], data);
                    }
                    previewResultData.push(resultData);
                } catch (error) {
                    showMessage(`ç¬¬${i+1}å¼µåœ–ç‰‡é è¦½è½‰æ›å¤±æ•—: ${error.message}`, 'error');
                    return;
                }
            }
            
            // é‡ç½®ç´¢å¼•ä¸¦é¡¯ç¤ºé è¦½
            currentPreviewResultIndex = 0;
            updatePreviewResult();
            
            showMessage('è½‰æ›çµæœé è¦½æˆåŠŸï¼', 'success');
        };

        function updatePreviewResult() {
            if (previewResultData.length === 0) return;
            
            const currentData = previewResultData[currentPreviewResultIndex];
            const isMultiColor = !!(currentPalette && currentImages[0].quantized);
            
            // æ¸…ç©ºé è¦½å€
            previewResultContainer.innerHTML = '';
            
            // æ¸²æŸ“ç•¶å‰é è¦½
            renderRoomPreview(currentData, isMultiColor);
            
            // å»ºç«‹é è¦½æŒ‰éˆ•å®¹å™¨ï¼ˆå¤šåœ–æ¨¡å¼æ‰é¡¯ç¤ºï¼‰
            // ä½¿ç”¨èˆ‡ç¾æœ‰é è¦½ç›¸åŒçš„é‚è¼¯ï¼šbatchMode && currentImages.length > 1
            if (batchMode && currentImages.length > 1) {
                const btnContainer = document.createElement('div');
                btnContainer.id = 'preview-result-btn-container';
                btnContainer.className = 'preview-btn-container';
                
                const prevBtn = document.createElement('button');
                prevBtn.className = 'preview-arrow-btn';
                prevBtn.textContent = '<';
                prevBtn.disabled = (currentPreviewResultIndex === 0);
                prevBtn.onclick = function() {
                    if (currentPreviewResultIndex > 0) {
                        currentPreviewResultIndex--;
                        updatePreviewResult();
                    }
                };
                
                const nextBtn = document.createElement('button');
                nextBtn.className = 'preview-arrow-btn';
                nextBtn.textContent = '>';
                nextBtn.disabled = (currentPreviewResultIndex === previewResultData.length - 1);
                nextBtn.onclick = function() {
                    if (currentPreviewResultIndex < previewResultData.length - 1) {
                        currentPreviewResultIndex++;
                        updatePreviewResult();
                    }
                };
                
                const label = document.createElement('span');
                label.className = 'preview-index-label';
                label.textContent = `${currentPreviewResultIndex + 1} / ${previewResultData.length}`;
                
                btnContainer.appendChild(prevBtn);
                btnContainer.appendChild(label);
                btnContainer.appendChild(nextBtn);
                
                // åœ¨æ¸²æŸ“é è¦½å¾Œæ’å…¥æŒ‰éˆ•å®¹å™¨
                previewResultContainer.appendChild(btnContainer);
            }
        }

        function renderRoomPreview(roomData, isMultiColor) {
            // å–å¾—æˆ¿é–“å°ºå¯¸
            const w = roomData.width || roomData.roomWidth;
            const h = roomData.height || roomData.roomHeight;
            const sw = roomData.spriteWidth;
            const sh = roomData.spriteHeight;
            const palette = isMultiColor ? (roomData.paletteName && currentPalette ? currentPalette : [[0,0,0],[255,255,255]]) : [[0,0,0],[255,255,255]];
            // å»ºç«‹ canvas
            const canvas = document.createElement('canvas');
            canvas.width = w * sw;
            canvas.height = h * sh;
            canvas.className = 'preview-canvas';
            const ctx = canvas.getContext('2d');
            
            // å…ˆå¡«æ»¿èƒŒæ™¯è‰²ï¼ˆç´¢å¼•0ï¼‰
            const bgColor = isMultiColor ? palette[0] || [255,255,255] : [255,255,255];
            ctx.fillStyle = isMultiColor ? `rgb(${bgColor[0]},${bgColor[1]},${bgColor[2]})` : 'white';
            ctx.fillRect(0, 0, w * sw, h * sh);
            
            // å»ºç«‹ spriteName->sprite æ˜ å°„
            const spriteMap = {};
            (roomData.spriteList||[]).forEach(s => { spriteMap[s.name] = s; });
            // å¡«è‰²
            (roomData.tileList||[]).forEach(tile => {
                const sprite = spriteMap[tile.spriteName];
                if (!sprite) return;
                const frame = sprite.frameList[0];
                for (let sy = 0; sy < sh; sy++) {
                    for (let sx = 0; sx < sw; sx++) {
                        const px = tile.x * sw + sx;
                        const py = tile.y * sh + sy;
                        let colorIdx = frame[sy * sw + sx];
                        if (isMultiColor) {
                            if (colorIdx < 0 || colorIdx >= palette.length) colorIdx = 0;
                            const [r,g,b] = palette[colorIdx] || [0,0,0];
                            ctx.fillStyle = `rgb(${r},${g},${b})`;
                        } else {
                            ctx.fillStyle = colorIdx ? 'black' : 'white';
                        }
                        ctx.fillRect(px, py, 1, 1);
                    }
                }
            });
            
            // æ¸…ç©ºé è¦½å€ä¸¦é‡æ–°çµ„è£å…§å®¹
            previewResultContainer.innerHTML = '';
            previewResultContainer.style.display = '';
            previewResultContainer.appendChild(canvas);
        }
    </script>
</body>
</html> 
