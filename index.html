<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mosiåœ–ç‰‡è½‰æˆ¿é–“æ•¸æ“šç”¢ç”Ÿå™¨</title>
    <style>
        @font-face {
            font-family: 'fakePearl';
            src: url('static/FakePearl-SemiBold.ttf') format('woff2'), url('static/FakePearl-SemiBold.ttf') format('ttf');
            font-weight: normal;
            font-style: normal;
        }
        * {
            box-sizing: border-box;
            font-family: "fakePearl", sans-serif;
            text-align: center;
        }
        html, body {
            background-color: #594a54;
            color: #d3cbd0;
        }
        a {
            color: #f69f8f;
        }
        canvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: pixelated;
        }
        input[type="file"] {
            padding: 1em 0;
            width: 256px;
        }
        input[type="text"], button {
            width: 14em;
            margin: 1em;
            padding: 0.25em;
            font-size: 1em;
        }
        label {
            display: flex;
            flex-wrap: wrap;
            align-content: center;
            justify-content: center;
            align-items: center;
        }
        textarea {
            height: 256px;
            width: 256px;
            font-family: monospace;
        }
        textarea, input {
            text-align: left;
            margin: 1em;
            padding: 0.25em;
            font-size: 1em;
        }
        .flex-container {
            background-color: #d3cbd0;
            display: flex;
            flex-flow: row wrap;
        }
        .section {
            margin: 0 auto;
            background-color: #d3cbd0;
            color: #594a54;
            width: 256px;
            padding-bottom: 1em;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-content: space-between;
        }
        .settings-container {
            display: flex;
            justify-content: space-between;
        }
        .sprite-settings, .room-settings {
            flex: 1;
            box-sizing: border-box;
        }
        @media (max-width: 768px) {
            .settings-container {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            .sprite-settings, .room-settings {
                flex: none;
                width: 100%;
            }
        }
        #preview {
            margin: 0 auto;
            width: 256px;
        }
        #file-list {
            list-style-type: none;
            padding: 0;
            border: 2px dashed #594A54;
            border-radius: 8px;
            margin-top: 10px;
            max-width: 400px;
        }
        #file-list li {
            display: flex;
            align-items: center;
            padding: 10px;
            margin: 5px;
            background-color: #D3CBD0;
            border: 1px solid #594A54;
            border-radius: 5px;
            cursor: grab;
            transition: background-color 0.3s;
        }
        #file-list li img {
            width: 24px;
            height: 24px;
            margin-right: 10px;
        }
        #file-list li.drag-hover {
            background-color: #9c758f;
            border-color: #594A54;
        }
        #file-list.dragging {
            border: 2px dashed #594A54;
        }
        .error {
            color: #ff6b6b;
            background-color: #ffe6e6;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .success {
            color: #51cf66;
            background-color: #ebfbee;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        #mergeSpriteFileList {
        list-style-type: none;
        padding: 0;
        border: 2px dashed #594A54;
        border-radius: 8px;
        margin-top: 10px;
        max-width: 400px;
        }
        #mergeSpriteFileList li {
        display: flex;
        align-items: center;
        padding: 10px;
        margin: 5px;
        background-color: #D3CBD0;
        border: 1px solid #594A54;
        border-radius: 5px;
        cursor: grab;
        transition: background-color 0.3s;
        }
        #mergeSpriteFileList li img {
        width: 24px;
        height: 24px;
        margin-right: 10px;
        }
        #mergeSpriteFileList li.drag-hover {
        background-color: #9c758f;
        border-color: #594A54;
        }
        #mergeSpriteFileList.dragging {
        border: 2px dashed #594A54;
        }
        /* Tab æ¨£å¼ */
        .tab-layout {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            min-height: 600px;
        }
        .tab-bar, #tab-select {
            margin-right: 0;
        }
        .tab-bar {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            min-width: 160px;
            background: #d3cbd0;
            border-radius: 10px 0 0 10px;
            box-shadow: 2px 0 8px rgba(0,0,0,0.04);
            height: 600px;
            gap: 0.2em;
        }
        .tab-btn {
            background: #d3cbd0;
            color: #594a54;
            border: none;
            border-left: 5px solid transparent;
            border-radius: 0 10px 10px 0;
            cursor: pointer;
            font-size: 1em;
            outline: none;
            text-align: left;
            transition: background 0.2s, color 0.2s, border-color 0.2s;
        }
        .tab-btn.active {
            background: #594a54;
            color: #d3cbd0;
            border-left: 5px solid #f69f8f;
            font-weight: bold;
        }
        .tab-content {
            flex: 1;
            min-width: 0;
            max-width: 600px;
            width: 100%;
            height: 600px;
            overflow-y: auto;
            background: #d3cbd0;
            border-radius: 0 10px 10px 0;
            box-sizing: border-box;
        }
        .tab-section { display: none; }
        .tab-section.active { display: block; }
        /* éŸ¿æ‡‰å¼ï¼šæ‰‹æ©Ÿç‰ˆç”¨ä¸‹æ‹‰é¸å–® */
        @media (max-width: 900px) {
            .tab-layout { flex-direction: column; min-height: 0; }
            .tab-bar { display: none !important; }
            #tab-select {
                display: block !important;
                margin: 1em auto 0.5em auto;
                width: 90%;
                max-width: 400px;
                font-size: 1.1em;
                background: #d3cbd0;
                color: #594a54;
                border: 1px solid #594a54;
                border-radius: 8px;
                padding: 0.7em 1em;
                box-shadow: 1px 1px 6px rgba(0,0,0,0.04);
            }
            .tab-content {
                max-width: 100%;
                height: auto;
                border-radius: 10px;
            }
        }
        #tab-select { display: none; }
        .header-toggle-btn {
            position: absolute;
            top: 18px;
            right: 24px;
            background: #d3cbd0;
            color: #594a54;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            font-size: 1.5em;
            cursor: pointer;
            box-shadow: 1px 1px 6px rgba(0,0,0,0.06);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, color 0.2s, transform 0.2s;
            z-index: 10;
        }
        .header-toggle-btn:hover {
            background: #f69f8f;
            color: #fff;
        }
        .header-collapsed {
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-height 0.3s, opacity 0.3s;
            padding-bottom: 0 !important;
        }
        .header-content {
            transition: max-height 0.3s, opacity 0.3s;
        }
        .header-toggle-btn.rotate {
            transform: rotate(180deg);
        }
        header { position: relative; }
    </style>
    <link rel="icon" href="static/é»‘ç§‘æŠ€.png" type="image/x-icon">
</head>
<body>
    <header>
        <button class="header-toggle-btn" id="headerToggleBtn" title="é–‹åˆèªªæ˜">â–¼</button>
        <div class="header-content" id="headerContent">
            <h1>Mosiåœ–ç‰‡è½‰æˆ¿é–“æ•¸æ“šç”¢ç”Ÿå™¨</h1>
            <p>è½‰æ›ä»»ä½•åœ–ç‰‡è‡³<a href="https://ebluvu.itch.io/mosi-ch">Mosiä¸­æ–‡ç‰ˆ</a>çš„æˆ¿é–“æ•¸æ“š</p>
            <p><a href="https://ebluvu.notion.site/M-si-5216b6a6c587449cb18c31ddd0dee61b">é—œæ–¼</a>ï½œæœ‰ä»»ä½•ç–‘å•æ­¡è¿è¯ç¹«æˆ‘</p>
            <p style="color: #f69f8f; font-weight: bold;">âœ¨ ç´”å‰ç«¯ç‰ˆæœ¬ - ç„¡éœ€ä¼ºæœå™¨ï¼Œå¯ç›´æ¥åœ¨ç€è¦½å™¨ä¸­é‹è¡Œ âœ¨</p>
        </div>
    </header>

    <div class="tab-layout">
      <div class="tab-bar">
        <button class="tab-btn active" data-tab="upload-img">åœ–ç‰‡ä¸Šå‚³</button>
        <button class="tab-btn" data-tab="sprite-settings">ç²¾éˆè¨­å®š</button>
        <button class="tab-btn" data-tab="room-settings">æˆ¿é–“è¨­å®š</button>
        <button class="tab-btn" data-tab="data">ç”Ÿæˆçµæœ</button>
        <button class="tab-btn" data-tab="merge-rooms">æˆ¿é–“åˆä½µå·¥å…·</button>
        <button class="tab-btn" data-tab="merge-sprite-section">åˆä½µç²¾éˆå·¥å…·</button>
        <button class="tab-btn" data-tab="merge-room-section">åˆä½µæˆ¿é–“å–®è‰²ç²¾éˆå·¥å…·</button>
        <button class="tab-btn" data-tab="merge-world-section">ä¸–ç•Œç´šåˆä½µå·¥å…·</button>
      </div>
      <select id="tab-select">
        <option value="upload-img">åœ–ç‰‡ä¸Šå‚³</option>
        <option value="sprite-settings">ç²¾éˆè¨­å®š</option>
        <option value="room-settings">æˆ¿é–“è¨­å®š</option>
        <option value="data">ç”Ÿæˆçµæœ</option>
        <option value="merge-rooms">æˆ¿é–“åˆä½µå·¥å…·</option>
        <option value="merge-sprite-section">åˆä½µç²¾éˆå·¥å…·</option>
        <option value="merge-room-section">åˆä½µæˆ¿é–“å–®è‰²ç²¾éˆå·¥å…·</option>
        <option value="merge-world-section">ä¸–ç•Œç´šåˆä½µå·¥å…·</option>
      </select>
      <div class="tab-content">
        <div class="flex-container">
          <div class="section tab-section active" id="upload-img">
            <h2>åœ–ç‰‡</h2>
            <img id="preview" alt="é è¦½" src="static/rest.png" style="max-width: 300px;">
            <form id="upload-form">
                <input type="file" id="file" name="file" accept="image/*" required>
                <button type="submit">è¼‰å…¥åœ–ç‰‡</button>
            </form>
            <div id="image-info" style="display: none;">
                <p>åœ–ç‰‡å°ºå¯¸: <span id="image-size"></span></p>
                <p>å»ºè­°çµ„åˆ:</p>
                <div id="suggestions" style="text-align: left; margin: 10px 0; padding: 10px; background: #f0f0f0; border-radius: 5px; max-height: 200px; overflow-y: auto;"></div>
            </div>
        </div>
          <form id="generate-form" style="width:100%;">
            <div class="settings-container">
              <div class="section tab-section" id="sprite-settings">
                    <h2>ç²¾éˆè¨­å®š</h2>
                    <label>ç²¾éˆåç¨±: <input type="text" id="spriteName" value="sprite"></label><br>
                    <label>ç²¾éˆå¯¬åº¦: <input type="number" id="spriteWidth" value="8" min="1" max="24"></label><br>
                    <label>ç²¾éˆé«˜åº¦: <input type="number" id="spriteHeight" value="8" min="1" max="24"></label><br>
                    <label>æ˜¯å¦ç‚ºä¸»è§’: <input type="checkbox" id="isAvatar"></label><br>
                    <label>æ˜¯å¦ç‚ºç‰†: <input type="checkbox" id="isWall"></label><br>
                    <label>æ˜¯å¦ç‚ºé“å…·: <input type="checkbox" id="isItem"></label><br>
                    <label>æ˜¯å¦ç‚ºé€æ˜åŒ–: <input type="checkbox" id="isTransparent"></label><br>
                    <label>é¡è‰²ç´¢å¼•:
                        <select id="colorIndex">
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                            <option value="4">4</option>
                            <option value="5">5</option>
                            <option value="6">6</option>
                            <option value="7">7</option>
                            <option value="8">8</option>
                        </select>
                    </label><br>
                    <small style="color: #666;">â€» ç²¾éˆå°ºå¯¸æœ€å¤§ç‚º 24Ã—24</small>
                    <small style="color: #2196F3; display: block; margin-top: 5px;">ğŸ’¡ ä¿®æ”¹ç²¾éˆå°ºå¯¸æœƒè‡ªå‹•è¨ˆç®—æˆ¿é–“å°ºå¯¸</small>
                </div>
                <div class="section tab-section" id="room-settings">
                    <h2>æˆ¿é–“è¨­å®š</h2>
                    <label>æˆ¿é–“åç¨±: <input type="text" id="roomName" value="room-1"></label><br>
                    <label>èª¿è‰²ç›¤åç¨±: <input type="text" id="paletteName" value="palette-1"></label><br>
                    <label>æ¨‚æ›²åç¨±: <input type="text" id="musicName" value="song-1"></label><br>
                    <label>æˆ¿é–“å¯¬åº¦: <input type="number" id="roomWidth" value="8" min="1" max="24"></label><br>
                    <label>æˆ¿é–“é•·åº¦: <input type="number" id="roomHeight" value="8" min="1" max="24"></label><br>
                    <button type="submit">ç”Ÿæˆæ•¸æ“š</button>
                    <button type="button" id="clearButton">é‡ç½®æ•¸æ“š</button>
                    <small style="color: #666;">â€» æˆ¿é–“å°ºå¯¸æœ€å¤§ç‚º 24Ã—24</small>
                    <small style="color: #2196F3; display: block; margin-top: 5px;">ğŸ’¡ ä¿®æ”¹æˆ¿é–“å°ºå¯¸æœƒè‡ªå‹•è¨ˆç®—ç²¾éˆå°ºå¯¸</small>
                </div>
            </div>
        </form>
          <div class="section tab-section" id="data">
            <h2>çµæœ</h2>
            <textarea id="output" readonly></textarea>
            <button id="download-btn" style="display: none;">ä¸‹è¼‰.JSONæ–‡ä»¶</button>
        </div>
          <div class="section tab-section" id="merge-rooms">
            <h2>æˆ¿é–“åˆä½µå·¥å…·</h2>
            <form id="merge-form">
                <label for="merge-files">ä¸Šå‚³å¤šå€‹æˆ¿é–“æ•¸æ“š (.json): </label>
                <input type="file" id="merge-files" name="merge-files" accept=".json" multiple required>
                <ul id="file-list"></ul>
                <button type="submit">åˆä½µæˆ¿é–“æ•¸æ“š</button>
            </form>
            <textarea id="merge-output" style="display: none;" readonly></textarea>
            <button id="merge-download-btn" style="display: none;">ä¸‹è¼‰åˆä½µå¾Œæ•¸æ“š</button>
        </div>
          <div class="section tab-section" id="merge-sprite-section">
            <h2>åˆä½µç²¾éˆå·¥å…·</h2>
            <input type="file" id="mergeSpriteInput" accept=".mosisprite" multiple style="margin-bottom:10px;">
            <ul id="mergeSpriteFileList"></ul>
            <div id="mergeSpriteAttrSelect" style="display:none; margin:10px 0;"></div>
            <div id="mergeSpriteError" class="error" style="display:none;"></div>
            <button id="mergeSpriteBtn" style="margin-top:10px; display:none;">åˆä½µä¸¦ä¸‹è¼‰å¤šè‰²ç²¾éˆ</button>
        </div>
          <div class="section tab-section" id="merge-room-section">
            <h2>åˆä½µæˆ¿é–“å–®è‰²ç²¾éˆå·¥å…·</h2>
            <input type="file" id="mergeRoomInput" accept=".mosiroom" style="margin-bottom:10px;">
            <div id="mergeRoomError" class="error" style="display:none;"></div>
            <button id="mergeRoomBtn" style="margin-top:10px; display:none;">åˆä½µä¸¦ä¸‹è¼‰æ–°æˆ¿é–“æª”æ¡ˆ</button>
        </div>
        <div class="section tab-section" id="merge-world-section">
          <h2>ä¸–ç•Œç´šåˆä½µå·¥å…·</h2>
          <input type="file" id="mergeWorldInput" accept=".mosi" style="margin-bottom:10px;">
          <div id="mergeWorldError" class="error" style="display:none;"></div>
          <button id="mergeWorldBtn" style="margin-top:10px; display:none;">åˆä½µä¸¦ä¸‹è¼‰æ–°ä¸–ç•Œæª”æ¡ˆ</button>
        </div>
        </div>
      </div>
    </div>
    <script>
        let currentImage = null;
        let imageCanvas = null;
        let imageContext = null;

        const uploadForm = document.getElementById("upload-form");
        const generateForm = document.getElementById("generate-form");
        const preview = document.getElementById("preview");
        const output = document.getElementById("output");
        const downloadBtn = document.getElementById("download-btn");
        const mergeFilesInput = document.getElementById("merge-files");
        const fileList = document.getElementById("file-list");
        const imageInfo = document.getElementById("image-info");
        const imageSize = document.getElementById("image-size");
        const suggestions = document.getElementById("suggestions");

        // åˆå§‹åŒ–è‡ªå‹•è¨ˆç®—åŠŸèƒ½
        setupAutoCalculation();

        // åœ–ç‰‡è¼‰å…¥è™•ç†
        uploadForm.addEventListener("submit", async (e) => {
            e.preventDefault();
            const fileInput = document.getElementById('file');
            const file = fileInput.files[0];
            
            if (!file) {
                showMessage('è«‹é¸æ“‡åœ–ç‰‡æª”æ¡ˆ', 'error');
                return;
            }

            try {
                // å‰µå»ºåœ–ç‰‡å°è±¡
                const img = new Image();
                img.onload = function() {
                    // å‰µå»º Canvas ä¾†è™•ç†åœ–ç‰‡
                    imageCanvas = document.createElement('canvas');
                    imageContext = imageCanvas.getContext('2d');
                    
                    // è¨­å®š Canvas å°ºå¯¸
                    imageCanvas.width = img.width;
                    imageCanvas.height = img.height;
                    
                    // ç¹ªè£½åœ–ç‰‡åˆ° Canvas
                    imageContext.drawImage(img, 0, 0);
                    
                    // å„²å­˜åœ–ç‰‡æ•¸æ“š
                    currentImage = {
                        width: img.width,
                        height: img.height,
                        canvas: imageCanvas,
                        context: imageContext
                    };
                    
                    // é¡¯ç¤ºé è¦½
                    preview.src = URL.createObjectURL(file);
                    preview.style.display = "block";
                    generateForm.style.display = "block";
                    
                    // é¡¯ç¤ºåœ–ç‰‡è³‡è¨Š
                    imageSize.textContent = `${img.width} x ${img.height}`;
                    
                    // è¨ˆç®—å»ºè­°çš„ç²¾éˆå’Œæˆ¿é–“å°ºå¯¸çµ„åˆ
                    const suggestions = calculateSuggestions(img.width, img.height);
                    displaySuggestions(suggestions);
                    imageInfo.style.display = "block";
                    
                    // è‡ªå‹•è¨­å®šç¬¬ä¸€å€‹å»ºè­°
                    if (suggestions.length > 0) {
                        const firstSuggestion = suggestions[0];
                        document.getElementById("spriteWidth").value = firstSuggestion.spriteWidth;
                        document.getElementById("spriteHeight").value = firstSuggestion.spriteHeight;
                        document.getElementById("roomWidth").value = firstSuggestion.roomWidth;
                        document.getElementById("roomHeight").value = firstSuggestion.roomHeight;
                    }
                    
                    showMessage('åœ–ç‰‡è¼‰å…¥æˆåŠŸï¼', 'success');
                };
                
                img.onerror = function() {
                    showMessage('åœ–ç‰‡è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ ¼å¼', 'error');
                };
                
                img.src = URL.createObjectURL(file);
                
            } catch (error) {
                console.error('åœ–ç‰‡è™•ç†éŒ¯èª¤:', error);
                showMessage('åœ–ç‰‡è™•ç†æ™‚ç™¼ç”ŸéŒ¯èª¤', 'error');
            }
        });

        // ç”Ÿæˆæ•¸æ“šè™•ç†
        generateForm.addEventListener("submit", async (e) => {
            e.preventDefault();
            
            if (!currentImage) {
                showMessage('è«‹å…ˆè¼‰å…¥åœ–ç‰‡', 'error');
                return;
            }
            
            try {
                // ç²å–è¨­å®šå€¼
                const data = {
                    spriteName: document.getElementById("spriteName").value,
                    spriteWidth: parseInt(document.getElementById("spriteWidth").value),
                    spriteHeight: parseInt(document.getElementById("spriteHeight").value),
                    isAvatar: document.getElementById("isAvatar").checked,
                    isWall: document.getElementById("isWall").checked,
                    isItem: document.getElementById("isItem").checked,
                    isTransparent: document.getElementById("isTransparent").checked,
                    colorIndex: parseInt(document.getElementById("colorIndex").value),
                    roomName: document.getElementById("roomName").value,
                    paletteName: document.getElementById("paletteName").value,
                    musicName: document.getElementById("musicName").value,
                    roomWidth: parseInt(document.getElementById("roomWidth").value),
                    roomHeight: parseInt(document.getElementById("roomHeight").value)
                };

                // é©—è­‰è¼¸å…¥
                if (data.spriteWidth <= 0 || data.spriteHeight <= 0) {
                    showMessage('ç²¾éˆå°ºå¯¸å¿…é ˆå¤§æ–¼0', 'error');
                    return;
                }
                
                if (data.roomWidth <= 0 || data.roomHeight <= 0) {
                    showMessage('æˆ¿é–“å°ºå¯¸å¿…é ˆå¤§æ–¼0', 'error');
                    return;
                }

                // æª¢æŸ¥Mosiå¼•æ“é™åˆ¶
                if (data.spriteWidth > 24 || data.spriteHeight > 24) {
                    showMessage('ç²¾éˆå°ºå¯¸ä¸èƒ½è¶…é24ï¼ˆMosiå¼•æ“é™åˆ¶ï¼‰', 'error');
                    return;
                }
                
                if (data.roomWidth > 24 || data.roomHeight > 24) {
                    showMessage('æˆ¿é–“å°ºå¯¸ä¸èƒ½è¶…é24ï¼ˆMosiå¼•æ“é™åˆ¶ï¼‰', 'error');
                    return;
                }

                // è™•ç†åœ–ç‰‡ä¸¦ç”Ÿæˆæ•¸æ“š
                const roomData = processImageToRoomData(currentImage, data);
                
                // é¡¯ç¤ºçµæœ
                output.value = JSON.stringify(roomData, null, 4);
                output.style.display = "block";
                downloadBtn.style.display = "block";
                
                showMessage('æ•¸æ“šç”ŸæˆæˆåŠŸï¼', 'success');
                
            } catch (error) {
                console.error('æ•¸æ“šç”ŸæˆéŒ¯èª¤:', error);
                showMessage('æ•¸æ“šç”Ÿæˆæ™‚ç™¼ç”ŸéŒ¯èª¤: ' + error.message, 'error');
            }
        });

        // åœ–ç‰‡è™•ç†å‡½æ•¸
        function processImageToRoomData(image, data) {
            const { width: imgWidth, height: imgHeight, context } = image;
            const { spriteWidth, spriteHeight, roomWidth, roomHeight } = data;
            
            // è¨ˆç®—éœ€è¦çš„åœ–ç‰‡å°ºå¯¸
            const requiredWidth = roomWidth * spriteWidth;
            const requiredHeight = roomHeight * spriteHeight;
            
            // æª¢æŸ¥æ˜¯å¦éœ€è¦ç¸®æ”¾
            let processedCanvas = imageCanvas;
            let processedContext = imageContext;
            let scale = 1;
            
            if (imgWidth !== requiredWidth || imgHeight !== requiredHeight) {
                // å‰µå»ºæ–°çš„ Canvas é€²è¡Œç¸®æ”¾
                const scaledCanvas = document.createElement('canvas');
                const scaledContext = scaledCanvas.getContext('2d');
                
                scaledCanvas.width = requiredWidth;
                scaledCanvas.height = requiredHeight;
                
                // ä½¿ç”¨ nearest-neighbor ç¸®æ”¾ä»¥ä¿æŒåƒç´ é¢¨æ ¼
                scaledContext.imageSmoothingEnabled = false;
                scaledContext.drawImage(imageCanvas, 0, 0, requiredWidth, requiredHeight);
                
                processedCanvas = scaledCanvas;
                processedContext = scaledContext;
                scale = requiredWidth / imgWidth;
            }
            
            // è¨ˆç®—æ¯è¡Œçš„ç²¾éˆæ•¸é‡
            const spritesPerRow = Math.floor(processedCanvas.width / spriteWidth);
            const totalSprites = spritesPerRow * Math.floor(processedCanvas.height / spriteHeight);
            
            // æª¢æŸ¥æˆ¿é–“å°ºå¯¸æ˜¯å¦åˆç†
            if (roomWidth * roomHeight > totalSprites) {
                throw new Error(`æˆ¿é–“å°ºå¯¸éå¤§ï¼Œåœ–ç‰‡åªèƒ½æä¾› ${totalSprites} å€‹ç²¾éˆï¼Œä½†æˆ¿é–“éœ€è¦ ${roomWidth * roomHeight} å€‹`);
            }
            
            const spriteData = [];
            const tileList = [];
            const uniqueSprites = new Map();
            let validSpriteCount = 0;

            // è™•ç†æ¯å€‹ç²¾éˆ
            for (let spriteIndex = 0; spriteIndex < roomWidth * roomHeight; spriteIndex++) {
                const x = (spriteIndex % spritesPerRow) * spriteWidth;
                const y = Math.floor(spriteIndex / spritesPerRow) * spriteHeight;
                
                // ç²å–ç²¾éˆå€åŸŸçš„åƒç´ æ•¸æ“š
                const imageData = processedContext.getImageData(x, y, spriteWidth, spriteHeight);
                const pixels = imageData.data;
                
                // è½‰æ›ç‚ºäºŒå€¼æ•¸æ“š
                const binaryData = [];
                for (let i = 0; i < pixels.length; i += 4) {
                    // è¨ˆç®—ç°åº¦å€¼
                    const gray = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
                    // è½‰æ›ç‚ºäºŒå€¼ï¼ˆ0ç‚ºé»‘è‰²/é€æ˜ï¼Œ1ç‚ºç™½è‰²/ä¸é€æ˜ï¼‰
                    binaryData.push(gray < 128 ? 1 : 0);
                }
                
                // æª¢æŸ¥æ˜¯å¦ç‚ºç©ºç™½ç²¾éˆ
                if (binaryData.some(pixel => pixel === 1)) {
                    const binaryKey = binaryData.join(',');
                    
                    if (!uniqueSprites.has(binaryKey)) {
                        // æ–°çš„ç²¾éˆ
                        validSpriteCount++;
                        const spriteName = `${data.spriteName}-${validSpriteCount.toString().padStart(2, '0')}`;
                        uniqueSprites.set(binaryKey, spriteName);
                        
                        spriteData.push({
                            name: spriteName,
                            isAvatar: data.isAvatar,
                            isWall: data.isWall,
                            isItem: data.isItem,
                            isTransparent: data.isTransparent,
                            colorIndex: data.colorIndex,
                            width: spriteWidth,
                            height: spriteHeight,
                            frameList: [binaryData]
                        });
                    }
                    
                    // æ·»åŠ åˆ°ç“·ç£šåˆ—è¡¨
                    tileList.push({
                        spriteName: uniqueSprites.get(binaryKey),
                        x: spriteIndex % roomWidth,
                        y: Math.floor(spriteIndex / roomWidth)
                    });
                }
            }
            
            // ç”Ÿæˆæˆ¿é–“æ•¸æ“š
            return {
                name: data.roomName,
                paletteName: data.paletteName,
                musicName: data.musicName,
                tileList: tileList,
                scriptList: {"on-enter": "", "on-exit": ""},
                width: roomWidth,
                height: roomHeight,
                spriteWidth: spriteWidth,
                spriteHeight: spriteHeight,
                spriteList: spriteData,
                processingInfo: {
                    originalSize: `${imgWidth}Ã—${imgHeight}`,
                    processedSize: `${processedCanvas.width}Ã—${processedCanvas.height}`,
                    scale: scale
                }
            };
        }

        // ä¸‹è¼‰æŒ‰éˆ•è™•ç†
        downloadBtn.addEventListener("click", () => {
            const roomName = document.getElementById("roomName").value || "room_data";
            const blob = new Blob([output.value], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${roomName}.json`;
            a.click();
            URL.revokeObjectURL(url);
        });

        // æ¸…é™¤æŒ‰éˆ•è™•ç†
        document.getElementById("clearButton").addEventListener("click", function () {
            // æ¸…ç©ºåœ–ç‰‡é è¦½
            const fileInput = document.getElementById("file");
            const preview = document.getElementById("preview");
            fileInput.value = "";
            preview.src = "static/rest.png";
            
            // æ¸…ç©ºæ•¸æ“šè¼¸å‡º
            const output = document.getElementById("output");
            output.value = "";
            output.style.display = "none";
            
            // éš±è—ä¸‹è¼‰æŒ‰éˆ•
            const downloadBtn = document.getElementById("download-btn");
            downloadBtn.style.display = "none";
            
            // éš±è—åœ–ç‰‡è³‡è¨Š
            imageInfo.style.display = "none";
            
            // é‡ç½®åœ–ç‰‡æ•¸æ“š
            currentImage = null;
            imageCanvas = null;
            imageContext = null;
            
            showMessage('æ•¸æ“šå·²æ¸…é™¤ï¼', 'success');
        });

        // æˆ¿é–“åˆä½µåŠŸèƒ½
        document.getElementById("merge-form").addEventListener("submit", async (e) => {
            e.preventDefault();

            const files = document.getElementById("merge-files").files;
            if (files.length < 2) {
                showMessage("è«‹ä¸Šå‚³è‡³å°‘å…©å€‹æˆ¿é–“æ•¸æ“šæª”æ¡ˆï¼", 'error');
                return;
            }

            try {
                let mergedData = null;

                for (const file of files) {
                    const text = await file.text();
                    const jsonData = JSON.parse(text);

                    if (!mergedData) {
                        mergedData = { ...jsonData };
                        mergedData.spriteList = [...jsonData.spriteList];
                        mergedData.tileList = [...jsonData.tileList];
                    } else {
                        // æª¢æŸ¥åŸºç¤è¨­å®šæ˜¯å¦ä¸€è‡´
                        if (
                            jsonData.roomName !== mergedData.roomName ||
                            jsonData.paletteName !== mergedData.paletteName ||
                            jsonData.musicName !== mergedData.musicName ||
                            jsonData.roomWidth !== mergedData.roomWidth ||
                            jsonData.roomHeight !== mergedData.roomHeight
                        ) {
                            showMessage(`æª”æ¡ˆ ${file.name} çš„åŸºç¤è¨­å®šèˆ‡å…¶ä»–æˆ¿é–“ä¸ä¸€è‡´ï¼Œç„¡æ³•åˆä½µï¼`, 'error');
                            return;
                        }

                        // åˆä½µç²¾éˆæ•¸æ“š
                        jsonData.spriteList.forEach(sprite => {
                            if (!mergedData.spriteList.some(s => JSON.stringify(s) === JSON.stringify(sprite))) {
                                mergedData.spriteList.push(sprite);
                            }
                        });

                        // åˆä½µç“·ç£šæ•¸æ“š
                        mergedData.tileList.push(...jsonData.tileList);
                    }
                }

                // é¡¯ç¤ºåˆä½µå¾Œæ•¸æ“š
                const mergeOutput = document.getElementById("merge-output");
                mergeOutput.value = JSON.stringify(mergedData, null, 4);
                mergeOutput.style.display = "block";

                // é¡¯ç¤ºä¸‹è¼‰æŒ‰éˆ•
                const mergeDownloadBtn = document.getElementById("merge-download-btn");
                mergeDownloadBtn.style.display = "block";

                showMessage('æˆ¿é–“åˆä½µæˆåŠŸï¼', 'success');

            } catch (error) {
                console.error('åˆä½µéŒ¯èª¤:', error);
                showMessage('åˆä½µæ™‚ç™¼ç”ŸéŒ¯èª¤: ' + error.message, 'error');
            }
        });

        // åˆä½µä¸‹è¼‰æŒ‰éˆ•
        document.getElementById("merge-download-btn").addEventListener("click", () => {
            const roomName = document.getElementById("roomName").value || "merged_room_data";
            const mergeOutput = document.getElementById("merge-output");
            const blob = new Blob([mergeOutput.value], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${roomName}.json`;
            a.click();
            URL.revokeObjectURL(url);
        });

        // æª”æ¡ˆåˆ—è¡¨è™•ç†
        mergeFilesInput.addEventListener("change", () => {
            fileList.innerHTML = "";
            Array.from(mergeFilesInput.files).forEach((file, index) => {
                const listItem = document.createElement("li");
                listItem.innerHTML = `
                    <img src="static/file-icon.png" alt="File Icon"> ${file.name}
                `;
                listItem.draggable = true;
                listItem.dataset.index = index;
                fileList.appendChild(listItem);
            });

            // æ‹–æ›³åŠŸèƒ½
            let draggedItem = null;

            fileList.addEventListener("dragstart", (e) => {
                draggedItem = e.target;
                e.dataTransfer.effectAllowed = "move";
                fileList.classList.add("dragging");
            });

            fileList.addEventListener("dragover", (e) => {
                e.preventDefault();
                const target = e.target.closest("li");
                if (target && target !== draggedItem) {
                    target.classList.add("drag-hover");
                }
            });

            fileList.addEventListener("dragleave", (e) => {
                const target = e.target.closest("li");
                if (target) {
                    target.classList.remove("drag-hover");
                }
            });

            fileList.addEventListener("drop", (e) => {
                e.preventDefault();
                const target = e.target.closest("li");
                if (target && target !== draggedItem) {
                    fileList.insertBefore(draggedItem, target);
                }
                target.classList.remove("drag-hover");
            });

            fileList.addEventListener("dragend", () => {
                fileList.classList.remove("dragging");
                fileList.querySelectorAll("li").forEach((li) => li.classList.remove("drag-hover"));
            });
        });

        // é¡¯ç¤ºè¨Šæ¯å‡½æ•¸
        function showMessage(message, type) {
            // ç§»é™¤èˆŠçš„è¨Šæ¯
            const existingMessage = document.querySelector('.error, .success');
            if (existingMessage) {
                existingMessage.remove();
            }
            
            // å‰µå»ºæ–°è¨Šæ¯
            const messageDiv = document.createElement('div');
            messageDiv.className = type;
            messageDiv.textContent = message;
            
            // æ’å…¥åˆ°é é¢é ‚éƒ¨
            document.body.insertBefore(messageDiv, document.body.firstChild);
            
            // 3ç§’å¾Œè‡ªå‹•ç§»é™¤
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.remove();
                }
            }, 3000);
        }

        // è¨ˆç®—å»ºè­°çš„ç²¾éˆå’Œæˆ¿é–“å°ºå¯¸çµ„åˆ
        function calculateSuggestions(width, height) {
            const suggestions = [];
            
            // å¸¸è¦‹çš„ç²¾éˆå°ºå¯¸ï¼ˆé™åˆ¶åœ¨24ä»¥å…§ï¼‰
            const commonSpriteSizes = [4, 8, 12, 16, 20, 24];
            
            // å¸¸è¦‹çš„æˆ¿é–“å°ºå¯¸ï¼ˆé™åˆ¶åœ¨24ä»¥å…§ï¼‰
            const commonRoomSizes = [5, 8, 10, 12, 15, 16, 20, 24];
            
            // æ–¹æ³•1ï¼šç›´æ¥æª¢æŸ¥ç²¾éˆå°ºå¯¸æ˜¯å¦èƒ½æ•´é™¤åœ–ç‰‡å°ºå¯¸
            for (const spriteSize of commonSpriteSizes) {
                if (width % spriteSize === 0 && height % spriteSize === 0) {
                    const roomWidth = width / spriteSize;
                    const roomHeight = height / spriteSize;
                    
                    // æª¢æŸ¥æˆ¿é–“å°ºå¯¸æ˜¯å¦åœ¨é™åˆ¶ç¯„åœå…§
                    if (roomWidth <= 24 && roomHeight <= 24) {
                        const score = calculateScore(roomWidth, roomHeight, spriteSize);
                        suggestions.push({
                            spriteWidth: spriteSize,
                            spriteHeight: spriteSize,
                            roomWidth: roomWidth,
                            roomHeight: roomHeight,
                            score: score,
                            description: `${roomWidth}Ã—${roomHeight} æˆ¿é–“ Ã— ${spriteSize}Ã—${spriteSize} ç²¾éˆ`,
                            scale: 1,
                            originalSize: `${width}Ã—${height}`
                        });
                    }
                }
            }
            
            // æ–¹æ³•2ï¼šå¦‚æœæ²’æœ‰æ‰¾åˆ°åˆé©çš„çµ„åˆï¼Œè¨ˆç®—ç¸®æ”¾æ¯”ä¾‹
            if (suggestions.length === 0) {
                const scaledSuggestions = calculateScaledSuggestions(width, height);
                suggestions.push(...scaledSuggestions);
            }
            
            // æŒ‰è©•åˆ†æ’åºï¼Œè©•åˆ†è¶Šé«˜è¶Šå„ªå…ˆ
            suggestions.sort((a, b) => b.score - a.score);
            
            // é™åˆ¶é¡¯ç¤ºæ•¸é‡
            return suggestions.slice(0, 10);
        }
        
        // è¨ˆç®—ç¸®æ”¾å¾Œçš„å»ºè­°çµ„åˆ
        function calculateScaledSuggestions(width, height) {
            const suggestions = [];
            const commonSpriteSizes = [4, 8, 12, 16, 20, 24];
            const commonRoomSizes = [5, 8, 10, 12, 15, 16, 20, 24];
            
            // å˜—è©¦ä¸åŒçš„ç¸®æ”¾æ¯”ä¾‹
            for (const roomWidth of commonRoomSizes) {
                for (const roomHeight of commonRoomSizes) {
                    for (const spriteSize of commonSpriteSizes) {
                        // è¨ˆç®—éœ€è¦çš„åœ–ç‰‡å°ºå¯¸
                        const requiredWidth = roomWidth * spriteSize;
                        const requiredHeight = roomHeight * spriteSize;
                        
                        // è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹
                        const scaleX = width / requiredWidth;
                        const scaleY = height / requiredHeight;
                        
                        // æª¢æŸ¥ç¸®æ”¾æ¯”ä¾‹æ˜¯å¦åˆç†ï¼ˆ0.1 åˆ° 10 ä¹‹é–“ï¼‰
                        if (scaleX >= 0.1 && scaleX <= 10 && scaleY >= 0.1 && scaleY <= 10) {
                            // ä½¿ç”¨è¼ƒå°çš„ç¸®æ”¾æ¯”ä¾‹ï¼ˆæ›´ä¿å®ˆï¼‰
                            const scale = Math.min(scaleX, scaleY);
                            
                            const score = calculateScore(roomWidth, roomHeight, spriteSize);
                            
                            // èª¿æ•´è©•åˆ†ï¼šç¸®æ”¾æ¯”ä¾‹è¶Šæ¥è¿‘1è¶Šå¥½
                            const scaleBonus = Math.max(0, 10 - Math.abs(scale - 1) * 5);
                            const finalScore = score + scaleBonus;
                            
                            suggestions.push({
                                spriteWidth: spriteSize,
                                spriteHeight: spriteSize,
                                roomWidth: roomWidth,
                                roomHeight: roomHeight,
                                score: finalScore,
                                description: `${roomWidth}Ã—${roomHeight} æˆ¿é–“ Ã— ${spriteSize}Ã—${spriteSize} ç²¾éˆ (ç¸®æ”¾ ${scale.toFixed(2)}x)`,
                                scale: scale,
                                originalSize: `${width}Ã—${height}`,
                                scaledSize: `${Math.round(requiredWidth * scale)}Ã—${Math.round(requiredHeight * scale)}`
                            });
                        }
                    }
                }
            }
            
            return suggestions;
        }
        
        // è¨ˆç®—å»ºè­°çš„è©•åˆ†
        function calculateScore(roomWidth, roomHeight, spriteSize) {
            let score = 0;
            
            // åå¥½é©ä¸­çš„æˆ¿é–“å°ºå¯¸ï¼ˆ8-20ä¹‹é–“ï¼Œä½†æœ€å¤§24ï¼‰
            if (roomWidth >= 8 && roomWidth <= 20) score += 10;
            if (roomHeight >= 8 && roomHeight <= 20) score += 10;
            
            // åå¥½é©ä¸­çš„ç²¾éˆå°ºå¯¸ï¼ˆ8-24ä¹‹é–“ï¼‰
            if (spriteSize >= 8 && spriteSize <= 24) score += 15;
            
            // åå¥½æ­£æ–¹å½¢æˆ¿é–“
            if (roomWidth === roomHeight) score += 5;
            
            // åå¥½è¼ƒå°çš„ç²¾éˆå°ºå¯¸ï¼ˆæ›´ç²¾ç´°ï¼Œä½†ä¸è¦å¤ªå°ï¼‰
            if (spriteSize >= 8 && spriteSize <= 16) score += 10;
            
            // åå¥½è¼ƒå°çš„æˆ¿é–“å°ºå¯¸ï¼ˆæ›´å¯¦ç”¨ï¼Œä½†ä¸è¦å¤ªå°ï¼‰
            if (roomWidth >= 8 && roomWidth <= 16) score += 5;
            if (roomHeight >= 8 && roomHeight <= 16) score += 5;
            
            // é¿å…æ¥µç«¯å€¼
            if (roomWidth < 5 || roomHeight < 5) score -= 10;
            if (spriteSize < 4) score -= 10;
            
            return score;
        }
        
        // é¡¯ç¤ºå»ºè­°åˆ—è¡¨
        function displaySuggestions(suggestions) {
            const suggestionsDiv = document.getElementById("suggestions");
            
            if (suggestions.length === 0) {
                suggestionsDiv.innerHTML = '<p style="color: #666;">ç„¡æ³•æ‰¾åˆ°åˆé©çš„çµ„åˆï¼Œè«‹æ‰‹å‹•èª¿æ•´å°ºå¯¸</p>';
                return;
            }
            
            let html = '<div style="margin-bottom: 10px;"><strong>é»æ“Šé¸æ“‡ï¼š</strong></div>';
            
            suggestions.forEach((suggestion, index) => {
                const isRecommended = index === 0;
                const style = isRecommended ? 
                    'background: #e8f5e8; border: 2px solid #4CAF50;' : 
                    'background: #f9f9f9; border: 1px solid #ddd;';
                
                // æ·»åŠ ç¸®æ”¾ä¿¡æ¯
                let scaleInfo = '';
                if (suggestion.scale !== 1) {
                    scaleInfo = `<div style="font-size: 0.8em; color: #ff6b35;">
                        ğŸ“ åŸåœ–: ${suggestion.originalSize} â†’ ç¸®æ”¾: ${suggestion.scale.toFixed(2)}x
                    </div>`;
                }
                
                html += `
                    <div class="suggestion-item" 
                         style="${style} padding: 8px; margin: 5px 0; border-radius: 4px; cursor: pointer;"
                         onclick="selectSuggestion(${suggestion.spriteWidth}, ${suggestion.spriteHeight}, ${suggestion.roomWidth}, ${suggestion.roomHeight})">
                        <div style="font-weight: bold; color: #333;">
                            ${isRecommended ? 'â­ ' : ''}${suggestion.description}
                        </div>
                        <div style="font-size: 0.9em; color: #666;">
                            è©•åˆ†: ${suggestion.score} | ç¸½ç²¾éˆæ•¸: ${suggestion.roomWidth * suggestion.roomHeight}
                        </div>
                        ${scaleInfo}
                    </div>
                `;
            });
            
            suggestionsDiv.innerHTML = html;
        }
        
        // é¸æ“‡å»ºè­°
        function selectSuggestion(spriteWidth, spriteHeight, roomWidth, roomHeight) {
            document.getElementById("spriteWidth").value = spriteWidth;
            document.getElementById("spriteHeight").value = spriteHeight;
            document.getElementById("roomWidth").value = roomWidth;
            document.getElementById("roomHeight").value = roomHeight;
            
            showMessage(`å·²é¸æ“‡: ${roomWidth}Ã—${roomHeight} æˆ¿é–“ Ã— ${spriteWidth}Ã—${spriteHeight} ç²¾éˆ`, 'success');
        }

        // è‡ªå‹•è¨ˆç®—åŠŸèƒ½
        function setupAutoCalculation() {
            const spriteWidthInput = document.getElementById("spriteWidth");
            const spriteHeightInput = document.getElementById("spriteHeight");
            const roomWidthInput = document.getElementById("roomWidth");
            const roomHeightInput = document.getElementById("roomHeight");

            // æ·»åŠ é˜²æŠ–åŠŸèƒ½
            let spriteTimeout, roomTimeout;

            // ç²¾éˆå°ºå¯¸è®Šæ›´æ™‚ï¼Œè‡ªå‹•è¨ˆç®—æˆ¿é–“å°ºå¯¸
            spriteWidthInput.addEventListener("input", () => {
                clearTimeout(spriteTimeout);
                spriteTimeout = setTimeout(autoCalculateRoomSize, 300);
            });
            spriteHeightInput.addEventListener("input", () => {
                clearTimeout(spriteTimeout);
                spriteTimeout = setTimeout(autoCalculateRoomSize, 300);
            });

            // æˆ¿é–“å°ºå¯¸è®Šæ›´æ™‚ï¼Œè‡ªå‹•è¨ˆç®—ç²¾éˆå°ºå¯¸
            roomWidthInput.addEventListener("input", () => {
                clearTimeout(roomTimeout);
                roomTimeout = setTimeout(autoCalculateSpriteSize, 300);
            });
            roomHeightInput.addEventListener("input", () => {
                clearTimeout(roomTimeout);
                roomTimeout = setTimeout(autoCalculateSpriteSize, 300);
            });
        }

        // è‡ªå‹•è¨ˆç®—æˆ¿é–“å°ºå¯¸
        function autoCalculateRoomSize() {
            if (!currentImage) return;

            const spriteWidth = parseInt(document.getElementById("spriteWidth").value) || 0;
            const spriteHeight = parseInt(document.getElementById("spriteHeight").value) || 0;

            if (spriteWidth > 0 && spriteHeight > 0) {
                // è¨ˆç®—æˆ¿é–“å°ºå¯¸
                const roomWidth = Math.floor(currentImage.width / spriteWidth);
                const roomHeight = Math.floor(currentImage.height / spriteHeight);

                // æª¢æŸ¥æ˜¯å¦åœ¨é™åˆ¶ç¯„åœå…§
                if (roomWidth <= 24 && roomHeight <= 24 && roomWidth > 0 && roomHeight > 0) {
                    // æš«æ™‚ç§»é™¤äº‹ä»¶ç›£è½å™¨é¿å…å¾ªç’°
                    const roomWidthInput = document.getElementById("roomWidth");
                    const roomHeightInput = document.getElementById("roomHeight");
                    
                    roomWidthInput.removeEventListener("input", autoCalculateSpriteSize);
                    roomHeightInput.removeEventListener("input", autoCalculateSpriteSize);
                    
                    roomWidthInput.value = roomWidth;
                    roomHeightInput.value = roomHeight;
                    
                    // é‡æ–°æ·»åŠ äº‹ä»¶ç›£è½å™¨
                    setTimeout(() => {
                        roomWidthInput.addEventListener("input", autoCalculateSpriteSize);
                        roomHeightInput.addEventListener("input", autoCalculateSpriteSize);
                    }, 100);
                    
                    // é¡¯ç¤ºè¨ˆç®—ä¿¡æ¯
                    showCalculationInfo(`è‡ªå‹•è¨ˆç®—: ${roomWidth}Ã—${roomHeight} æˆ¿é–“`);
                } else {
                    // å¦‚æœè¶…å‡ºé™åˆ¶ï¼Œé¡¯ç¤ºè­¦å‘Š
                    const maxRoomWidth = Math.min(24, Math.floor(currentImage.width / spriteWidth));
                    const maxRoomHeight = Math.min(24, Math.floor(currentImage.height / spriteHeight));
                    
                    if (maxRoomWidth > 0 && maxRoomHeight > 0) {
                        const roomWidthInput = document.getElementById("roomWidth");
                        const roomHeightInput = document.getElementById("roomHeight");
                        
                        roomWidthInput.removeEventListener("input", autoCalculateSpriteSize);
                        roomHeightInput.removeEventListener("input", autoCalculateSpriteSize);
                        
                        roomWidthInput.value = maxRoomWidth;
                        roomHeightInput.value = maxRoomHeight;
                        
                        setTimeout(() => {
                            roomWidthInput.addEventListener("input", autoCalculateSpriteSize);
                            roomHeightInput.addEventListener("input", autoCalculateSpriteSize);
                        }, 100);
                        
                        showCalculationInfo(`å·²èª¿æ•´è‡³æœ€å¤§å¯ç”¨å°ºå¯¸: ${maxRoomWidth}Ã—${maxRoomHeight} æˆ¿é–“`);
                    } else {
                        showCalculationInfo(`ç²¾éˆå°ºå¯¸éå¤§ï¼Œç„¡æ³•è¨ˆç®—åˆé©çš„æˆ¿é–“å°ºå¯¸`, 'warning');
                    }
                }
            }
        }

        // è‡ªå‹•è¨ˆç®—ç²¾éˆå°ºå¯¸
        function autoCalculateSpriteSize() {
            if (!currentImage) return;

            const roomWidth = parseInt(document.getElementById("roomWidth").value) || 0;
            const roomHeight = parseInt(document.getElementById("roomHeight").value) || 0;

            if (roomWidth > 0 && roomHeight > 0) {
                // è¨ˆç®—ç²¾éˆå°ºå¯¸
                const spriteWidth = Math.floor(currentImage.width / roomWidth);
                const spriteHeight = Math.floor(currentImage.height / roomHeight);

                // æª¢æŸ¥æ˜¯å¦åœ¨é™åˆ¶ç¯„åœå…§
                if (spriteWidth <= 24 && spriteHeight <= 24 && spriteWidth > 0 && spriteHeight > 0) {
                    // æš«æ™‚ç§»é™¤äº‹ä»¶ç›£è½å™¨é¿å…å¾ªç’°
                    const spriteWidthInput = document.getElementById("spriteWidth");
                    const spriteHeightInput = document.getElementById("spriteHeight");
                    
                    spriteWidthInput.removeEventListener("input", autoCalculateRoomSize);
                    spriteHeightInput.removeEventListener("input", autoCalculateRoomSize);
                    
                    spriteWidthInput.value = spriteWidth;
                    spriteHeightInput.value = spriteHeight;
                    
                    // é‡æ–°æ·»åŠ äº‹ä»¶ç›£è½å™¨
                    setTimeout(() => {
                        spriteWidthInput.addEventListener("input", autoCalculateRoomSize);
                        spriteHeightInput.addEventListener("input", autoCalculateRoomSize);
                    }, 100);
                    
                    // é¡¯ç¤ºè¨ˆç®—ä¿¡æ¯
                    showCalculationInfo(`è‡ªå‹•è¨ˆç®—: ${spriteWidth}Ã—${spriteHeight} ç²¾éˆ`);
                } else {
                    // å¦‚æœè¶…å‡ºé™åˆ¶ï¼Œé¡¯ç¤ºè­¦å‘Š
                    const maxSpriteWidth = Math.min(24, Math.floor(currentImage.width / roomWidth));
                    const maxSpriteHeight = Math.min(24, Math.floor(currentImage.height / roomHeight));
                    
                    if (maxSpriteWidth > 0 && maxSpriteHeight > 0) {
                        const spriteWidthInput = document.getElementById("spriteWidth");
                        const spriteHeightInput = document.getElementById("spriteHeight");
                        
                        spriteWidthInput.removeEventListener("input", autoCalculateRoomSize);
                        spriteHeightInput.removeEventListener("input", autoCalculateRoomSize);
                        
                        spriteWidthInput.value = maxSpriteWidth;
                        spriteHeightInput.value = maxSpriteHeight;
                        
                        setTimeout(() => {
                            spriteWidthInput.addEventListener("input", autoCalculateRoomSize);
                            spriteHeightInput.addEventListener("input", autoCalculateRoomSize);
                        }, 100);
                        
                        showCalculationInfo(`å·²èª¿æ•´è‡³æœ€å¤§å¯ç”¨å°ºå¯¸: ${maxSpriteWidth}Ã—${maxSpriteHeight} ç²¾éˆ`);
                    } else {
                        showCalculationInfo(`æˆ¿é–“å°ºå¯¸éå¤§ï¼Œç„¡æ³•è¨ˆç®—åˆé©çš„ç²¾éˆå°ºå¯¸`, 'warning');
                    }
                }
            }
        }

        // é¡¯ç¤ºè¨ˆç®—ä¿¡æ¯
        function showCalculationInfo(message, type = 'info') {
            // ç§»é™¤èˆŠçš„è¨ˆç®—ä¿¡æ¯
            const existingInfo = document.querySelector('.calculation-info');
            if (existingInfo) {
                existingInfo.remove();
            }
            
            // å‰µå»ºæ–°çš„è¨ˆç®—ä¿¡æ¯
            const infoDiv = document.createElement('div');
            infoDiv.className = 'calculation-info';
            infoDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 10px 15px;
                border-radius: 5px;
                color: white;
                font-size: 14px;
                z-index: 1000;
                max-width: 300px;
                word-wrap: break-word;
            `;
            
            // æ ¹æ“šé¡å‹è¨­å®šé¡è‰²
            if (type === 'warning') {
                infoDiv.style.backgroundColor = '#ff9800';
            } else {
                infoDiv.style.backgroundColor = '#2196F3';
            }
            
            infoDiv.textContent = message;
            
            // æ’å…¥åˆ°é é¢
            document.body.appendChild(infoDiv);
            
            // 3ç§’å¾Œè‡ªå‹•ç§»é™¤
            setTimeout(() => {
                if (infoDiv.parentNode) {
                    infoDiv.remove();
                }
            }, 3000);
        }

        // ====== å…¨åŸŸå‹•ç•«å¹€è£œé½Šå‡½æ•¸ ======
        function padFrames(frames, maxLen) {
            if (frames.length === maxLen) return frames.slice();
            if (maxLen === 2) {
                return [frames[0], frames[0]];
            }
            if (maxLen === 3) {
                if (frames.length === 1) return [frames[0], frames[0], frames[0]];
                if (frames.length === 2) return [frames[0], frames[1], frames[0]];
            }
            if (maxLen === 4) {
                if (frames.length === 1) return [frames[0], frames[0], frames[0], frames[0]];
                if (frames.length === 2) return [frames[0], frames[1], frames[0], frames[1]];
                if (frames.length === 3) return [frames[0], frames[1], frames[1], frames[2]];
            }
            const arr = frames.slice();
            while (arr.length < maxLen) arr.push(JSON.parse(JSON.stringify(arr[arr.length - 1])));
            return arr;
        }

        // ===== åˆä½µç²¾éˆå·¥å…· =====
        (function(){
            const input = document.getElementById('mergeSpriteInput');
            const fileList = document.getElementById('mergeSpriteFileList');
            const attrSelect = document.getElementById('mergeSpriteAttrSelect');
            const errorDiv = document.getElementById('mergeSpriteError');
            const mergeBtn = document.getElementById('mergeSpriteBtn');
            let sprites = [];
            let attrSourceIdx = 0;

            // æ‹–æ›³æ’åº
            let dragIdx = null;
            fileList.addEventListener('dragstart', e => {
                dragIdx = Number(e.target.dataset.idx);
                e.dataTransfer.effectAllowed = 'move';
            });
            fileList.addEventListener('dragover', e => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            });
            fileList.addEventListener('drop', e => {
                e.preventDefault();
                const targetIdx = Number(e.target.closest('li').dataset.idx);
                if (dragIdx !== null && targetIdx !== dragIdx) {
                    const moved = sprites.splice(dragIdx, 1)[0];
                    sprites.splice(targetIdx, 0, moved);
                    renderFileList();
                    renderAttrSelect();
                }
                dragIdx = null;
            });

            input.addEventListener('change', async e => {
                sprites = [];
                errorDiv.style.display = 'none';
                attrSelect.style.display = 'none';
                mergeBtn.style.display = 'none';
                fileList.innerHTML = '';
                const files = Array.from(input.files);
                for (const file of files) {
                    try {
                        const text = await file.text();
                        const data = JSON.parse(text);
                        sprites.push({file, data});
                    } catch {
                        errorDiv.textContent = `æª”æ¡ˆ ${file.name} è§£æå¤±æ•—`;
                        errorDiv.style.display = '';
                        return;
                    }
                }
                if (sprites.length < 2) {
                    errorDiv.textContent = 'è«‹é¸æ“‡è‡³å°‘å…©å€‹å–®è‰²ç²¾éˆæª”æ¡ˆ';
                    errorDiv.style.display = '';
                    return;
                }
                // æª¢æŸ¥é•·å¯¬ä¸€è‡´
                const w = sprites[0].data.width, h = sprites[0].data.height;
                if (!sprites.every(s => s.data.width === w && s.data.height === h)) {
                    errorDiv.textContent = 'æ‰€æœ‰ç²¾éˆçš„å¯¬é«˜å¿…é ˆä¸€è‡´ï¼';
                    errorDiv.style.display = '';
                    return;
                }
                renderFileList();
                renderAttrSelect();
                mergeBtn.style.display = '';
            });

            function renderFileList() {
                fileList.innerHTML = '';
                sprites.forEach((s, i) => {
                    const li = document.createElement('li');
                    li.textContent = `${s.file.name} (${s.data.name || ''})`;
                    li.draggable = true;
                    li.dataset.idx = i;
                    fileList.appendChild(li);
                });
            }
            function renderAttrSelect() {
                attrSelect.style.display = '';
                attrSelect.innerHTML = 'é¸æ“‡è¦ä¿ç•™å±¬æ€§çš„ç²¾éˆï¼š';
                const select = document.createElement('select');
                sprites.forEach((s, i) => {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.textContent = `${s.file.name} (${s.data.name || ''})`;
                    select.appendChild(opt);
                });
                select.value = attrSourceIdx;
                select.onchange = e => { attrSourceIdx = Number(e.target.value); };
                attrSelect.appendChild(select);
            }

            mergeBtn.onclick = function() {
                errorDiv.style.display = 'none';
                if (sprites.length < 2) {
                    errorDiv.textContent = 'è«‹é¸æ“‡è‡³å°‘å…©å€‹å–®è‰²ç²¾éˆæª”æ¡ˆ';
                    errorDiv.style.display = '';
                    return;
                }
                // å…ˆå°‡æ‰€æœ‰å–®è‰²ç²¾éˆ frameList è½‰ç‚ºå¤šè‰²ï¼ˆ1->colorIndex, 0->0ï¼‰
                const colorFrameLists = sprites.map(s => {
                    const color = s.data.colorIndex;
                    return s.data.frameList.map(frame => frame.map(px => px === 1 ? color : 0));
                });
                // ====== æ–°å¢ï¼šå‹•ç•«å¹€è£œé½Š ======
                const maxFrameLen = Math.max(...colorFrameLists.map(frames => frames.length));
                const paddedColorFrameLists = colorFrameLists.map(frames => padFrames(frames, maxFrameLen));
                // ====== åˆä½µæ™‚ colorFrameLists æ›æˆ paddedColorFrameLists ======
                const w = sprites[0].data.width, h = sprites[0].data.height;
                const mergedFrameList = [];
                for (let f = 0; f < maxFrameLen; f++) {
                    const mergedFrame = [];
                    for (let i = 0; i < w * h; i++) {
                        let val = 0;
                        for (let sIdx = 0; sIdx < paddedColorFrameLists.length; sIdx++) {
                            const frameArr = paddedColorFrameLists[sIdx][f] || paddedColorFrameLists[sIdx][0];
                            if (frameArr[i] !== 0) val = frameArr[i];
                        }
                        mergedFrame.push(val);
                    }
                    mergedFrameList.push(mergedFrame);
                }
                // ç›´æ¥å¾ä¸‹æ‹‰é¸å–® DOM å–å€¼ï¼Œç¢ºä¿æ­£ç¢º
                const select = attrSelect.querySelector('select');
                const idx = select ? Number(select.value) : attrSourceIdx;
                const src = sprites[idx].data;
                const merged = {
                    name: src.name,
                    isAvatar: src.isAvatar,
                    isWall: src.isWall,
                    isItem: src.isItem,
                    isTransparent: src.isTransparent,
                    width: src.width,
                    height: src.height,
                    frameList: mergedFrameList,
                    scriptList: JSON.parse(JSON.stringify(src.scriptList || {}))
                };
                delete merged.colorIndex;
                const fileName = sprites[idx].file.name;
                const blob = new Blob([JSON.stringify(merged, null, 2)], {type:'application/json'});
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = fileName;
                a.click();
            };
        })();

        // ===== åˆä½µæˆ¿é–“å–®è‰²ç²¾éˆå·¥å…· =====
        (function(){
            const input = document.getElementById('mergeRoomInput');
            const errorDiv = document.getElementById('mergeRoomError');
            const mergeBtn = document.getElementById('mergeRoomBtn');
            let roomData = null, fileName = '';
            input.onchange = async function(e) {
                errorDiv.style.display = 'none';
                mergeBtn.style.display = 'none';
                if (!input.files[0]) return;
                fileName = input.files[0].name;
                try {
                    const text = await input.files[0].text();
                    roomData = JSON.parse(text);
                    mergeBtn.style.display = '';
                } catch {
                    errorDiv.textContent = 'æª”æ¡ˆæ ¼å¼éŒ¯èª¤ï¼Œè«‹ä¸Šå‚³æ­£ç¢ºçš„ .mosiroom æª”æ¡ˆ';
                    errorDiv.style.display = '';
                    roomData = null;
                }
            };
            mergeBtn.onclick = function() {
                errorDiv.style.display = 'none';
                if (!roomData) return;
                try {
                    const room = JSON.parse(JSON.stringify(roomData));
                    const spriteMap = {};
                    room.spriteList.forEach(s => spriteMap[s.name] = s);
                    // ====== é è™•ç†ï¼šæ¯å€‹é‡è¤‡æ”¾ç½®çš„ sprite éƒ½åˆ†é…ä¸€å€‹ç¨ç«‹è¤‡è£½ï¼ˆåç¨±åŠ ç·¨è™Ÿï¼‰ ======
                    // ï¼ˆå·²ä¸éœ€è¦ï¼Œç›´æ¥è·³éï¼Œä¿ç•™åŸå§‹ tileList èˆ‡ spriteListï¼‰
                    // ä¾åº§æ¨™åˆ†çµ„
                    const posMap = {};
                    room.tileList.forEach((t, idx) => {
                        const key = t.x + ',' + t.y;
                        if (!posMap[key]) posMap[key] = [];
                        posMap[key].push(idx);
                    });
                    let mergedCount = 0;
                    Object.entries(posMap).forEach(([key, idxArr]) => {
                        // æ¯ä¸€æ ¼éƒ½ç”¢ç”Ÿä¸€å€‹ç¨ç«‹çš„åˆä½µç²¾éˆ
                        const [x, y] = key.split(',').map(Number);
                        const sprites = idxArr.map(idx => spriteMap[room.tileList[idx].spriteName]);
                        // ====== æ–°å¢ï¼šå‹•ç•«å¹€è£œé½Š ======
                        // 1. å–®è‰²ç²¾éˆ frameList è½‰å¤šè‰²
                        const colorFrameLists = sprites.map(s => {
                            const color = s.colorIndex;
                            return s.frameList.map(frame => frame.map(px => px === 1 ? color : 0));
                        });
                        // 2. å–å¾—æœ€å¤§å‹•ç•«å¹€æ•¸
                        const maxFrameLen = Math.max(...colorFrameLists.map(frames => frames.length));
                        // 3. å¹€æ•¸ä¸è¶³è£œé½Š
                        const paddedColorFrameLists = colorFrameLists.map(frames => padFrames(frames, maxFrameLen));
                        // ====== åˆä½µæ™‚ colorFrameLists æ›æˆ paddedColorFrameLists ======
                        const w = sprites[0].width, h = sprites[0].height;
                        const mergedFrameList = [];
                        for (let f = 0; f < maxFrameLen; f++) {
                            const mergedFrame = [];
                            for (let i = 0; i < w * h; i++) {
                                let color = 0;
                                for (let sIdx = 0; sIdx < paddedColorFrameLists.length; sIdx++) {
                                    const val = paddedColorFrameLists[sIdx][f][i];
                                    if (val && val !== 0) color = val;
                                }
                                mergedFrame.push(color);
                            }
                            mergedFrameList.push(mergedFrame);
                        }
                        // å…ˆå®£å‘Š topSprite
                        const topSprite = sprites[sprites.length - 1];
                        // æ±ºå®šåˆä½µç²¾éˆåç¨±ï¼šåªæœ‰å¤šè‰²æ‰åŠ  -åˆä½µ(x,y)ï¼Œå–®è‰²ç¶­æŒåŸå
                        let mergedName = topSprite.name;
                        if (sprites.length > 1) {
                            mergedName = `${topSprite.name}-åˆä½µ(${x},${y})`;
                        }
                        // ===== scriptList æ–°é‚è¼¯ =====
                        let mergedScriptList = {};
                        let scriptLog = [];
                        for (let i = sprites.length - 1; i >= 0; i--) {
                            scriptLog.push({name: sprites[i].name, scriptList: sprites[i].scriptList});
                            if (isScriptListValid(sprites[i].scriptList)) {
                                mergedScriptList = JSON.parse(JSON.stringify(sprites[i].scriptList));
                                break;
                            }
                        }
                        console.log(`[åˆä½µæˆ¿é–“å–®è‰²ç²¾éˆ] (${x},${y}) sprites:`, scriptLog, 'â†’ æ¡ç”¨ scriptList:', mergedScriptList);
                        const mergedSprite = {
                            name: mergedName,
                            isAvatar: false,
                            isWall: false,
                            isItem: false,
                            isTransparent: true,
                            width: w,
                            height: h,
                            frameList: mergedFrameList,
                            scriptList: mergedScriptList
                        };
                        // å±¬æ€§ä¾†æºï¼šå–æœ€ä¸Šå±¤ç²¾éˆï¼ˆå¯èª¿æ•´ï¼‰
                        mergedSprite.isAvatar = topSprite.isAvatar;
                        mergedSprite.isWall = topSprite.isWall;
                        mergedSprite.isItem = topSprite.isItem;
                        mergedSprite.isTransparent = topSprite.isTransparent;
                        mergedSprite.scriptList = mergedScriptList;
                        console.log('[åˆä½µæˆ¿é–“å–®è‰²ç²¾éˆ] mergedSprite(å±¬æ€§è¨­å®šå¾Œ):', JSON.parse(JSON.stringify(mergedSprite)));
                        room.spriteList.push(mergedSprite);
                        // åª log é™¤ frameList ä»¥å¤–çš„å±¬æ€§
                        const { frameList, ...spriteInfo } = mergedSprite;
                        // tileList ä¿ç•™æ‰€æœ‰åŸ tileï¼Œå…¨éƒ¨æŒ‡å‘æ–°åˆä½µç²¾éˆ
                        idxArr.forEach(idx => {
                            room.tileList[idx] = {
                                spriteName: mergedSprite.name,
                                x: room.tileList[idx].x,
                                y: room.tileList[idx].y
                            };
                        });
                        mergedCount++;
                    });
                    // ç§»é™¤è¢«åˆä½µçš„ tile
                    room.tileList = room.tileList.filter(t => t);
                    if (mergedCount === 0) {
                        errorDiv.textContent = 'æ²’æœ‰éœ€è¦åˆä½µçš„åŒæ ¼å–®è‰²ç²¾éˆ';
                        errorDiv.style.display = '';
                        return;
                    }
                    // ====== æ–°å¢ï¼šåˆä½µç²¾éˆå…§å®¹å»é‡ ======
                    if (room.spriteList && room.spriteList.length > 0) {
                        const spriteContentMap = {};
                        const nameMap = {};
                        room.spriteList.forEach(s => {
                            const hash = JSON.stringify({
                                isAvatar: s.isAvatar,
                                isWall: s.isWall,
                                isItem: s.isItem,
                                isTransparent: s.isTransparent,
                                width: s.width,
                                height: s.height,
                                frameList: s.frameList,
                                scriptList: s.scriptList
                            });
                            if (!spriteContentMap[hash]) {
                                spriteContentMap[hash] = s;
                                nameMap[s.name] = s.name;
                            } else {
                                nameMap[s.name] = spriteContentMap[hash].name;
                            }
                        });
                        room.spriteList = Object.values(spriteContentMap);
                        // ä¿®æ­£ tileList æŒ‡å‘å”¯ä¸€ç²¾éˆåç¨±
                        room.tileList.forEach(tile => {
                            if (nameMap[tile.spriteName]) {
                                tile.spriteName = nameMap[tile.spriteName];
                            }
                        });
                    }
                    // ä¸‹è¼‰
                    const blob = new Blob([JSON.stringify(room, null, 2)], {type:'application/json'});
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = fileName;
                    a.click();
                } catch (e) {
                    errorDiv.textContent = 'åˆä½µå¤±æ•—ï¼š' + e.message;
                    errorDiv.style.display = '';
                    console.error('åˆä½µæˆ¿é–“å–®è‰²ç²¾éˆéŒ¯èª¤', e);
                }
            };
        })();

        // ===== ä¸–ç•Œç´šåˆä½µå·¥å…· =====
        (function(){
            const input = document.getElementById('mergeWorldInput');
            const errorDiv = document.getElementById('mergeWorldError');
            const mergeBtn = document.getElementById('mergeWorldBtn');
            let worldData = null, fileName = '';
            input.onchange = async function(e) {
                errorDiv.style.display = 'none';
                mergeBtn.style.display = 'none';
                if (!input.files[0]) return;
                fileName = input.files[0].name;
                try {
                    const text = await input.files[0].text();
                    worldData = JSON.parse(text);
                    mergeBtn.style.display = '';
                } catch {
                    errorDiv.textContent = 'æª”æ¡ˆæ ¼å¼éŒ¯èª¤ï¼Œè«‹ä¸Šå‚³æ­£ç¢ºçš„ .mosi ä¸–ç•Œæª”æ¡ˆ';
                    errorDiv.style.display = '';
                    worldData = null;
                }
            };
            mergeBtn.onclick = function() {
                errorDiv.style.display = 'none';
                if (!worldData) return;
                try {
                    // æ·±æ‹·è²ä¸–ç•Œæ•¸æ“šï¼Œå®Œæ•´ä¿ç•™æ‰€æœ‰å±¬æ€§
                    const world = JSON.parse(JSON.stringify(worldData));
                    if (!Array.isArray(world.roomList) || !Array.isArray(world.spriteList)) {
                        errorDiv.textContent = 'ä¸–ç•Œæ•¸æ“šæ ¼å¼éŒ¯èª¤ï¼Œç¼ºå°‘ roomList æˆ– spriteList';
                        errorDiv.style.display = '';
                        return;
                    }
                    // å»ºç«‹ spriteName->sprite æ˜ å°„
                    const globalSpriteMap = {};
                    world.spriteList.forEach(s => globalSpriteMap[s.name] = s);
                    // ç”¨ä¾†è¨˜éŒ„æ‰€æœ‰åˆä½µå¾Œæ–°ç²¾éˆåç¨±
                    const mergedSpriteNames = new Set();
                    // ç”¨ä¾†è¨˜éŒ„æ‰€æœ‰è¢«åˆä½µçš„åŸå§‹ç²¾éˆåç¨±
                    const mergedSourceNames = new Set();
                    // è™•ç†æ¯å€‹æˆ¿é–“
                    world.roomList.forEach(room => {
                        // å»ºç«‹æœ¬æˆ¿é–“ spriteName->sprite
                        const roomSpriteMap = {};
                        (room.spriteList||[]).forEach(s => roomSpriteMap[s.name] = s);
                        // åˆä½µ tileList
                        const posMap = {};
                        (room.tileList||[]).forEach((t, idx) => {
                            const key = t.x + ',' + t.y;
                            if (!posMap[key]) posMap[key] = [];
                            posMap[key].push(idx);
                        });
                        Object.entries(posMap).forEach(([key, idxArr]) => {
                            // æ¯æ ¼éƒ½ç”¢ç”Ÿä¸€å€‹åˆä½µç²¾éˆ
                            const [x, y] = key.split(',').map(Number);
                            // æ”¯æ´æˆ¿é–“è‡ªå¸¶ spriteListï¼Œå¦å‰‡ç”¨ä¸–ç•Œ spriteList
                            const sprites = idxArr.map(idx => {
                                const sn = room.tileList[idx].spriteName;
                                return roomSpriteMap[sn] || globalSpriteMap[sn];
                            });
                            // è¨˜éŒ„æ‰€æœ‰è¢«åˆä½µçš„åŸå§‹ç²¾éˆåç¨±
                            sprites.forEach(s => mergedSourceNames.add(s.name));
                            // å–®è‰²ç²¾éˆ frameList è½‰å¤šè‰²
                            const colorFrameLists = sprites.map(s => {
                                const color = s.colorIndex;
                                return s.frameList.map(frame => frame.map(px => px === 1 ? color : 0));
                            });
                            // å¹€è£œé½Š
                            const maxFrameLen = Math.max(...colorFrameLists.map(frames => frames.length));
                            const paddedColorFrameLists = colorFrameLists.map(frames => padFrames(frames, maxFrameLen));
                            const w = sprites[0].width, h = sprites[0].height;
                            const mergedFrameList = [];
                            for (let f = 0; f < maxFrameLen; f++) {
                                const mergedFrame = [];
                                for (let i = 0; i < w * h; i++) {
                                    let color = 0;
                                    for (let sIdx = 0; sIdx < paddedColorFrameLists.length; sIdx++) {
                                        const val = paddedColorFrameLists[sIdx][f][i];
                                        if (val && val !== 0) color = val;
                                    }
                                    mergedFrame.push(color);
                                }
                                mergedFrameList.push(mergedFrame);
                            }
                            // å–æœ€ä¸Šå±¤ç²¾éˆ
                            const topSprite = sprites[sprites.length - 1];
                            let mergedName = topSprite.name;
                            if (sprites.length > 1) {
                                mergedName = `${topSprite.name}-åˆä½µ(${x},${y})`;
                            }
                            const mergedSprite = {
                                name: mergedName,
                                isAvatar: topSprite.isAvatar,
                                isWall: topSprite.isWall,
                                isItem: topSprite.isItem,
                                isTransparent: topSprite.isTransparent,
                                width: w,
                                height: h,
                                frameList: mergedFrameList,
                                scriptList: JSON.parse(JSON.stringify(topSprite.scriptList || {}))
                            };
                            // æ–°å¢åˆ°ä¸–ç•Œ spriteList
                            world.spriteList.push(mergedSprite);
                            mergedSpriteNames.add(mergedName);
                            // tileList æŒ‡å‘æ–°åˆä½µç²¾éˆ
                            idxArr.forEach(idx => {
                                room.tileList[idx] = {
                                    spriteName: mergedSprite.name,
                                    x: room.tileList[idx].x,
                                    y: room.tileList[idx].y
                                };
                            });
                        });
                    });
                    // åˆä½µå¾Œæ¸…ç† spriteListï¼š
                    // 1. åªä¿ç•™åˆä½µå¾Œçš„æ–°ç²¾éˆï¼ˆmergedSpriteNamesï¼‰
                    // 2. ç§»é™¤æ‰€æœ‰åˆä½µå‰çš„ç²¾éˆï¼ˆmergedSourceNamesï¼‰
                    // 3. ç§»é™¤é‡è¤‡ç²¾éˆï¼ˆåŒååªç•™ä¸€å€‹ï¼‰
                    const uniqueSpriteMap = {};
                    world.spriteList.forEach(s => {
                        if (mergedSpriteNames.has(s.name)) {
                            uniqueSpriteMap[s.name] = s;
                        }
                    });
                    world.spriteList = Object.values(uniqueSpriteMap);
                    // ====== æ–°å¢ï¼šåˆä½µç²¾éˆå…§å®¹å»é‡ ======
                    const spriteContentMap = {};
                    const nameMap = {};
                    world.spriteList.forEach(s => {
                        const hash = JSON.stringify({
                            isAvatar: s.isAvatar,
                            isWall: s.isWall,
                            isItem: s.isItem,
                            isTransparent: s.isTransparent,
                            width: s.width,
                            height: s.height,
                            frameList: s.frameList,
                            scriptList: s.scriptList
                        });
                        if (!spriteContentMap[hash]) {
                            spriteContentMap[hash] = s;
                            nameMap[s.name] = s.name;
                        } else {
                            nameMap[s.name] = spriteContentMap[hash].name;
                        }
                    });
                    world.spriteList = Object.values(spriteContentMap);
                    // ä¿®æ­£æ‰€æœ‰æˆ¿é–“ tileList æŒ‡å‘å”¯ä¸€ç²¾éˆåç¨±
                    world.roomList.forEach(room => {
                        room.tileList.forEach(tile => {
                            if (nameMap[tile.spriteName]) {
                                tile.spriteName = nameMap[tile.spriteName];
                            }
                        });
                    });
                    // ä¸‹è¼‰
                    const blob = new Blob([JSON.stringify(world, null, 2)], {type:'application/json'});
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = fileName;
                    a.click();
                } catch (e) {
                    errorDiv.textContent = 'åˆä½µå¤±æ•—ï¼š' + e.message;
                    errorDiv.style.display = '';
                    console.error('ä¸–ç•Œç´šåˆä½µéŒ¯èª¤', e);
                }
            };
        })();

        // Tab åˆ‡æ›é‚è¼¯
        function setTab(tabId) {
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-section').forEach(sec => sec.classList.remove('active'));
            const btn = document.querySelector('.tab-btn[data-tab="' + tabId + '"]');
            if (btn) btn.classList.add('active');
            const sec = document.getElementById(tabId);
            if (sec) sec.classList.add('active');
            // æ‰‹æ©Ÿä¸‹æ‹‰åŒæ­¥
            const select = document.getElementById('tab-select');
            if (select && select.value !== tabId) select.value = tabId;
        }
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.onclick = function() {
                setTab(btn.dataset.tab);
            };
        });
        // éŸ¿æ‡‰å¼ä¸‹æ‹‰é¸å–®åˆ‡æ›
        document.getElementById('tab-select').addEventListener('change', function() {
            setTab(this.value);
        });
        // é è¨­é¡¯ç¤ºç¬¬ä¸€å€‹ tab
        setTab('upload-img');

        // Header é–‹åˆé‚è¼¯
        const headerBtn = document.getElementById('headerToggleBtn');
        const headerContent = document.getElementById('headerContent');
        let headerOpen = true;
        headerBtn.onclick = function() {
            headerOpen = !headerOpen;
            if (headerOpen) {
                headerContent.classList.remove('header-collapsed');
                headerBtn.classList.remove('rotate');
            } else {
                headerContent.classList.add('header-collapsed');
                headerBtn.classList.add('rotate');
            }
        };

        // ===== scriptList æœ‰æ•ˆæ€§åˆ¤æ–· =====
        function isScriptListValid(scriptList) {
            if (!scriptList || typeof scriptList !== 'object') return false;
            return Object.values(scriptList).some(v => typeof v === 'string' && v.trim() !== '');
        }
    </script>
</body>
</html> 
